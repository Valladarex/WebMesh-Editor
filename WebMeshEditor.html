<!DOCTYPE html>
<!-- 
  Version: 1.0.00
Key Changes:

**Fix: True Centroid for Mesh Refinement:** The center node created when subdividing a CQUAD4 element is now calculated as the true geometric average of all four corner nodes. This corrects a "staircasing" visual artifact that occurred with non-rectangular elements.
**Fix: Mesh Refinement:** Corrected a bug in the "Subdivide Shells" tool where all new mid-nodes were created at the same coordinate, resulting in degenerate elements. The tool now correctly creates unique mid-nodes for each edge.
**Fix: Element Creation Workflow:** After adding an element, the input focus now automatically returns to the "Node 1" field for the next element, and previous node IDs are cleared, streamlining the creation of multiple elements.
**Fix: Data Export Precision:** Corrected the data export formatting for floating-point numbers to prevent precision loss.
**Fix: Node Selection Accuracy:** Increased the raycasting threshold for node picking to improve selection accuracy on dense or large models.
**Fix: Tool State Reset:** Corrected a state management issue where the node-picking mode from one tool could interfere with the general selection tool.
**Fix: Radial Copy Axis:** The 'By Vector' method for radial copy now correctly interprets the input axis in the scene's coordinate system.
**Fix: Transform Coordinate Calculations:** Corrected a bug that caused incorrect node coordinates when transforming nodes defined in custom coordinate systems.
**Enhancement: Smarter Selection for Transforms:** Transform/copy tools will now automatically include elements in the operation if all their nodes are selected.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebMesh Editor v1.0.00</title>
  <style>
    :root {
      --bg: #0f1115; --panel: #141821; --text: #e6e8ee; --muted: #9aa3b2; --accent: #5aa9ff; --danger: #ff6b6b; --ok: #4ad295; --border: #1f2430;
    }
    html, body { 
      height: 100%; 
      margin: 0; 
      background: var(--bg); 
      color: var(--text); 
      font: 14px/1.4 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden; /* Prevent body from scrolling */
    }
    #app { 
      display: grid; 
      grid-template-columns: 320px 1fr; 
      grid-template-rows: auto 1fr; 
      height: 100vh; /* Use viewport height */
    }
    header { grid-column: 1 / -1; display: flex; align-items: center; gap: 12px; padding: 10px 14px; border-bottom: 1px solid var(--border); background: #10131a; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    header .btn { background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px 12px; cursor: pointer; }
    header .btn:hover { border-color: #2b3242; }
    header .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    #sidebar { 
      background: var(--panel); 
      border-right: 1px solid var(--border); 
      padding: 12px; 
      overflow-y: auto; /* Explicitly set vertical scroll */
      grid-row: 2;
    }
    /* Collapsible card styles */
    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 4px 0;
        user-select: none;
    }
    .card-header h2 { font-size: 13px; letter-spacing: .04em; text-transform: uppercase; margin: 0; color: var(--muted); }
    .card-header::after {
        content: '▲';
        transition: transform 0.2s ease-in-out;
        font-size: 10px;
        color: var(--muted);
    }
    .card-content {
        max-height: 1000px; /* Set a large max-height for transition */
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    }
    .card.collapsed .card-content {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .card.collapsed .card-header::after {
        transform: rotate(180deg);
    }

    .card { background: #0f1320; border: 1px solid var(--border); border-radius: 12px; padding: 10px; margin-bottom: 10px; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .row label { width: 100px; color: var(--muted); flex-shrink: 0; }
    input[type="text"], input[type="number"], select { width: 100%; background: #0d111a; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; }
    input[type="file"] { width: 100%; }
    input[type="range"] { width: 100%; accent-color: var(--accent); }
    button { background: #1a2130; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; cursor: pointer; flex-grow: 1; }
    button:hover { border-color: #2b3242; }
    #viewport { 
      position: relative; 
      grid-row: 2;
      overflow: hidden; /* Prevent viewport from causing scroll */
    }
    #canvas { width: 100%; height: 100%; display: block; }
    #dropzone { position: absolute; inset: 0; border: 2px dashed #2b3242; border-radius: 16px; display: none; align-items: center; justify-content: center; color: var(--muted); background: rgba(20, 24, 33, 0.6); pointer-events: none; }
    #status { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color: var(--muted); white-space: pre-wrap; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 12px; background: #0c1220; border: 1px solid var(--border); color: var(--muted); font-size: 12px; margin-right: 6px; }
    .danger { color: var(--danger); }
    .ok { color: var(--ok); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 0 12px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .grid-3 label { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; font-size: 12px;}
    .grid-2 .row label { width: auto; }
    .label { font-size: 11px; line-height: 1; padding: 2px 6px; background: rgba(0,0,0,0.55); border: 1px solid var(--border); border-radius: 6px; color: var(--text); pointer-events: none; transition: opacity 0.2s; }
    .label.muted { opacity: 0.8; }
    /* Model tree styles */
    #modelTreeContainer ul { list-style: none; padding-left: 12px; margin: 0; }
    #modelTreeContainer li { cursor: pointer; user-select: none; position: relative; }
    #modelTreeContainer li ul { display: none; }
    #modelTreeContainer li.open > ul { display: block; }
    #modelTreeContainer li::before { content: '►'; display: inline-block; width: 1em; color: var(--muted); }
    #modelTreeContainer li.open::before { content: '▼'; }
    /* Selection rectangle overlay */
    #selectRect { position: absolute; border: 1px dashed var(--accent); background: rgba(90,169,255,0.15); pointer-events: none; display: none; z-index: 10; }
    /* Context menu */
    #contextMenu { position: fixed; z-index: 20; background: #0d111a; border: 1px solid var(--border); border-radius: 6px; padding: 4px 0; display: none; box-shadow: 0 2px 6px rgba(0,0,0,0.5); }
    #contextMenu div { padding: 4px 12px; cursor: pointer; white-space: nowrap; }
    #contextMenu div:hover { background: #1a2130; }
    #measureResults small { color: var(--muted); font-style: italic; display: block; }
    
    /* Tab Styles */
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .tab-btn.active { color: var(--text) !important; border-bottom-color: var(--accent) !important; }
    .tab-btn:hover { color: var(--text); }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>WebMesh Editor v1.0.00</h1>
      <span class="pill">Rotate: LMB</span>
      <span class="pill">Pan: RMB</span>
      <span class="pill">Zoom: Wheel</span>
      <span class="pill">Set Pivot: Dbl-Click</span>
      <span class="pill">Box Select: Alt+Drag</span>
      <span class="pill">Polygon Select: Ctrl+Shift+Click</span>
      <div class="spacer"></div>
      <button class="btn" id="btnUndo" disabled>Undo</button>
      <button class="btn" id="btnRedo" disabled>Redo</button>
      <button class="btn" id="btnReset">Reset View</button>
      <button class="btn" id="btnExport">Export .dat</button>
    </header>

    <!-- Selection Toolbar - Right of left pane, below header -->
    <div id="selectionToolbar" style="background: var(--panel); border-bottom: 1px solid var(--border); padding: 8px 14px; display: flex; align-items: center; gap: 12px; position: fixed; top: 60px; left: 320px; right: 0; z-index: 100;">
      <span style="color: var(--muted); font-size: 13px; font-weight: 600;">SELECTION MODE:</span>
      <select id="selectModeToolbar" style="background: #0d111a; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 4px 8px; font-size: 13px;">
        <option value="node" selected>Nodes</option>
        <option value="element">Elements</option>
        <option value="load">Loads</option>
        <option value="constraint">Constraints</option>
      </select>
      <label style="display: flex; align-items: center; gap: 6px; color: var(--muted); font-size: 13px; cursor: pointer;">
        <input id="multiSelectToolbar" type="checkbox" style="margin: 0;">
        Multi Select
      </label>
      <div class="spacer"></div>
      <span id="selCountToolbar" style="color: var(--muted); font-size: 13px;">None</span>
      <button id="btnExportSelectionCSV" class="btn" style="padding: 4px 8px; font-size: 13px;">Export CSV</button>
      <button id="btnClearSelectionToolbar" class="btn" style="padding: 4px 8px; font-size: 13px;">Clear Selection</button>
    </div>

    <aside id="sidebar">
      <!-- Tab Navigation -->
      <div id="tabNavigation" style="display: flex; background: var(--panel); border-bottom: 1px solid var(--border); margin-bottom: 12px;">
        <button id="tabInspect" class="tab-btn active" style="flex: 1; padding: 12px; background: var(--panel); color: var(--text); border: none; border-bottom: 2px solid var(--accent); cursor: pointer; font-size: 14px; font-weight: 600;">Inspect</button>
        <button id="tabCreate" class="tab-btn" style="flex: 1; padding: 12px; background: var(--panel); color: var(--muted); border: none; border-bottom: 2px solid transparent; cursor: pointer; font-size: 14px; font-weight: 600;">Create</button>
        <button id="tabModify" class="tab-btn" style="flex: 1; padding: 12px; background: var(--panel); color: var(--muted); border: none; border-bottom: 2px solid transparent; cursor: pointer; font-size: 14px; font-weight: 600;">Modify</button>
      </div>

      <!-- Tab Content -->
      <div id="tabContent">
        <!-- Inspect Tab -->
        <div id="inspectTab" class="tab-content active">
          <div class="card">
            <div class="card-header"><h2>File</h2></div>
            <div class="card-content">
                <div class="row"><input id="file" type="file" accept=".dat,.bdf" /></div>
                <div class="row" style="justify-content: space-between">
                  <button id="btnSample">Load sample</button>
                  <button id="btnClear">New Model</button>
                </div>
                <div class="row" style="margin-top:6px">
                  <small class="muted">You can also drag & drop a .dat/.bdf anywhere</small>
                </div>
            </div>
          </div>

          <div class="card">
            <div class="card-header"><h2>Model Info</h2></div>
            <div class="card-content">
                <div id="modelTreeContainer"></div>
            </div>
          </div>

          <div class="card">
            <div class="card-header"><h2>Measure Tools</h2></div>
            <div class="card-content" id="measureResultsContainer">
                 <div id="measureResults">
                    <small>Select 2 nodes for distance.<br>Select 3 nodes for angle.<br>Select multiple nodes/elements for centroid & area.</small>
                 </div>
            </div>
          </div>

          <div class="card">
            <div class="card-header"><h2>Display Settings</h2></div>
            <div class="card-content">
                <div class="row"><label>Symbol Size</label><input id="symbolSize" type="number" step="0.1" value="1.0"></div>
                <div class="row"><label>Spring Size</label><input id="springSize" type="number" step="0.1" value="1.0"></div>
                <div class="row"><label>Color Mode</label>
                  <select id="colorMode">
                    <option value="default">Default</option>
                    <option value="property" selected>Property</option>
                  </select>
                </div>
                <div class="row"><label>Background</label><input id="bgColor" type="color" value="#0f1115"></div>
                <div class="row"><label>Shading</label><input type="checkbox" id="shadingToggle"></div>
                <div class="row"><label>Parallel View</label><input type="checkbox" id="parallelToggle" checked></div>
                <div class="row"><label>Show Free Edges</label><input type="checkbox" id="showFreeEdges"></div>
            </div>
          </div>

          <div class="card">
            <div class="card-header"><h2>Visibility</h2></div>
            <div class="card-content">
                <div class="row"><label>Opacity</label><input id="opacitySlider" type="range" min="0" max="1" step="0.05" value="1.0"></div>
                <div class="grid-2">
                    <div class="row"><label>Nodes</label><input type="checkbox" data-vis="nodes"></div>
                    <div class="row"><label>Forces</label><input type="checkbox" data-vis="forces" checked></div>
                    <div class="row"><label>Moments</label><input type="checkbox" data-vis="moments" checked></div>
                    <div class="row"><label>SPCs</label><input type="checkbox" data-vis="spcs" checked></div>
                    <div class="row"><label>Edges</label><input type="checkbox" data-vis="edges" checked></div>
                    <div class="row"><label>Coord Sys</label><input type="checkbox" data-vis="coords" checked></div>
                    <div class="row"><label>CQUAD4</label><input type="checkbox" data-vis="cquad4" checked></div>
                    <div class="row"><label>CTRIA3</label><input type="checkbox" data-vis="ctria3" checked></div>
                    <div class="row"><label>CBAR</label><input type="checkbox" data-vis="cbar" checked></div>
                    <div class="row"><label>CBEAM</label><input type="checkbox" data-vis="cbeam" checked></div>
                    <div class="row"><label>CBUSH</label><input type="checkbox" data-vis="cbush" checked></div>
                    <div class="row"><label>RBE2</label><input type="checkbox" data-vis="rbe2" checked></div>
                    <div class="row"><label>RBE3</label><input type="checkbox" data-vis="rbe3" checked></div>
                </div>
            </div>
          </div>

          <div class="card collapsed">
            <div class="card-header"><h2>Clipping</h2></div>
            <div class="card-content">
              <div class="row"><label>Enable</label><input id="clippingToggle" type="checkbox"></div>
              <div class="row"><label>Plane</label>
                <select id="clipPlaneSelect">
                  <option value="x">YZ Plane (Normal X)</option>
                  <option value="y">XZ Plane (Normal Y)</option>
                  <option value="z" selected>XY Plane (Normal Z)</option>
                </select>
              </div>
              <div class="row"><label>Offset</label><input id="clipOffsetSlider" type="range" min="-1" max="1" step="0.01" value="0"></div>
               <div class="row" style="justify-content: space-between">
                  <button id="setClipOriginToSelection">Set to Selection</button>
                  <button id="flipClipPlane">Flip</button>
                </div>
            </div>
          </div>

          <div class="card collapsed">
            <div class="card-header"><h2>Labels</h2></div>
            <div class="card-content">
                <div class="row"><label>Node IDs</label><input id="showNodeIds" type="checkbox"></div>
                <div class="row"><label>Element IDs</label><input id="showElemIds" type="checkbox"></div>
                <div class="row"><label>SPC DOF</label><input id="showSPCLabels" type="checkbox"></div>
                <div class="row"><label>Load Labels</label><input id="showLoadLabels" type="checkbox"></div>
                <div class="row"><label>Load Mode</label>
                  <select id="loadLabelMode">
                    <option value="resultant" selected>Resultant</option>
                    <option value="components">Components</option>
                  </select>
                </div>
                <div class="row" style="margin-top:8px;">
                  <button id="btnRefreshLabels" style="width:100%;">Refresh Labels</button>
                </div>
            </div>
          </div>

          <div class="card">
            <div class="card-header"><h2>Status</h2></div>
            <div class="card-content" id="status">Drop a .dat/.bdf file to begin…</div>
          </div>

        </div>

        <!-- Create Tab -->
        <div id="createTab" class="tab-content">
          <div class="card">
            <div class="card-header"><h2>Add Node</h2></div>
            <div class="card-content">
                <div class="row"><label>NID</label><input id="newNid" type="number" placeholder="Auto"></div>
                <div class="row"><label>X</label><input id="newX" type="number" step="any" value="0"></div>
                <div class="row"><label>Y</label><input id="newY" type="number" step="any" value="0"></div>
                <div class="row"><label>Z</label><input id="newZ" type="number" step="any" value="0"></div>
                <div class="row">
                  <button id="advancedNodeToggle" style="width:auto; padding: 2px 8px; font-size: 12px; background: none; border: none; color: var(--muted); cursor:pointer;">Advanced ▼</button>
                </div>
                <div id="advancedNodeOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                    <div class="row"><label>CP</label><input id="newCP" type="number" step="1" value="0"></div>
                    <div class="row"><label>CD</label><input id="newCD" type="number" step="1" value="0"></div>
                    <div class="row"><label>PS</label><input id="newPS" type="text" placeholder="e.g., 123"></div>
                </div>
                <div class="row" style="margin-top: 8px;"><button id="btnCopySelectedNode" disabled>Copy Selected Node Coords</button></div>
                <div class="row" style="margin-top: 8px;"><button id="btnAddNode">Add Node</button></div>
            </div>
          </div>

          <div class="card collapsed" id="addElementCard">
            <div class="card-header"><h2>Add Element</h2></div>
            <div class="card-content">
                <div class="row"><label>Type</label>
                  <select id="elemType">
                    <option value="cquad4" selected>CQUAD4</option>
                    <option value="ctria3">CTRIA3</option>
                    <option value="cbar">CBAR</option>
                    <option value="cbeam">CBEAM</option>
                    <option value="cbush">CBUSH</option>
                    <option value="rbe2">RBE2</option>
                    <option value="rbe3">RBE3</option>
                  </select>
                </div>
                <div class="row"><label>EID</label><input id="elemEid" type="number" placeholder="Auto"></div>
                <div class="row"><label>PID</label><input id="elemPid" type="number" value="1"></div>
                <div class="row elem-nodes"><label id="elemN1Label">Node 1</label><input id="elemN1" type="number" placeholder="Use selected"></div>
                <div class="row elem-nodes"><label>Node 2</label><input id="elemN2" type="number"></div>
                <div class="row elem-nodes"><label>Node 3</label><input id="elemN3" type="number"></div>
                <div class="row elem-nodes"><label>Node 4</label><input id="elemN4" type="number"></div>
                <div class="row" id="elemCmRow" style="display:none;"><label>CM</label><input id="elemCm" type="text" value="123456"></div>
                <div class="row" id="elemDepNodesRow" style="display:none;"><label>Deps</label><input id="elemDepNodes" type="text" placeholder="Multi-select or CSV"></div>
                <div class="row" id="elemIndNodesRow" style-display:none;"><label>Indeps</label><input id="elemIndNodes" type="text" placeholder="Multi-select or CSV"></div>
                <div class="row" id="cquad4AdvancedToggleRow" style="display:none;">
                    <button id="cquad4AdvancedToggle" style="width:auto; padding: 2px 8px; font-size: 12px; background: none; border: none; color: var(--muted); cursor:pointer;">Advanced ▼</button>
                </div>
                <div id="cquad4AdvancedOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                    <div class="row"><label>THETA/MCID</label><input id="elemThetaMcid" type="number" step="any" placeholder="Default 0.0"></div>
                    <div class="row"><label>ZOFFS</label><input id="elemZoffs" type="number" step="any" placeholder="Optional"></div>
                    <div class="row"><label>TFLAG</label><input id="elemTflag" type="number" step="1" placeholder="0 or 1"></div>
                    <div class="row"><label>Thicknesses</label></div>
                    <div class="grid-2">
                        <div class="row"><label>T1</label><input id="elemT1" type="number" step="any"></div>
                        <div class="row"><label>T2</label><input id="elemT2" type="number" step="any"></div>
                        <div class="row"><label>T3</label><input id="elemT3" type="number" step="any"></div>
                        <div class="row"><label>T4</label><input id="elemT4" type="number" step="any"></div>
                    </div>
                </div>
                <div class="row"><button id="btnAddElement">Add Element</button></div>
            </div>
          </div>

          <div class="card collapsed">
            <div class="card-header"><h2>Add CORD2R System</h2></div>
            <div class="card-content">
                  <div class="row"><label>CSYS ID</label><input id="csysId" type="number" value="1"></div>
                  <div class="row"><label>Ref CID</label><input id="csysRid" type="number" value="0" placeholder="0 for basic"></div>
                  <div class="row"><label>Method</label>
                    <select id="csysMethod">
                        <option value="nodes" selected>By Node IDs</option>
                        <option value="coords">By Coordinates</option>
                    </select>
                  </div>
                  <div id="csysNodes">
                      <div class="grid-3">
                        <label>Origin (G1)</label>
                        <label>Z-Axis (G2)</label>
                        <label>XZ-Plane (G3)</label>
                        <input id="csysN1" type="number" placeholder="NID">
                        <input id="csysN2" type="number" placeholder="NID">
                        <input id="csysN3" type="number" placeholder="NID">
                      </div>
                  </div>
                  <div id="csysCoords" style="display:none;">
                     <div class="grid-3">
                        <label>Origin X</label><label>Origin Y</label><label>Origin Z</label>
                        <input type="number" id="csysA1" value="0"><input type="number" id="csysA2" value="0"><input type="number" id="csysA3" value="0">
                        <label>Z-Axis X</label><label>Z-Axis Y</label><label>Z-Axis Z</label>
                        <input type="number" id="csysB1" value="0"><input type="number" id="csysB2" value="0"><input type="number" id="csysB3" value="1">
                        <label>XZ-Plane X</label><label>XZ-Plane Y</label><label>XZ-Plane Z</label>
                        <input type="number" id="csysC1" value="1"><input type="number" id="csysC2" value="0"><input type="number" id="csysC3" value="0">
                     </div>
                  </div>
                  <div class="row" style="margin-top:8px"><button id="btnAddCsys">Add CORD2R</button></div>
              </div>
          </div>

          <div class="card collapsed">
            <div class="card-header"><h2>Add Load / Constraint</h2></div>
            <div class="card-content">
                <div class="row"><label>Node ID(s)</label><input id="loadNodeId" type="text" placeholder="Selected or CSV"></div>
                <div class="row"><label>SID</label><input id="sid" type="number" value="1"></div>
                <div class="row"><label>FORCE</label><input id="fMag" type="number" step="any" value="1000"></div>
                <div class="row"><label>Dir X</label><input id="fX" type="number" step="any" value="1"></div>
                <div class="row"><label>Dir Y</label><input id="fY" type="number" step="any" value="0"></div>
                <div class="row"><label>Dir Z</label><input id="fZ" type="number" step="any" value="0"></div>
                <div class="row"><button id="btnAddForce">Add FORCE</button></div>
                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
                <div class="row"><label>MOMENT</label><input id="mMag" type="number" step="any" value="500"></div>
                <div class="row"><label>Dir X</label><input id="mX" type="number" step="any" value="0"></div>
                <div class="row"><label>Dir Y</label><input id="mY" type="number" step="any" value="1"></div>
                <div class="row"><label>Dir Z</label><input id="mZ" type="number" step="any" value="0"></div>
                <div class="row"><button id="btnAddMoment">Add MOMENT</button></div>
                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
                <div class="row"><label>SPC1</label><input id="spcComp" type="text" value="123"></div>
                <div class="row"><button id="btnAddSPC">Add SPC1</button></div>
            </div>
          </div>
        </div>

        <!-- Modify Tab -->
        <div id="modifyTab" class="tab-content">

          <div class="card">
            <div class="card-header"><h2>Selection Details</h2></div>
            <div class="card-content">
                <div id="selectionEditContainer">
                  <div class="row"><label>Node/Elem ID</label><input id="selNid" type="number" placeholder="Find by ID (Enter)"></div>
                  <div id="nodeDetails" style="display:none;">
                    <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
                    <div class="grid-2">
                      <div>
                        <div class="row"><label style="color: var(--text);"><b>Local Coords</b></label></div>
                        <div class="row"><label>X</label><input id="selX" type="number" step="any"></div>
                        <div class="row"><label>Y</label><input id="selY" type="number" step="any"></div>
                        <div class="row"><label>Z</label><input id="selZ" type="number" step="any"></div>
                      </div>
                      <div>
                        <div class="row"><label style="color: var(--text);"><b>Global Coords</b></label></div>
                        <div class="row"><label>X</label><input id="selGX" type="text" disabled></div>
                        <div class="row"><label>Y</label><input id="selGY" type="text" disabled></div>
                        <div class="row"><label>Z</label><input id="selGZ" type="text" disabled></div>
                      </div>
                    </div>
                    <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
                    <div class="row"><label>CP</label><input id="selCP" type="number" step="1"></div>
                    <div class="row"><label>CD</label><input id="selCD" type="number" step="1"></div>
                    <div class="row" style="justify-content: space-between">
                      <button id="btnApplyChanges">Apply Changes</button>
                      <button id="btnCancelChanges">Cancel</button>
                    </div>
                  </div>
                </div>
            </div>
          </div>

          <div class="card" id="editElementCard" style="display: none;">
            <div class="card-header"><h2>Edit Element</h2></div>
            <div class="card-content">
              <div class="row"><label>EID</label><input id="editEid" type="number" disabled></div>
              <div class="row"><label>PID</label><input id="editPid" type="number"></div>
              <div class="row edit-elem-nodes"><label>Node 1</label><input id="editN1" type="number"></div>
              <div class="row edit-elem-nodes"><label>Node 2</label><input id="editN2" type="number"></div>
              <div class="row edit-elem-nodes"><label>Node 3</label><input id="editN3" type="number"></div>
              <div class="row edit-elem-nodes"><label>Node 4</label><input id="editN4" type="number"></div>
              <div id="editCquad4AdvancedOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                  <div class="row"><label>THETA/MCID</label><input id="editThetaMcid" type="number" step="any"></div>
                  <div class="row"><label>ZOFFS</label><input id="editZoffs" type="number" step="any"></div>
                  <div class="row"><label>TFLAG</label><input id="editTflag" type="number" step="1"></div>
                  <div class="row"><label>Thicknesses</label></div>
                  <div class="grid-2">
                      <div class="row"><label>T1</label><input id="editT1" type="number" step="any"></div>
                      <div class="row"><label>T2</label><input id="editT2" type="number" step="any"></div>
                      <div class="row"><label>T3</label><input id="editT3" type="number" step="any"></div>
                      <div class="row"><label>T4</label><input id="editT4" type="number" step="any"></div>
                  </div>
              </div>
              <div class="row" style="justify-content: space-between">
                <button id="btnApplyElemEdit">Apply Edit</button>
                <button id="btnCancelElemEdit">Cancel</button>
              </div>
            </div>
          </div>

          <div class="card collapsed">
            <div class="card-header"><h2>Transform Tools</h2></div>
            <div class="card-content">
                <div class="row"><label style="color: var(--text);"><b>Linear</b></label></div>
                <div class="row"><label>Method</label>
                    <select id="copyMethod">
                        <option value="offset">By Offset</option>
                        <option value="vector">By Node Vector</option>
                    </select>
                </div>
                <div id="copyOffsetFields">
                    <div class="grid-3">
                        <label>ΔX</label><label>ΔY</label><label>ΔZ</label>
                        <input id="meshDeltaX" type="number" value="0"><input id="meshDeltaY" type="number" value="0"><input id="meshDeltaZ" type="number" value="0">
                    </div>
                </div>
                <div id="copyVectorFields" style="display:none;">
                    <div class="grid-2">
                        <div class="row"><label>Node 1</label><input id="meshVecN1" type="number" placeholder="Pick"></div>
                        <div class="row"><label>Node 2</label><input id="meshVecN2" type="number" placeholder="Pick"></div>
                    </div>
                </div>
                <div class="row"><label>Repeat</label><input id="meshLinearCopies" type="number" value="1" step="1"></div>
                <div class="row" style="margin-top:8px; gap: 8px;"><button id="btnMove">Move</button><button id="btnCopy">Copy</button></div>
                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">

                <div class="row"><label style="color: var(--text);"><b>Radial</b></label></div>
                <div class="row"><label>Axis Method</label>
                    <select id="radialAxisMethod">
                        <option value="vector">By Vector</option>
                        <option value="nodes">By 2 Nodes</option>
                    </select>
                </div>
                <div id="radialVectorFields">
                    <div class="row"><label>Center</label><input id="meshRadCenterX" type="number" placeholder="X" value="0"><input id="meshRadCenterY" type="number" placeholder="Y" value="0"><input id="meshRadCenterZ" type="number" placeholder="Z" value="0"></div>
                    <div class="row"><label>Axis</label><input id="meshRadAxisX" type="number" placeholder="X" value="0"><input id="meshRadAxisY" type="number" placeholder="Y" value="1"><input id="meshRadAxisZ" type="number" placeholder="Z" value="0"></div>
                </div>
                <div id="radialNodeFields" style="display:none;">
                    <div class="grid-2">
                        <div class="row"><label>Node 1</label><input id="meshRadN1" type="number" placeholder="Pick"></div>
                        <div class="row"><label>Node 2</label><input id="meshRadN2" type="number" placeholder="Pick"></div>
                    </div>
                </div>
                <div class="grid-2">
                    <div class="row"><label>Angle</label><input id="meshRadAngle" type="number" value="90"></div>
                    <div class="row"><label>Copies</label><input id="meshRadCopies" type="number" value="1" step="1"></div>
                </div>
                <div class="row" style="margin-top:8px; gap: 8px;"><button id="btnRadialMove">Radial Move</button><button id="btnRadialCopy">Radial Copy</button></div>
                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">

                <div class="row"><label style="color: var(--text);"><b>Reflect</b></label></div>
                 <div class="row"><label>Method</label>
                    <select id="reflectMethod">
                        <option value="plane">Standard Plane</option>
                        <option value="nodes">By 3 Nodes</option>
                    </select>
                </div>
                <div id="reflectPlaneFields">
                  <div class="row"><label>Plane</label>
                      <select id="meshReflectPlane">
                          <option value="yz">YZ (reflect across X)</option>
                          <option value="xz">XZ (reflect across Y)</option>
                          <option value="xy">XY (reflect across Z)</option>
                      </select>
                  </div>
                  <div class="row"><label>Offset</label><input id="meshReflectOffset" type="number" value="0"></div>
                </div>
                <div id="reflectNodeFields" style="display:none;">
                   <div class="grid-3">
                      <label>Node 1</label><label>Node 2</label><label>Node 3</label>
                      <input id="reflectN1" type="number" placeholder="Pick"><input id="reflectN2" type="number" placeholder="Pick"><input id="reflectN3" type="number" placeholder="Pick">
                    </div>
                </div>
                <div class="row" style="margin-top:8px"><button id="btnReflect">Reflect</button></div>
                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">

                <div class="row"><label style="color: var(--text);"><b>Utilities</b></label></div>
                <div class="row"><button id="btnRefineMesh">Subdivide Shells</button></div>
                <div class="row" style="margin-top:8px"><label>Merge Tol.</label><input id="meshMergeTol" type="number" value="0.001"></div>
                 <div class="row"><label>Keep Node</label>
                    <select id="meshMergeKeep">
                        <option value="lower">Lower ID</option>
                        <option value="higher">Higher ID</option>                </select>
                </div>
                <div class="row" style="margin-top:8px"><button id="btnMergeNodes">Merge Nodes</button></div>
            </div>
          </div>

        </div>
      </div>

    </aside>

    <section id="viewport">
      <canvas id="canvas"></canvas>
      <div id="selectRect"></div>
      <div id="polygonOverlay" style="position:absolute; inset:0; pointer-events:none; display:none;"><svg width="100%" height="100%"><polyline id="polygonLine" fill="rgba(90,169,255,0.15)" stroke="var(--accent)" stroke-width="1" stroke-dasharray="4" /></svg></div>
      <div id="dropzone">Drop .dat/.bdf to load</div>
      <!-- Mini reference compass for global orientation -->
      <div id="compass" style="position:absolute; bottom:10px; left:10px; width:80px; height:80px; pointer-events:none;"></div>
    </section>
    <div id="contextMenu"></div>
  </div>

  <!-- Three.js import map + modules -->
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

    // ---------------- Model ----------------
    const model = {
      nodes: new Map(), // nid -> {x,y,z,cp,cd,ps}
      nodeIndex: new Map(), // nid -> idx
      indexToNid: [], // idx -> nid
      elems: { tri: [], quad: [], bar: [], beam: [], bush: [], rbe2: [], rbe3: [] },
      loads: { force: [], pload: [], moment: [] }, // {sid,nid,cid,mag,dir:[x,y,z]}
      spc1: [], // {sid,components,nodes:[nid,...]}
      coords: new Map(), // cid -> {type, rid, nodes?, origin?, zAxisPt?, xzPlanePt?}
      bbox: null,
      properties: new Map(),
      materials: new Map(),
      preLines: [],
      postLines: [],
    };

    // ---------------- UI State & Helpers ----------------
    const selection = { nodes: new Set(), elems: new Set() };
    const hidden = { elems: new Set(), loads: new Set(), spc: new Set(), nodes: new Set() };
    let selectMode = 'node';
    let faceToElem = [];
    let lineToElem = [];
    let selectedElemLines = null;
    let highlightPoints = null;
    let freeEdgeLines = null;
    const propertyColorMap = new Map();
    var currentElemInput = null;
    var dragStart = null;
    var boxSelecting = false;
    var multiSelectMode = false;
    let isPolygonSelecting = false;
    let polygonPoints = [];
    const visibility = {
        nodes: true, forces: true, moments: true, spcs: true, edges: true, coords: true,
        cquad4: true, ctria3: true, cbar: true, cbeam: true,
        cbush: true, rbe2: true, rbe3: true
    };
    const clippingPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
    let clipPlaneHelper;

    let lastCameraPos = new THREE.Vector3();
    let lastCameraQuat = new THREE.Quaternion();
    const CULLING_THRESHOLD_SQUARED = 0.00001; // Small threshold to avoid floating point issues

    // --------------- UI hooks (DECLARED EARLY TO PREVENT INITIALIZATION ERRORS) ---------------
    const fileInput=document.getElementById('file'), btnSample=document.getElementById('btnSample'), btnClear=document.getElementById('btnClear'), btnReset=document.getElementById('btnReset'), btnExport=document.getElementById('btnExport'), dropzone=document.getElementById('dropzone'), statusEl=document.getElementById('status'), btnUndo = document.getElementById('btnUndo'), btnRedo = document.getElementById('btnRedo'), selNid=document.getElementById('selNid'), selX=document.getElementById('selX'), selY=document.getElementById('selY'), selZ=document.getElementById('selZ'), selCP=document.getElementById('selCP'), selCD=document.getElementById('selCD'), selGX=document.getElementById('selGX'), selGY=document.getElementById('selGY'), selGZ=document.getElementById('selGZ'), btnApplyChanges=document.getElementById('btnApplyChanges'), btnCancelChanges=document.getElementById('btnCancelChanges'), sidEl=document.getElementById('sid'), fMag=document.getElementById('fMag'), fX=document.getElementById('fX'), fY=document.getElementById('fY'), fZ=document.getElementById('fZ'), btnAddForce=document.getElementById('btnAddForce'), spcComp=document.getElementById('spcComp'), btnAddSPC=document.getElementById('btnAddSPC'), mMag=document.getElementById('mMag'), mX=document.getElementById('mX'), mY=document.getElementById('mY'), mZ=document.getElementById('mZ'), btnAddMoment=document.getElementById('btnAddMoment'), loadNodeId = document.getElementById('loadNodeId'), showNodeIds=document.getElementById('showNodeIds'), showElemIds=document.getElementById('showElemIds'), showSPCLabels=document.getElementById('showSPCLabels'), showLoadLabels=document.getElementById('showLoadLabels'), loadLabelMode=document.getElementById('loadLabelMode'), elemType = document.getElementById('elemType'), elemEid = document.getElementById('elemEid'), elemPid = document.getElementById('elemPid'), elemN1 = document.getElementById('elemN1'), elemN2 = document.getElementById('elemN2'), elemN3 = document.getElementById('elemN3'), elemN4 = document.getElementById('elemN4'), elemCm = document.getElementById('elemCm'), elemDepNodes = document.getElementById('elemDepNodes'), elemIndNodes = document.getElementById('elemIndNodes'), btnAddElement = document.getElementById('btnAddElement'), newNid=document.getElementById('newNid'), newX=document.getElementById('newX'), newY=document.getElementById('newY'), newZ=document.getElementById('newZ'), btnAddNode=document.getElementById('btnAddNode'), btnCopySelectedNode=document.getElementById('btnCopySelectedNode'), newCP = document.getElementById('newCP'), newCD = document.getElementById('newCD'), newPS = document.getElementById('newPS'), advancedNodeToggle = document.getElementById('advancedNodeToggle'), advancedNodeOptions = document.getElementById('advancedNodeOptions');
    const csysId = document.getElementById('csysId'), csysRid = document.getElementById('csysRid'), csysMethod = document.getElementById('csysMethod'), csysNodes = document.getElementById('csysNodes'), csysCoords = document.getElementById('csysCoords'), csysN1 = document.getElementById('csysN1'), csysN2 = document.getElementById('csysN2'), csysN3 = document.getElementById('csysN3'), btnAddCsys = document.getElementById('btnAddCsys');
    const modelTreeContainer=document.getElementById('modelTreeContainer'), colorMode=document.getElementById('colorMode'), selCount=document.getElementById('selCount'), btnClearSelection=document.getElementById('btnClearSelection'), selectionEditContainer=document.getElementById('selectionEditContainer'), selectRect=document.getElementById('selectRect'), multiSelectEl=document.getElementById('multiSelect'), multiSelect=multiSelectEl, symbolSize = document.getElementById('symbolSize'), springSize = document.getElementById('springSize'), btnApplyElemEdit = document.getElementById('btnApplyElemEdit'), btnCancelElemEdit = document.getElementById('btnCancelElemEdit'), opacitySlider = document.getElementById('opacitySlider'), shadingToggle = document.getElementById('shadingToggle'), bgColorPicker = document.getElementById('bgColor'), showFreeEdges = document.getElementById('showFreeEdges');
    const contextMenu = document.getElementById('contextMenu');
    const clippingToggle = document.getElementById('clippingToggle');
    const clipPlaneSelect = document.getElementById('clipPlaneSelect');
    const clipOffsetSlider = document.getElementById('clipOffsetSlider');
    const setClipOriginToSelection = document.getElementById('setClipOriginToSelection');
    const flipClipPlane = document.getElementById('flipClipPlane');
    const polygonOverlay = document.getElementById('polygonOverlay');
    const polygonLine = document.getElementById('polygonLine');
    const nodeInputs = [elemN1, elemN2, elemN3, elemN4, elemDepNodes, elemIndNodes, csysN1, csysN2, csysN3, document.getElementById('meshVecN1'), document.getElementById('meshVecN2'), document.getElementById('meshRadN1'), document.getElementById('meshRadN2'), document.getElementById('reflectN1'), document.getElementById('reflectN2'), document.getElementById('reflectN3')];
    const selectModeEl = document.getElementById('selectMode');
    const btnRefreshLabels = document.getElementById('btnRefreshLabels');
    
    // Tab elements
    const tabInspect = document.getElementById('tabInspect');
    const tabCreate = document.getElementById('tabCreate');
    const tabModify = document.getElementById('tabModify');
    const inspectTab = document.getElementById('inspectTab');
    const createTab = document.getElementById('createTab');
    const modifyTab = document.getElementById('modifyTab');
    
    // Toolbar elements
    const selectModeToolbar = document.getElementById('selectModeToolbar');
    const multiSelectToolbar = document.getElementById('multiSelectToolbar');
    const selCountToolbar = document.getElementById('selCountToolbar');
    const btnClearSelectionToolbar = document.getElementById('btnClearSelectionToolbar');

    // Rebuild labels when toggles change to avoid building millions of DOM nodes at once
    if (showNodeIds) showNodeIds.addEventListener('change', () => rebuildLabels());
    if (showElemIds) showElemIds.addEventListener('change', () => rebuildLabels());
    if (showSPCLabels) showSPCLabels.addEventListener('change', () => rebuildLabels());
    if (showLoadLabels) showLoadLabels.addEventListener('change', () => rebuildLabels());
    if (loadLabelMode) loadLabelMode.addEventListener('change', () => rebuildLabels());
    if (btnRefreshLabels) btnRefreshLabels.addEventListener('click', () => rebuildLabels());
    
    // Tab switching
    if (tabInspect) tabInspect.addEventListener('click', () => switchTab('inspect'));
    if (tabCreate) tabCreate.addEventListener('click', () => switchTab('create'));
    if (tabModify) tabModify.addEventListener('click', () => switchTab('modify'));
    
    // Toolbar synchronization
    if (selectModeToolbar) selectModeToolbar.addEventListener('change', () => {
      selectMode = selectModeToolbar.value;
      if (selectModeEl) selectModeEl.value = selectModeToolbar.value;
      selection.nodes.clear();
      selection.elems.clear();
      updateSelectionVisual();
      highlightSelectedElementVisual();
      updateSelectionUI();
    });
    if (selectModeEl) selectModeEl.addEventListener('change', () => {
      selectMode = selectModeEl.value;
      if (selectModeToolbar) selectModeToolbar.value = selectModeEl.value;
      selection.nodes.clear();
      selection.elems.clear();
      updateSelectionVisual();
      highlightSelectedElementVisual();
      updateSelectionUI();
    });
    if (multiSelectToolbar) multiSelectToolbar.addEventListener('change', () => {
      multiSelectMode = multiSelectToolbar.checked;
      if (multiSelect) multiSelect.checked = multiSelectToolbar.checked;
    });
    if (multiSelect) multiSelect.addEventListener('change', () => {
      multiSelectMode = multiSelect.checked;
      if (multiSelectToolbar) multiSelectToolbar.checked = multiSelect.checked;
    });
    if (btnClearSelectionToolbar) btnClearSelectionToolbar.addEventListener('click', () => {
      selection.nodes.clear(); 
      selection.elems.clear(); 
      currentElemInput = null; 
      updateSelectionVisual(); 
      highlightSelectedElementVisual(); 
      updateSelectionUI();
    });
    
    // CSV Export functionality
    const btnExportSelectionCSV = document.getElementById('btnExportSelectionCSV');
    if (btnExportSelectionCSV) btnExportSelectionCSV.addEventListener('click', () => {
      exportSelectionToCSV();
    });

    // Tab switching function
    function switchTab(tabName) {
      // Hide all tabs
      if (inspectTab) inspectTab.classList.remove('active');
      if (createTab) createTab.classList.remove('active');
      if (modifyTab) modifyTab.classList.remove('active');
      
      // Remove active class from all tab buttons and reset their styling
      if (tabInspect) {
        tabInspect.classList.remove('active');
        tabInspect.style.color = 'var(--muted)';
        tabInspect.style.borderBottomColor = 'transparent';
      }
      if (tabCreate) {
        tabCreate.classList.remove('active');
        tabCreate.style.color = 'var(--muted)';
        tabCreate.style.borderBottomColor = 'transparent';
      }
      if (tabModify) {
        tabModify.classList.remove('active');
        tabModify.style.color = 'var(--muted)';
        tabModify.style.borderBottomColor = 'transparent';
      }
      
      // Show selected tab and activate button
      switch(tabName) {
        case 'inspect':
          if (inspectTab) inspectTab.classList.add('active');
          if (tabInspect) {
            tabInspect.classList.add('active');
            tabInspect.style.color = 'var(--text)';
            tabInspect.style.borderBottomColor = 'var(--accent)';
          }
          break;
        case 'create':
          if (createTab) createTab.classList.add('active');
          if (tabCreate) {
            tabCreate.classList.add('active');
            tabCreate.style.color = 'var(--text)';
            tabCreate.style.borderBottomColor = 'var(--accent)';
          }
          break;
        case 'modify':
          if (modifyTab) modifyTab.classList.add('active');
          if (tabModify) {
            tabModify.classList.add('active');
            tabModify.style.color = 'var(--text)';
            tabModify.style.borderBottomColor = 'var(--accent)';
          }
          break;
      }
    }

    const historyManager = {
      stack: [], pointer: -1, maxSize: 50,
      cloneState: function() { return { nodes: new Map(JSON.parse(JSON.stringify(Array.from(model.nodes)))), elems: JSON.parse(JSON.stringify(model.elems)), loads: JSON.parse(JSON.stringify(model.loads)), spc1: JSON.parse(JSON.stringify(model.spc1)), coords: new Map(JSON.parse(JSON.stringify(Array.from(model.coords)))), properties: new Map(JSON.parse(JSON.stringify(Array.from(model.properties)))), materials: new Map(JSON.parse(JSON.stringify(Array.from(model.materials)))) }; },
      recordAction: function(actionFn) { if (this.pointer < this.stack.length - 1) { this.stack.splice(this.pointer + 1); } actionFn(); this.stack.push(this.cloneState()); if (this.stack.length > this.maxSize) { this.stack.shift(); } this.pointer = this.stack.length - 1; updateUndoRedoButtons(); },
      undo: function() { if (this.pointer > 0) { this.pointer--; this.restoreState(this.stack[this.pointer]); } },
      redo: function() { if (this.pointer < this.stack.length - 1) { this.pointer++; this.restoreState(this.stack[this.pointer]); } },
      restoreState: function(state) {
        model.nodes=new Map(state.nodes); model.elems=JSON.parse(JSON.stringify(state.elems)); model.loads=JSON.parse(JSON.stringify(state.loads)); model.spc1=JSON.parse(JSON.stringify(state.spc1)); model.coords=new Map(state.coords); model.properties=new Map(state.properties); model.materials=new Map(state.materials);
        const nids = Array.from(model.nodes.keys()).sort((a,b)=>a-b); model.indexToNid=nids; model.nodeIndex=new Map(nids.map((nid,i)=>[nid,i]));
        buildGeometries(true); updateUndoRedoButtons();
      },
      clear: function() { this.stack = []; this.pointer = -1; this.stack.push(this.cloneState()); this.pointer = 0; updateUndoRedoButtons(); }
    };
    
    function updateOpacity() { 
        if (meshShell) { 
            const val = parseFloat(opacitySlider.value); 
            meshShell.material.opacity = val; 
            meshShell.material.transparent = val < 1.0; 
            meshShell.material.needsUpdate = true; 
        } 
    };

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [r, g, b];
    }

    function getPropColor(pid) {
      if (propertyColorMap.has(pid)) return propertyColorMap.get(pid);
      const golden = 0.618033988749895;
      const h = (pid * golden) % 1;
      const [r, g, b] = hslToRgb(h, 0.7, 0.6);
      const col = [r, g, b];
      propertyColorMap.set(pid, col);
      return col;
    }

    function resetModel() {
      model.nodes.clear();
      model.nodeIndex = new Map();
      model.indexToNid.length = 0;
      model.elems = { tri: [], quad: [], bar: [], beam: [], bush: [], rbe2: [], rbe3: [] };
      model.loads = { force: [], pload: [], moment: [] };
      model.spc1 = [];
      model.coords.clear();
      model.bbox = null;
      model.properties = new Map();
      model.materials = new Map();
      model.preLines = [];
    }

    // --------------- Parsing ---------------
    function parseTokens(line) {
      if (line.includes(',')) { // Free format
        return line.split(',').map(t => t.trim());
      }
      // Fixed format
      const toks = [];
      for (let i = 0; i < line.length; i += 8) {
        toks.push(line.slice(i, i + 8));
      }
      return toks.map(t => t.trim());
    }

    function parseBDF(text) {
        resetModel();
        const rawLines = text.split(/\r?\n/);
        const lines = [];

        // Pre-processor to handle line continuations
        for (let i = 0; i < rawLines.length; i++) {
            let currentLine = rawLines[i];
            const commentIndex = currentLine.indexOf('$');
            if (commentIndex >= 0) currentLine = currentLine.slice(0, commentIndex);
            if (currentLine.trim() === '') continue;

            // Look ahead for continuations
            while (i + 1 < rawLines.length) {
                const nextLineRaw = rawLines[i + 1];
                const commentIndexNext = nextLineRaw.indexOf('$');
                const nextLineFull = (commentIndexNext >= 0 ? nextLineRaw.slice(0, commentIndexNext) : nextLineRaw);
                const nextLineTrimLeft = nextLineFull.replace(/^\s+/, '');

                const isFree = currentLine.includes(',');
                if (isFree) {
                  const currEndsWithComma = /,\s*$/.test(currentLine);
                  const nextStartsWithComma = nextLineTrimLeft.startsWith(',');
                  if (!(currEndsWithComma || nextStartsWithComma)) break; // no continuation
                  // join: remove trailing comma from current; remove leading comma from next
                  const curr = currentLine.replace(/,\s*$/, '');
                  const next = nextLineTrimLeft.replace(/^,\s*/, '');
                  currentLine = curr + ',' + next;
                  i++; // consumed next line
                  continue;
                }

                // Fixed small-field: continuation only if '+' in column 1
                const isFixedCont = nextLineFull.startsWith('+');
                if (!isFixedCont) break;
                currentLine += nextLineFull.substring(8); // append fields after col 8
                i++; // consumed next line
            }
            lines.push(currentLine);
        }

      const asNum = (s) => (s === '' || s === undefined ? NaN : Number(s));

      for (const line of lines) {
        const tokens = parseTokens(line);
        if (!tokens.length || tokens[0] === '') continue;
        const card = tokens[0].toUpperCase();
        try {
          switch (card) {
            case 'GRID': {
              const nid = asNum(tokens[1]);
              const cp = asNum(tokens[2] || '0');
              const x = asNum(tokens[3]);
              const y = asNum(tokens[4]);
              const z = asNum(tokens[5]);
              const cd = asNum(tokens[6] || '0');
              const ps = tokens[7] || '';
              if (!isNaN(nid) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                model.nodes.set(nid, { x, y, z, cp, cd, ps });
              }
              break; }
            case 'CTRIA3': {
              const [eid,pid,n1,n2,n3] = tokens.slice(1).map(v=>parseInt(v));
              model.elems.tri.push({ eid, pid, n:[n1,n2,n3], type: 'CTRIA3' });
              break; }
            case 'CQUAD4': {
              const eid = asNum(tokens[1]), pid = asNum(tokens[2]);
              const n1 = asNum(tokens[3]), n2 = asNum(tokens[4]), n3 = asNum(tokens[5]), n4 = asNum(tokens[6]);
              const elem = { eid, pid, n:[n1,n2,n3,n4], type: 'CQUAD4' };
              const thetaMcid = asNum(tokens[7]); if (!isNaN(thetaMcid)) elem.thetaMcid = thetaMcid;
              const zoffs = asNum(tokens[8]); if (!isNaN(zoffs)) elem.zoffs = zoffs;
              const tflag = asNum(tokens[9]); if (!isNaN(tflag)) elem.tflag = tflag;
              const t1 = asNum(tokens[10]), t2 = asNum(tokens[11]), t3 = asNum(tokens[12]), t4 = asNum(tokens[13]);
              if (![t1,t2,t3,t4].every(isNaN)) elem.T = [t1,t2,t3,t4].map(v => isNaN(v) ? undefined : v);
              model.elems.quad.push(elem);
              break; }
            case 'CBAR':
            case 'CBEAM': {
              const eid = parseInt(tokens[1]);
              const pid = parseInt(tokens[2]);
              const n1 = parseInt(tokens[3]);
              const n2 = parseInt(tokens[4]);
              const key = card === 'CBAR' ? 'bar' : 'beam';
              model.elems[key].push({ eid, pid, n:[n1,n2], type: card });
              break; }
            case 'CBUSH': {
              const eid = parseInt(tokens[1]);
              const pid = parseInt(tokens[2]);
              const ga = parseInt(tokens[3]);
              const gb = parseInt(tokens[4]);
              model.elems.bush.push({ eid, pid, n:[ga,gb], type: 'CBUSH' });
              break; }
            case 'RBE2': {
              const eid = parseInt(tokens[1]);
              const gn  = parseInt(tokens[2]);
              const cm  = tokens[3] || '123456';
              const deps = tokens.slice(4).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.elems.rbe2.push({ eid, gn, cm, deps, type: 'RBE2' });
              break; }
            case 'RBE3': {
              const eid = parseInt(tokens[1]);
              const gn  = parseInt(tokens[2]);
              const cm  = tokens[3] || '123456';
              const inds = tokens.slice(4).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.elems.rbe3.push({ eid, gn, cm, inds, type: 'RBE3' });
              break; }
            case 'FORCE': {
              const sid = parseInt(tokens[1]);
              const nid = parseInt(tokens[2]);
              const cid = parseInt(tokens[3] || '0');
              const mag = Number(tokens[4]);
              const dir = [Number(tokens[5]||0), Number(tokens[6]||0), Number(tokens[7]||0)];
              model.loads.force.push({ type: 'FORCE', sid, nid, cid, mag, dir });
              break; }
            case 'MOMENT': {
              const sid = parseInt(tokens[1]);
              const nid = parseInt(tokens[2]);
              const cid = parseInt(tokens[3] || '0');
              const mag = Number(tokens[4]);
              const dir = [Number(tokens[5]||0), Number(tokens[6]||0), Number(tokens[7]||0)];
              model.loads.moment.push({ type: 'MOMENT', sid, nid, cid, mag, dir });
              break; }
            case 'PLOAD': {
              const sid = parseInt(tokens[1]);
              let pRaw = tokens[2];
              let pVal = Number(pRaw);
              if ((isNaN(pVal) || !isFinite(pVal)) && typeof pRaw === 'string') {
                const plusIndex = pRaw.indexOf('+');
                if (plusIndex > 0) {
                  const baseStr = pRaw.slice(0, plusIndex);
                  const expStr = pRaw.slice(plusIndex + 1);
                  const base = parseFloat(baseStr);
                  const exp = parseInt(expStr);
                  if (!isNaN(base) && !isNaN(exp)) {
                    pVal = base * Math.pow(10, exp);
                  }
                }
              }
              if (isNaN(pVal) || !isFinite(pVal)) pVal = 0;
              const pts = tokens.slice(3).map(t => parseInt(t)).filter(v => !isNaN(v));
              if (pts.length >= 2) {
                const nodes = pts.slice(0, 4);
                while (nodes.length < 4) nodes.push(nodes[nodes.length - 1]);
                model.loads.pload.push({ type: 'PLOAD', sid, p: pVal, nodes });
              }
              break; }
            case 'SPC1': {
              const sid = parseInt(tokens[1]);
              const comp = tokens[2];
              const nodes = tokens.slice(3).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.spc1.push({ sid, components: comp, nodes });
              break; }
            case 'CORD2R': {
              const toInt = s => parseInt(s, 10);
              const cid = toInt(tokens[1]);
              const rid = toInt(tokens[2] || '0');
              const remaining = tokens.slice(3).filter(t => t.length > 0);

              if (remaining.length >= 9) { // Coords form
                const coords = remaining.slice(0, 9).map(Number);
                if (coords.some(isNaN)) {
                  console.warn(`Could not parse CORD2R ${cid} due to invalid coordinate numbers.`);
                } else {
                  model.coords.set(cid, { type: 'CORD2R', rid, origin: coords.slice(0,3), zAxisPt: coords.slice(3,6), xzPlanePt: coords.slice(6,9) });
                }
              } else if (remaining.length >= 3) { // Nodes form
                const nodes = remaining.slice(0, 3).map(toInt);
                if (nodes.some(isNaN)) {
                  console.warn(`Could not parse CORD2R ${cid} due to invalid node IDs.`);
                } else {
                  model.coords.set(cid, { type: 'CORD2R', rid, nodes });
                }
              } else {
                console.warn(`Could not parse CORD2R ${cid}: not enough fields.`);
              }
              break;
            }
            case 'PSHELL': {
              const pid = parseInt(tokens[1]);
              const mid = parseInt(tokens[2]);
              const t = Number(tokens[3]);
              model.properties.set(pid, { type: 'PSHELL', mid, t });
              break; }
            case 'PBAR':
            case 'PBEAM': {
              const pid = parseInt(tokens[1]);
              const mid = parseInt(tokens[2]);
              model.properties.set(pid, { type: card, mid });
              break; }
            case 'MAT1': {
              const mid = parseInt(tokens[1]);
              const e = Number(tokens[2]);
              let nu = NaN;
              if (tokens.length > 3) {
                const val = Number(tokens[3]);
                if (!isNaN(val)) nu = val;
              }
              model.materials.set(mid, { type: 'MAT1', E: e, Nu: nu });
              break; }
            default:
              model.preLines.push(line);
              break;
          }
        } catch (e) { console.warn('Parse warning:', card, line, e); }
      }

      const nids = Array.from(model.nodes.keys()).sort((a,b)=>a-b);
      model.indexToNid = nids;
      model.nodeIndex = new Map(nids.map((nid,i)=>[nid,i]));

      if (!model.bbox) {
        model.bbox = new THREE.Box3(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
    }

    // --------------- Export ---------------
    function exportBDF() {
      // FIX: A robust formatter for Nastran 8-character "short field" format.
      // This version uses 'E' notation for exponents as requested by some parsers.
      const pad8 = (val) => {
        if (val === undefined || val === null) return '        ';

        // If it's not a number or not finite, treat as a generic string field
        const num = Number(val);
        if (isNaN(num) || !Number.isFinite(num)) {
          let s = String(val);
          if (s.length > 8) s = s.slice(0, 8);
          return s.padEnd(8, ' ');
        }

        // --- Number Formatting ---

        // For numbers very close to zero, to avoid scientific notation like 4.44e-16
        if (Math.abs(num) < 1.0e-9 && num !== 0) {
          return '0.'.padEnd(8, ' ');
        }
        
        // Attempt to format as a fixed-point decimal if it fits
        let s = String(num);
        if (!s.includes('e')) { // If JS didn't already make it scientific
            if (s.length <= 8) {
                return s.padEnd(8, ' ');
            }
            if (s.includes('.')) {
                const intPart = s.split('.')[0];
                if (intPart.length < 8) {
                    const fracLen = Math.max(0, 8 - (intPart.length + 1));
                    const rounded = num.toFixed(fracLen);
                    // Check if rounding caused overflow (e.g. 9.99 -> 10.0)
                    if (rounded.length <= 8) {
                        return rounded.padEnd(8, ' ');
                    }
                }
            }
        }

        // If the number is too large, too small, or was already scientific,
        // format it into Nastran-style exponential notation (e.g., "-1.23E-5").
        const exp = Math.floor(Math.log10(Math.abs(num)));
        const mant = num / (10 ** exp);

        const sign = exp >= 0 ? '+' : '-';
        const expStr = String(Math.abs(exp));
        
        // Calculate available space for the mantissa
        let spaceForMantissa = 8 - (expStr.length + 2); // +2 for 'E' and sign
        
        if (spaceForMantissa < 1) {
            return '********'; // Cannot format
        }

        let mantStr = String(mant);
        if (mantStr.length > spaceForMantissa) {
            // Need to shorten the mantissa.
            // Using toFixed is a reliable way to control decimal places for rounding.
            let decimalPlaces = spaceForMantissa - 1; // for the '.'
            if (mant < 0) decimalPlaces -= 1; // for the '-'
            if (Math.abs(mant) >= 10) decimalPlaces -= 1; // for two-digit integer part
            
            mantStr = mant.toFixed(Math.max(0, decimalPlaces));
            
            // Final check in case rounding made it too long (e.g. 9.99 -> 10.0)
            if (mantStr.length > spaceForMantissa) {
                mantStr = mantStr.slice(0, spaceForMantissa);
            }
        }

        // Ensure it doesn't end with a dot after truncation
        if(mantStr.endsWith('.')) {
            mantStr = mantStr.slice(0, -1);
        }

        let finalStr = mantStr + 'E' + sign + expStr;
        return finalStr.padEnd(8, ' ');
      };

      const lines = [];

      const writeContinuationCard = (cardName, fixedFields, nodeList, nodesPerFirst, nodesPerCont) => {
          const nodes = [...nodeList];
          let line = pad8(cardName);
          fixedFields.forEach(f => line += pad8(f));
          const firstLineNodes = nodes.splice(0, nodesPerFirst);
          firstLineNodes.forEach(n => line += pad8(n));
          lines.push(line.slice(0, 72));
          while(nodes.length > 0) {
              const continuationNodes = nodes.splice(0, nodesPerCont);
              let continuationLine = ' '.padEnd(8, ' ');
              continuationNodes.forEach(n => continuationLine += pad8(n));
              lines.push(continuationLine.slice(0, 72));
          }
      };

      if (model.preLines && model.preLines.length) {
        for (const l of model.preLines) lines.push(l);
      }
      for (const nid of model.indexToNid) {
        const node = model.nodes.get(nid);
        lines.push(('GRID'.padEnd(8) + pad8(nid) + pad8(node.cp ?? 0) + pad8(node.x) + pad8(node.y) + pad8(node.z) + pad8(node.cd ?? 0) + pad8(node.ps || '')).slice(0,72) );
      }
      
      const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

      for (const [cid, cs] of model.coords) {
          if (cs.type === 'CORD2R') {
              let line1 = 'CORD2R'.padEnd(8) + pad8(cid) + pad8(cs.rid || 0);
              let line2 = '+'.padEnd(8);
              let originCoords, zAxisPtCoords, xzPlanePtCoords;

              if (cs.nodes) {
                  const refTransform = globalCoordTransforms.get(cs.rid || 0) || new THREE.Matrix4();
                  const invRefTransform = refTransform.clone().invert();
                  
                  const p1Global = globalPositions.get(cs.nodes[0]);
                  const p2Global = globalPositions.get(cs.nodes[1]);
                  const p3Global = globalPositions.get(cs.nodes[2]);
                  
                  if (!p1Global || !p2Global || !p3Global) continue;

                  const p1Ref = p1Global.clone().applyMatrix4(invRefTransform);
                  const p2Ref = p2Global.clone().applyMatrix4(invRefTransform);
                  const p3Ref = p3Global.clone().applyMatrix4(invRefTransform);

                  originCoords = [p1Ref.x, p1Ref.y, p1Ref.z];
                  zAxisPtCoords = [p2Ref.x, p2Ref.y, p2Ref.z];
                  xzPlanePtCoords = [p3Ref.x, p3Ref.y, p3Ref.z];

              } else if (cs.origin) {
                  originCoords = cs.origin;
                  zAxisPtCoords = cs.zAxisPt;
                  xzPlanePtCoords = cs.xzPlanePt;
              }

              if(originCoords) {
                line1 += originCoords.map(pad8).join('');
                line1 += zAxisPtCoords.map(pad8).join('');
                lines.push(line1.slice(0, 72));
                
                line2 += xzPlanePtCoords.map(pad8).join('');
                lines.push(line2.slice(0, 72));
              }
          }
      }
      for (const e of model.elems.tri) lines.push(('CTRIA3'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1]) + pad8(e.n[2])).slice(0,72));
      
      for (const e of model.elems.quad) {
        let line1 = 'CQUAD4'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1]) + pad8(e.n[2]) + pad8(e.n[3]);
        const hasT = e.tflag !== undefined || (e.T && e.T.some(t => t !== undefined && !isNaN(t)));
        const hasAdvanced = e.thetaMcid !== undefined || e.zoffs !== undefined || hasT;
        
        if (hasAdvanced) {
            line1 += pad8(e.thetaMcid ?? '');
            line1 += pad8(e.zoffs ?? '');
            lines.push(line1.slice(0, 72));
            
            if (hasT) {
                let line2 = ' '.padEnd(8); // Continuation line
                line2 += pad8(e.tflag ?? '');
                const tVals = e.T || [];
                line2 += pad8(tVals[0] ?? '');
                line2 += pad8(tVals[1] ?? '');
                line2 += pad8(tVals[2] ?? '');
                line2 += pad8(tVals[3] ?? '');
                lines.push(line2.slice(0, 72));
            }
        } else {
            lines.push(line1.slice(0, 72));
        }
      }

      for (const e of model.elems.bar) lines.push(('CBAR'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      for (const e of model.elems.beam) lines.push(('CBEAM'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      for (const e of model.elems.bush) lines.push(('CBUSH'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      
      for (const e of model.elems.rbe2) writeContinuationCard('RBE2', [e.eid, e.gn, e.cm], e.deps, 5, 8);
      for (const e of model.elems.rbe3) writeContinuationCard('RBE3', [e.eid, e.gn, e.cm], e.inds, 5, 8);
      
      for (const f of model.loads.force) lines.push(('FORCE'.padEnd(8) + pad8(f.sid) + pad8(f.nid) + pad8(f.cid ?? 0) + String(f.mag).padEnd(8) + pad8(f.dir[0]) + pad8(f.dir[1]) + pad8(f.dir[2])).slice(0,72));
      for (const m of model.loads.moment) lines.push(('MOMENT'.padEnd(8) + pad8(m.sid) + pad8(m.nid) + pad8(m.cid ?? 0) + String(m.mag).padEnd(8) + pad8(m.dir[0]) + pad8(m.dir[1]) + pad8(m.dir[2])).slice(0,72));
      for (const pl of model.loads.pload) lines.push(('PLOAD'.padEnd(8) + pad8(pl.sid) + String(pl.p).padEnd(8) + pl.nodes.map(nid=>pad8(nid)).join('')).slice(0,72));
      
      for (const s of model.spc1) {
        if (s.nodes.length) writeContinuationCard('SPC1', [s.sid, s.components], s.nodes, 6, 8);
      }

      lines.push('ENDDATA');
      const blob = new Blob([lines.join('\n')+'\n'], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'model_modified.dat'; a.click(); URL.revokeObjectURL(url);
    }
    
    // --------------- CSV Export ---------------
    function exportSelectionToCSV() {
      const csvLines = [];
      
      // Add header
      if (selectMode === 'node') {
        csvLines.push('Node ID,X,Y,Z,CP,CD,PS');
        for (const nid of selection.nodes) {
          const node = model.nodes.get(nid);
          if (node) {
            const idx = model.nodeIndex.get(nid);
            const pos = nodePosition(idx);
            csvLines.push(`${nid},${pos.x},${pos.y},${pos.z},${node.cp || 0},${node.cd || 0},"${node.ps || ''}"`);
          }
        }
      } else if (selectMode === 'element') {
        csvLines.push('Element ID,Type,PID,Node1,Node2,Node3,Node4');
        const allElems = [...model.elems.tri, ...model.elems.quad, ...model.elems.bar, ...model.elems.beam, ...model.elems.bush, ...model.elems.rbe2, ...model.elems.rbe3];
        for (const eid of selection.elems) {
          const elem = allElems.find(e => e.eid === eid);
          if (elem) {
            const nodes = elem.n || [];
            const nodeStr = nodes.map(n => n || '').join(',');
            csvLines.push(`${eid},${elem.type},${elem.pid || ''},${nodeStr}`);
          }
        }
      } else if (selectMode === 'load') {
        csvLines.push('Load Type,SID,Node ID,Component,Magnitude,Direction X,Direction Y,Direction Z');
        for (const load of [...model.loads.force, ...model.loads.moment, ...model.loads.pload]) {
          if (load.type === 'FORCE' || load.type === 'MOMENT') {
            csvLines.push(`${load.type},${load.sid},${load.nid},${load.cid || 0},${load.mag},${load.dir[0]},${load.dir[1]},${load.dir[2]}`);
          } else if (load.type === 'PLOAD') {
            csvLines.push(`${load.type},${load.sid},${load.pid},${load.scale},${load.n1 || ''},${load.n2 || ''},${load.n3 || ''},${load.n4 || ''}`);
          }
        }
      } else if (selectMode === 'constraint') {
        csvLines.push('Constraint ID,Components,Node IDs');
        for (const spc of model.spc1) {
          csvLines.push(`${spc.sid},${spc.components},"${spc.nodes.join(';')}"`);
        }
      }
      
      if (csvLines.length > 1) {
        const csvContent = csvLines.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `selection_${selectMode}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        statusMsg(`Exported ${csvLines.length - 1} ${selectMode} to CSV`);
      } else {
        statusMsg('No selection to export', true);
      }
    }
    
    const fmt = (v) => Number(v).toString();

    // --------------- Coordinate System Transformation ---------------
    // Maps Nastran's coordinate system (Z-up) to Three.js's (Y-up) for geometry creation.
    function nastranToThree(vx, vy, vz) { return new THREE.Vector3(vx, vy, vz); } 
    // Maps Three.js's coordinate system back to Nastran's for display and export.
    function threeToNastran(p) { return { x: p.x, y: p.y, z: p.z }; }

    // --------------- Three.js setup ---------------
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, logarithmicDepthBuffer: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.localClippingEnabled = false;
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0f1115);

    let camera, perspectiveCamera, orthographicCamera;

    perspectiveCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 10000);
    perspectiveCamera.position.set(2.5, 2.5, 2.5);
    perspectiveCamera.up.set(0, 0, 1);

    // Placeholder for ortho camera, will be configured in fitView
    const aspect = canvas.clientWidth / canvas.clientHeight;
    orthographicCamera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.01, 10000);
    orthographicCamera.position.copy(perspectiveCamera.position);
    orthographicCamera.up.set(0, 0, 1);
    orthographicCamera.zoom = 0.1; // Initial zoom
    
    // Set parallel view as default
    camera = orthographicCamera;

    const controls = new OrbitControls(camera, canvas); controls.enableDamping = false; controls.rotateSpeed = 0.7;
    
    // Enhanced lighting setup for better shading
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(5, 5, 5); // Position relative to camera
    camera.add(keyLight); // Attach light to camera
    scene.add(camera); // Make sure camera is in the scene so its children are processed

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-5, 2, -5);
    scene.add(fillLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Reduced ambient
    scene.add(ambientLight);

    function makeTextSprite(message, parameters) {
        if (parameters === undefined) parameters = {};
        const fontface = parameters.fontface || 'Arial';
        const fontsize = parameters.fontsize || 24;
        const borderThickness = parameters.borderThickness || 0;
        const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
        const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.0 };
        const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1.0 };
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = "Bold " + fontsize + "px " + fontface;
        const metrics = context.measureText(message);
        const textWidth = metrics.width;
        canvas.width = textWidth + borderThickness * 2;
        canvas.height = fontsize + borderThickness * 2;
        context.font = "Bold " + fontsize + "px " + fontface;
        context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
        context.lineWidth = borderThickness;
        context.fillStyle = "rgba(" + textColor.r + "," + textColor.g + "," + textColor.b + "," + textColor.a + ")";
        context.fillText(message, borderThickness, fontsize - borderThickness);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        const spriteScale = 0.15; 
        sprite.scale.set(spriteScale * (canvas.width / fontsize), spriteScale, 1);
        return sprite;
    }

    const axesGroup = new THREE.Group();
    const axisMatX = new THREE.LineBasicMaterial({ color: 0xff4b4b });
    const axisMatY = new THREE.LineBasicMaterial({ color: 0x4bff4b });
    const axisMatZ = new THREE.LineBasicMaterial({ color: 0x4b4bff });
    const makeAxis = (dir, mat) => {
      const pts = [ new THREE.Vector3(0, 0, 0), new THREE.Vector3(dir.x, dir.y, dir.z) ];
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      return new THREE.Line(geom, mat);
    };
    axesGroup.add(makeAxis(new THREE.Vector3(1, 0, 0), axisMatX));
    axesGroup.add(makeAxis(new THREE.Vector3(0, 1, 0), axisMatY));
    axesGroup.add(makeAxis(new THREE.Vector3(0, 0, 1), axisMatZ));
    const axisLabelX = makeTextSprite("X", { fontsize: 32, textColor: { r: 255, g: 75, b: 75, a: 1.0 } });
    axisLabelX.position.set(1.1, 0, 0);
    axesGroup.add(axisLabelX);
    const axisLabelY = makeTextSprite("Y", { fontsize: 32, textColor: { r: 75, g: 255, b: 75, a: 1.0 } });
    axisLabelY.position.set(0, 1.1, 0);
    axesGroup.add(axisLabelY);
    const axisLabelZ = makeTextSprite("Z", { fontsize: 32, textColor: { r: 75, g: 75, b: 255, a: 1.0 } });
    axisLabelZ.position.set(0, 0, 1.1);
    axesGroup.add(axisLabelZ);
    scene.add(axesGroup);
    
    const viewportEl = document.getElementById('viewport');
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    viewportEl.appendChild(labelRenderer.domElement);
    
    const compassDiv = document.getElementById('compass');
    let compassRenderer, compassScene, compassCamera;
    if (compassDiv) {
      compassRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      compassRenderer.setSize(compassDiv.clientWidth, compassDiv.clientHeight);
      compassRenderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      compassDiv.appendChild(compassRenderer.domElement);
      compassScene = new THREE.Scene();
      const w = compassDiv.clientWidth;
      const h = compassDiv.clientHeight;
      compassCamera = new THREE.OrthographicCamera(-w/80, w/80, h/80, -h/80, 1, 100);
      compassCamera.up.set(0, 0, 1);
      compassCamera.position.z = 2.5;
      compassCamera.lookAt(0, 0, 0);
      compassCamera.updateProjectionMatrix();
      
      const compassAxes = new THREE.Group();
      compassAxes.add(makeAxis(new THREE.Vector3(0.6, 0, 0), axisMatX));
      compassAxes.add(makeAxis(new THREE.Vector3(0, 0.6, 0), axisMatY));
      compassAxes.add(makeAxis(new THREE.Vector3(0, 0, 0.6), axisMatZ));
      const compassLabelX = makeTextSprite("X", { fontsize: 48, textColor: { r: 255, g: 75, b: 75, a: 1.0 } });
      compassLabelX.position.set(0.8, 0, 0);
      compassAxes.add(compassLabelX);
      const compassLabelY = makeTextSprite("Y", { fontsize: 48, textColor: { r: 75, g: 255, b: 75, a: 1.0 } });
      compassLabelY.position.set(0, 0.8, 0);
      compassAxes.add(compassLabelY);
      const compassLabelZ = makeTextSprite("Z", { fontsize: 48, textColor: { r: 75, g: 75, b: 255, a: 1.0 } });
      compassLabelZ.position.set(0, 0, 0.8);
      compassAxes.add(compassLabelZ);
      compassScene.add(compassAxes);
    }
    
    let meshShell = null, meshWire = null, meshLines = null, bushGroup = null, coordSysGroup = null;
    const nodeLabelGroup = new THREE.Group();
    const elemLabelGroup = new THREE.Group();
    const spcLabelGroup = new THREE.Group();
    const loadLabelGroup = new THREE.Group();
    const allLabelGroups = [nodeLabelGroup, elemLabelGroup, spcLabelGroup, loadLabelGroup];
    scene.add(nodeLabelGroup, elemLabelGroup, spcLabelGroup, loadLabelGroup);
    let points = null, selectionSphere = null;
    const forceGroup = new THREE.Group();
    const momentGroup = new THREE.Group();
    const ploadGroup = new THREE.Group();
    const spcGroup = new THREE.Group();
    scene.add(forceGroup, momentGroup, ploadGroup, spcGroup);
    const tempLabelGroup = new THREE.Group();
    scene.add(tempLabelGroup);
    let tempLabelTimeout = null;

    function clearScene() {
      for (const obj of [meshShell, meshWire, meshLines, points, selectionSphere, highlightPoints, bushGroup, coordSysGroup, clipPlaneHelper, freeEdgeLines]) { if (obj) scene.remove(obj); }
      meshShell = meshWire = meshLines = points = selectionSphere = highlightPoints = bushGroup = coordSysGroup = clipPlaneHelper = freeEdgeLines = null;
      forceGroup.clear(); momentGroup.clear(); ploadGroup.clear(); spcGroup.clear();
      nodeLabelGroup.clear(); elemLabelGroup.clear(); spcLabelGroup.clear(); loadLabelGroup.clear();
      if(tempLabelGroup) tempLabelGroup.clear();
    }

    function createBushSpriteMaterial() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.arc(32, 32, 28, 0, Math.PI * 2);
      ctx.strokeStyle = '#ffa657';
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(16, 32);
      ctx.lineTo(22, 26);
      ctx.lineTo(28, 38);
      ctx.lineTo(34, 26);
      ctx.lineTo(40, 38);
      ctx.lineTo(46, 26);
      ctx.lineTo(52, 32);
      ctx.lineWidth = 3;
      ctx.stroke();
      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, color: 0xffa657 });
      mat.clippingPlanes = [clippingPlane];
      return mat;
    }
    const bushMaterial = createBushSpriteMaterial();

    function createMomentArrow(origin, direction, length, color) {
        const headLength = length * 0.3; 
        const headWidth = length * 0.2;
        const arrow = new THREE.ArrowHelper(direction, origin, length, color, headLength, headWidth);
        arrow.line.material.clippingPlanes = [clippingPlane];
        arrow.cone.material.clippingPlanes = [clippingPlane];
        const cone2 = arrow.cone.clone();
        cone2.position.copy(arrow.cone.position);
        cone2.position.y -= headLength * 0.8; 
        arrow.add(cone2);
        return arrow;
    }
    
    function resolveAllTransforms() {
        const globalPositions = new Map();
        const globalCoordTransforms = new Map();

        const nastranBasicToThree = new THREE.Matrix4(); // Identity matrix, as we are now Z-up in Three.js
        globalCoordTransforms.set(0, nastranBasicToThree);

        // Phase A: Seed all GRID nodes defined in the basic coordinate system
        for (const nid of model.indexToNid) {
            const n = model.nodes.get(nid);
            if ((n.cp ?? 0) === 0) {
                const p = new THREE.Vector3(n.x, n.y, n.z);
                globalPositions.set(nid, p);
            }
        }

        // Phase B: Iteratively resolve CORD2R systems, respecting RID dependencies
        const pending = new Set(model.coords.keys());
        let progressed = true;
        while (pending.size > 0 && progressed) {
            progressed = false;
            for (const cid of Array.from(pending)) {
                const cs = model.coords.get(cid);
                const parentTransform = globalCoordTransforms.get(cs.rid || 0);
                if (!parentTransform) continue; // Parent not resolved yet, skip for now

                let transform;
                if (cs.origin) { // Defined by coordinates
                    const A = new THREE.Vector3(...cs.origin).applyMatrix4(parentTransform);
                    const B = new THREE.Vector3(...cs.zAxisPt).applyMatrix4(parentTransform);
                    const C = new THREE.Vector3(...cs.xzPlanePt).applyMatrix4(parentTransform);
                    
                    const zDir = B.clone().sub(A).normalize();
                    const inPlane = C.clone().sub(A);
                    const xDir = inPlane.sub(zDir.clone().multiplyScalar(inPlane.dot(zDir))).normalize();
                    const yDir = new THREE.Vector3().crossVectors(zDir, xDir).normalize();
                    transform = new THREE.Matrix4().makeBasis(xDir, yDir, zDir).setPosition(A);

                } else if (cs.nodes) { // Defined by nodes
                    const p1 = globalPositions.get(cs.nodes[0]);
                    const p2 = globalPositions.get(cs.nodes[1]);
                    const p3 = globalPositions.get(cs.nodes[2]);
                    if (!p1 || !p2 || !p3) continue; // Defining nodes not resolved yet

                    const zDir = p2.clone().sub(p1).normalize();
                    const t = p3.clone().sub(p1);
                    const xDir = t.sub(zDir.clone().multiplyScalar(t.dot(zDir))).normalize();
                    const yDir = new THREE.Vector3().crossVectors(zDir, xDir).normalize();
                    transform = new THREE.Matrix4().makeBasis(xDir, yDir, zDir).setPosition(p1);
                }

                if (transform) {
                    globalCoordTransforms.set(cid, transform);
                    pending.delete(cid);
                    progressed = true;
                }
            }
        }
        
        if (pending.size > 0) {
            console.warn('Unresolved CORD2R due to cycles or missing parent RID:', Array.from(pending));
        }

        // Phase C: Resolve all remaining GRID nodes using their CP transform
        for (const nid of model.indexToNid) {
            if (globalPositions.has(nid)) continue; // Already resolved in Phase A
            const n = model.nodes.get(nid);
            const T = globalCoordTransforms.get(n.cp || 0);
            if (!T) {
                 continue;
            }
            const local = new THREE.Vector3(n.x, n.y, n.z);
            globalPositions.set(nid, local.applyMatrix4(T));
        }

        return { globalPositions, globalCoordTransforms };
    }

    function buildGeometries(preserveView = false) {
      let prevCamPos, prevTarget;
      if (preserveView) {
        prevCamPos = camera.position.clone();
        prevTarget = controls.target.clone();
      }
      clearScene();
      const N = model.indexToNid.length;
      const pos = new Float32Array(N*3);
      
      const { globalPositions, globalCoordTransforms } = resolveAllTransforms();
      
      for(let i=0; i<N; i++) {
          const nid = model.indexToNid[i];
          const gp = globalPositions.get(nid);
          if (gp) {
            pos[3*i]   = gp.x; 
            pos[3*i+1] = gp.y; 
            pos[3*i+2] = gp.z;
          } else {
            const n = model.nodes.get(nid);
            const local = new THREE.Vector3(n.x, n.y, n.z);
            pos[3*i]   = local.x; 
            pos[3*i+1] = local.y; 
            pos[3*i+2] = local.z;
          }
      }

      const bbox = new THREE.Box3();
      if (N > 0) {
          bbox.setFromArray(pos);
          if (bbox.min.equals(bbox.max)) { // Handle single point case
              bbox.expandByScalar(0.5);
          }
      } else {
          bbox.set(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
      model.bbox = bbox;

      const ptsGeom = new THREE.BufferGeometry();
      ptsGeom.setAttribute('position', new THREE.BufferAttribute(pos,3));
      points = new THREE.Points(ptsGeom, new THREE.PointsMaterial({ size: 7, sizeAttenuation: false, color: 0x66ccff, clippingPlanes: [clippingPlane] })); 
      points.visible = visibility.nodes;
      scene.add(points);

      const hlGeom = new THREE.BufferGeometry();
      hlGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
      highlightPoints = new THREE.Points(hlGeom, new THREE.PointsMaterial({ size: 12, sizeAttenuation: false, color: 0xffd166, clippingPlanes: [clippingPlane] }));
      scene.add(highlightPoints);

      const shellPositions = [], shellColors = [], shellIndices = [];
      faceToElem = [];
      const usePropColors = colorMode && colorMode.value === 'property';
      let shellVertCounter = 0;

      const processShell = (elem, isQuad) => {
        const nodes = elem.n;
        const [n1,n2,n3,n4] = nodes.map(nid=>model.nodeIndex.get(nid));
        if(nodes.some(nid=>model.nodeIndex.get(nid) === undefined)) return;
        
        let cr, cg, cb;
        if (usePropColors) { [cr,cg,cb] = getPropColor(elem.pid || 0); } 
        else { [cr,cg,cb] = [0x1f/255, 0x6f/255, 0xeb/255]; }

        const p1 = [pos[3*n1],pos[3*n1+1],pos[3*n1+2]];
        const p2 = [pos[3*n2],pos[3*n2+1],pos[3*n2+2]];
        const p3 = [pos[3*n3],pos[3*n3+1],pos[3*n3+2]];
        shellPositions.push(...p1, ...p2, ...p3);
        shellColors.push(cr,cg,cb, cr,cg,cb, cr,cg,cb);
        shellIndices.push(shellVertCounter, shellVertCounter + 1, shellVertCounter + 2);
        shellVertCounter += 3;
        faceToElem.push({ etype:elem.type, eid: elem.eid, nodes: elem.n.slice() });

        if(isQuad) {
            const p4 = [pos[3*n4],pos[3*n4+1],pos[3*n4+2]];
            shellPositions.push(...p4);
            shellColors.push(cr,cg,cb);
            shellIndices.push(shellVertCounter-3, shellVertCounter-1, shellVertCounter);
            shellVertCounter += 1;
            faceToElem.push({ etype:elem.type, eid: elem.eid, nodes: elem.n.slice() });
        }
      };

      if(visibility.ctria3) for(const e of model.elems.tri) { if(!hidden.elems.has(e.eid)) processShell(e, false); }
      if(visibility.cquad4) for(const e of model.elems.quad) { if(!hidden.elems.has(e.eid)) processShell(e, true); }
      
      if(shellPositions.length > 0) {
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.Float32BufferAttribute(shellPositions, 3));
        g.setAttribute('color', new THREE.Float32BufferAttribute(shellColors, 3));
        g.setIndex(shellIndices);
        g.computeVertexNormals();
        const useShading = shadingToggle.checked;
        const mat = useShading ? new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide, shininess: 25, clippingPlanes: [clippingPlane] }) : new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, clippingPlanes: [clippingPlane] });
        meshShell = new THREE.Mesh(g, mat);
        scene.add(meshShell);
        updateOpacity();

        if(visibility.edges) {
            const edgePositions = [];
            const addEdge = (n1, n2) => {
                if (n1 === undefined || n2 === undefined) return;
                edgePositions.push(pos[3*n1], pos[3*n1+1], pos[3*n1+2], pos[3*n2], pos[3*n2+1], pos[3*n2+2]);
            };
            if(visibility.ctria3) for(const e of model.elems.tri) { if(!hidden.elems.has(e.eid)) { const [n1, n2, n3] = e.n.map(nid => model.nodeIndex.get(nid)); addEdge(n1, n2); addEdge(n2, n3); addEdge(n3, n1); }}
            if(visibility.cquad4) for(const e of model.elems.quad) { if(!hidden.elems.has(e.eid)) { const [n1, n2, n3, n4] = e.n.map(nid => model.nodeIndex.get(nid)); addEdge(n1, n2); addEdge(n2, n3); addEdge(n3, n4); addEdge(n4, n1); }}
            if(edgePositions.length > 0) {
                const edgeGeom = new THREE.BufferGeometry();
                edgeGeom.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
                meshWire = new THREE.LineSegments(edgeGeom, new THREE.LineBasicMaterial({ color: 0x000000, clippingPlanes: [clippingPlane] }));
                scene.add(meshWire);
            }
        }
      }

      lineToElem = [];
      const linePos = [], lineColor = [];
      const cbarColor = {r:0.9, g:0.9, b:0.9}, cbeamColor = {r:0.6, g:0.6, b:1.0}, cbushColor = {r:0xff/255, g:0xa6/255, b:0x57/255}, rbe2Color = {r:0x58/255, g:0xa6/255, b:0xff/255}, rbe3Color = {r:0xff/255, g:0xa6/255, b:0x57/255};
      const addLineSegment = (n1, n2, color, elemData) => {
        const i0 = model.nodeIndex.get(n1), i1 = model.nodeIndex.get(n2);
        if (i0 === undefined || i1 === undefined) return;
        linePos.push(pos[3*i0],pos[3*i0+1],pos[3*i0+2], pos[3*i1],pos[3*i1+1],pos[3*i1+2]);
        lineColor.push(color.r, color.g, color.b, color.r, color.g, color.b);
        lineToElem.push(elemData);
      };

      if(visibility.cbar) for (const e of model.elems.bar) { if (!hidden.elems.has(e.eid)) addLineSegment(e.n[0], e.n[1], cbarColor, { etype: e.type, eid: e.eid, nodes: e.n.slice() }); }
      if(visibility.cbeam) for (const e of model.elems.beam) { if (!hidden.elems.has(e.eid)) addLineSegment(e.n[0], e.n[1], cbeamColor, { etype: e.type, eid: e.eid, nodes: e.n.slice() }); }
      if(visibility.rbe2) for (const e of model.elems.rbe2) { if (!hidden.elems.has(e.eid)) for (const dep of e.deps) addLineSegment(e.gn, dep, rbe2Color, { etype: 'RBE2', eid: e.eid, nodes: [e.gn, ...e.deps] }); }
      if(visibility.rbe3) for (const e of model.elems.rbe3) { if (!hidden.elems.has(e.eid)) for (const ind of e.inds) addLineSegment(e.gn, ind, rbe3Color, { etype: 'RBE3', eid: e.eid, nodes: [e.gn, ...e.inds] }); }
      if(visibility.cbush) for (const b of model.elems.bush) { if (!hidden.elems.has(b.eid)) addLineSegment(b.n[0], b.n[1], cbushColor, { etype: b.type, eid: b.eid, nodes: b.n.slice() }); }
      
      if (linePos.length > 0) {
        const lg = new THREE.BufferGeometry();
        lg.setAttribute('position', new THREE.Float32BufferAttribute(linePos,3));
        lg.setAttribute('color', new THREE.Float32BufferAttribute(lineColor,3));
        meshLines = new THREE.LineSegments(lg, new THREE.LineBasicMaterial({ vertexColors: true, clippingPlanes: [clippingPlane] }));
        scene.add(meshLines);
      }
      
      if(visibility.cbush) {
        bushGroup = new THREE.Group();
        for (const b of model.elems.bush) {
            if (hidden.elems.has(b.eid)) continue;
            const p1 = nodePosition(model.nodeIndex.get(b.n[0]));
            const p2 = nodePosition(model.nodeIndex.get(b.n[1]));
            if(!p1 || !p2) continue;
            const bushSprite = new THREE.Sprite(bushMaterial);
            bushSprite.position.copy(p1).add(p2).multiplyScalar(0.5);
            const scale = 0.025 * Number(springSize.value || 1.0);
            bushSprite.scale.set(scale, scale, 1);
            bushSprite.userData = { etype: 'CBUSH', eid: b.eid, nodes: b.n.slice() };
            bushGroup.add(bushSprite);
        }
        if(bushGroup.children.length > 0) scene.add(bushGroup);
      }
      
      clipPlaneHelper = new THREE.PlaneHelper(clippingPlane, model.bbox.getSize(new THREE.Vector3()).length(), 0xffffff);
      if (clippingToggle.checked) scene.add(clipPlaneHelper);

      drawFreeEdges();
      drawOverlays(globalPositions, globalCoordTransforms);
      if (!preserveView) { fitView(); } 
      else { camera.position.copy(prevCamPos); controls.target.copy(prevTarget); controls.update(); }
      
      refreshCounts();
      if (typeof populateModelTree === 'function') populateModelTree();
      updateSelectionVisual();
      highlightSelectedElementVisual();
      updateMeasureUI();
    }

    function drawOverlays(globalPositions, globalCoordTransforms) {
      forceGroup.clear(); momentGroup.clear(); ploadGroup.clear(); spcGroup.clear();
      if(coordSysGroup) coordSysGroup.clear(); else coordSysGroup = new THREE.Group();
      
      for (const f of model.loads.force) {
        if (hidden.loads.has(f)) continue;
        const p = globalPositions.get(f.nid);
        if (!p) continue;
        const dir = nastranToThree(f.dir[0], f.dir[1], f.dir[2]).normalize();
        if (dir.lengthSq() === 0) continue;
        const arrowLength = 1.0;
        const arrow = new THREE.ArrowHelper(dir, p, arrowLength, 0xffa500, arrowLength * 0.3, arrowLength * 0.2);
        arrow.line.material.clippingPlanes = [clippingPlane];
        arrow.cone.material.clippingPlanes = [clippingPlane];
        arrow.userData = { type: 'load', data: f, isStaticSymbol: true, baseScale: 2.5 };
        arrow.children.forEach(c => { c.userData = arrow.userData; c.renderOrder = 999; });
        forceGroup.add(arrow);
      }
      
      for (const m of model.loads.moment) {
        if (hidden.loads.has(m)) continue;
        const p = globalPositions.get(m.nid);
        if (!p) continue;
        const dir = nastranToThree(m.dir[0], m.dir[1], m.dir[2]).normalize();
        if (dir.lengthSq() === 0) continue;
        const arrowLength = 1.0;
        const arrow = createMomentArrow(p, dir, arrowLength, 0x9b59b6);
        arrow.userData = { type: 'load', data: m, isStaticSymbol: true, baseScale: 4.125 };
        arrow.children.forEach(c => c.userData = arrow.userData);
        momentGroup.add(arrow);
      }

      if (Array.isArray(model.loads.pload)) {
        for (const pl of model.loads.pload) {
          if (hidden.loads.has(pl)) continue;
          const pts = pl.nodes.map(nid => globalPositions.get(nid)).filter(Boolean);
          if (pts.length !== pl.nodes.length) continue;
          const centroid = new THREE.Vector3();
          for (const pt of pts) centroid.add(pt);
          centroid.divideScalar(pts.length);
          let normal = new THREE.Vector3(0,0,1);
          if (pts.length >= 3) {
            const v1 = new THREE.Vector3().subVectors(pts[1], pts[0]);
            const v2 = new THREE.Vector3().subVectors(pts[pts.length - 1], pts[0]);
            normal.crossVectors(v1, v2).normalize();
            if (normal.lengthSq() < 1e-8) normal.set(0,0,1);
          }
          const arrowLength = 1.0;
          const arrow = new THREE.ArrowHelper(normal, centroid, arrowLength, 0xff77aa, arrowLength * 0.3, arrowLength * 0.2);
          arrow.line.material.clippingPlanes = [clippingPlane];
          arrow.cone.material.clippingPlanes = [clippingPlane];
          arrow.userData = { type: 'load', data: pl, isStaticSymbol: true, baseScale: 2.5 };
          arrow.children.forEach(c => c.userData = arrow.userData);
          ploadGroup.add(arrow);
        }
      }

      for (const s1 of model.spc1) {
        for (const nid of s1.nodes) {
          const p = globalPositions.get(nid);
          if (!p) continue;
          const key = s1.sid + ':' + nid;
          if (hidden.spc.has(key)) continue;
          const pyramidSize = 1.0;
          const pyramidHeight = pyramidSize * 1.2;
          const pyramidGeom = new THREE.ConeGeometry(pyramidSize, pyramidHeight, 4);
          pyramidGeom.translate(0, -pyramidHeight / 2, 0); 
          const pyramid = new THREE.Mesh(pyramidGeom, new THREE.MeshPhongMaterial({ color: 0x7ee787, clippingPlanes: [clippingPlane] }));
          pyramid.position.copy(p);
          pyramid.userData = { type:'spc', data:{ sid:s1.sid, components:s1.components, nid:nid }, key: key, isStaticSymbol: true, baseScale: 1.0 };
          spcGroup.add(pyramid);
        }
      }

      for (const [cid, transform] of globalCoordTransforms) {
          if (cid === 0) continue;
          if (!transform) continue;
          const origin = new THREE.Vector3().setFromMatrixPosition(transform);
          const xAxis = new THREE.Vector3().setFromMatrixColumn(transform, 0).normalize();
          const yAxis = new THREE.Vector3().setFromMatrixColumn(transform, 1).normalize();
          const zAxis = new THREE.Vector3().setFromMatrixColumn(transform, 2).normalize();
          const length = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() : 1) * 0.05;
          coordSysGroup.add(new THREE.ArrowHelper(xAxis, origin, length, 0xff4b4b));
          coordSysGroup.add(new THREE.ArrowHelper(yAxis, origin, length, 0x4bff4b));
          coordSysGroup.add(new THREE.ArrowHelper(zAxis, origin, length, 0x4b4bff));
      }
      scene.add(coordSysGroup);

      forceGroup.visible = visibility.forces;
      momentGroup.visible = visibility.moments;
      ploadGroup.visible = visibility.forces;
      spcGroup.visible = visibility.spcs;
      coordSysGroup.visible = visibility.coords;
      rebuildLabels();
    }

    // ---- Labels (simple + surface-only) ----
    const MAX_LABELS = 5000; // increased cap for better distribution
    function clearGroup(g){ while(g.children.length > 0) { const child = g.children[0]; g.remove(child); } }
    function makeLabel(text, cls=''){ const el=document.createElement('div'); el.className='label '+cls; el.textContent=text; return new CSS2DObject(el); }
    function rebuildLabels(){ 
      allLabelGroups.forEach(clearGroup);
      const checked = { nodes: showNodeIds.checked, elems: showElemIds.checked, spcs: showSPCLabels.checked, loads: showLoadLabels.checked };
      if (!points) return; 
      if (checked.nodes) buildNodeLabels(); 
      if (checked.elems) buildElemLabels(); 
      if (checked.spcs) buildSPCLabels(); 
      if (checked.loads) buildLoadLabels(); 
    }
    function buildNodeLabels(){ 
      // Show nodes based on current camera view - prioritize closer nodes
      const candidates = [];
      for (let i = 0; i < model.indexToNid.length; i++) {
        const nid = model.indexToNid[i];
        const idx = model.nodeIndex.get(nid);
        if (idx === undefined) continue;
        const p = nodePosition(idx);
        const dist = camera.position.distanceTo(p);
        candidates.push({ nid, p, dist });
      }
      
      // Sort by distance (closer first) and take the closest ones
      candidates.sort((a, b) => a.dist - b.dist);
      const toShow = candidates.slice(0, MAX_LABELS);
      
      for (const { nid, p } of toShow) {
        const lbl = makeLabel(String(nid), 'muted');
        lbl.position.copy(p);
        nodeLabelGroup.add(lbl);
      }
    }
    function buildElemLabels(){ 
      // Show elements based on current camera view - prioritize closer elements
      const candidates = [];
      
      // Collect all elements with their centroids and distances
      for (const e of model.elems.tri) {
        if (hidden.elems.has(e.eid)) continue;
        const c = centroidOf(e.n);
        const dist = camera.position.distanceTo(c);
        candidates.push({ eid: e.eid, pos: c, dist });
      }
      for (const e of model.elems.quad) {
        if (hidden.elems.has(e.eid)) continue;
        const c = centroidOf(e.n);
        const dist = camera.position.distanceTo(c);
        candidates.push({ eid: e.eid, pos: c, dist });
      }
      for (const e of model.elems.bar) {
        if (hidden.elems.has(e.eid)) continue;
        const c = midOf(e.n[0], e.n[1]);
        const dist = camera.position.distanceTo(c);
        candidates.push({ eid: e.eid, pos: c, dist });
      }
      for (const e of model.elems.beam) {
        if (hidden.elems.has(e.eid)) continue;
        const c = midOf(e.n[0], e.n[1]);
        const dist = camera.position.distanceTo(c);
        candidates.push({ eid: e.eid, pos: c, dist });
      }
      for (const e of model.elems.bush) {
        if (hidden.elems.has(e.eid)) continue;
        const c = midOf(e.n[0], e.n[1]);
        const dist = camera.position.distanceTo(c);
        candidates.push({ eid: e.eid, pos: c, dist });
      }
      for (const e of model.elems.rbe2) {
        if (hidden.elems.has(e.eid)) continue;
        const idx = model.nodeIndex.get(e.gn);
        if (idx !== undefined) {
          const p = nodePosition(idx);
          const dist = camera.position.distanceTo(p);
          candidates.push({ eid: e.eid, pos: p, dist });
        }
      }
      for (const e of model.elems.rbe3) {
        if (hidden.elems.has(e.eid)) continue;
        const idx = model.nodeIndex.get(e.gn);
        if (idx !== undefined) {
          const p = nodePosition(idx);
          const dist = camera.position.distanceTo(p);
          candidates.push({ eid: e.eid, pos: p, dist });
        }
      }
      
      // Sort by distance (closer first) and take the closest ones
      candidates.sort((a, b) => a.dist - b.dist);
      const toShow = candidates.slice(0, MAX_LABELS);
      
      for (const { eid, pos } of toShow) {
        const l = makeLabel(String(eid));
        l.position.copy(pos);
        elemLabelGroup.add(l);
      }
    }
    function buildSPCLabels(){ 
      let count = 0;
      for (const s of model.spc1){ for (const nid of s.nodes){ if (count >= MAX_LABELS) break; const idx=model.nodeIndex.get(nid); if (idx===undefined) continue; const p=nodePosition(idx); const l=makeLabel('SID '+s.sid+' '+s.components,'muted'); l.position.copy(p.clone()); spcLabelGroup.add(l); count++; } } 
    }
    function buildLoadLabels() {
      const staticScale = Number(symbolSize.value || 1.0);
      const allLoads = [...model.loads.force, ...model.loads.moment, ...model.loads.pload];
      let count = 0;
      for (const load of allLoads) {
        if (count >= MAX_LABELS) break;
        if(hidden.loads.has(load)) continue;
        let tip, txt;
        const mode = loadLabelMode.value;
        const dist = camera.position.distanceTo(controls.target);
        let arrowLength = dist * 0.01 * staticScale * (load.type === 'MOMENT' ? 4.125 : 2.5);
        if (load.type === 'FORCE' || load.type === 'MOMENT') {
            const idx = model.nodeIndex.get(load.nid); if (idx === undefined) continue;
            const p = nodePosition(idx);
            const d = nastranToThree(load.dir[0], load.dir[1], load.dir[2]).normalize(); if (d.lengthSq() === 0) continue;
            tip = p.clone().add(d.clone().multiplyScalar(arrowLength * 1.1));
            if (mode === 'components') { const [dx, dy, dz] = load.dir; txt = `${load.type[0]}x ${(load.mag * dx).toPrecision(3)}, ${load.type[0]}y ${(load.mag * dy).toPrecision(3)}, ${load.type[0]}z ${(load.mag * dz).toPrecision(3)}`; } 
            else { txt = `${load.type[0]} ${load.mag}`; }
        } else if (load.type === 'PLOAD') {
          const indices = load.nodes.map(nid => model.nodeIndex.get(nid)); if (indices.some(idx => idx === undefined)) continue;
          const centroid = new THREE.Vector3();
          for (const i of indices) centroid.add(nodePosition(i));
          centroid.divideScalar(indices.length);
          let normal = new THREE.Vector3(0, 0, 1);
          if (indices.length >= 3) { const p0=nodePosition(indices[0]), p1=nodePosition(indices[1]), p2=nodePosition(indices[indices.length-1]); normal.crossVectors(new THREE.Vector3().subVectors(p1, p0), new THREE.Vector3().subVectors(p2, p0)).normalize(); }
          tip = centroid.clone().add(normal.clone().multiplyScalar(arrowLength * 1.1));
          txt = 'P ' + load.p;
        }
        if(tip && txt) { const l = makeLabel(txt); l.position.copy(tip); loadLabelGroup.add(l); count++; }
      }
    }
    function centroidOf(ids){ const v=new THREE.Vector3(); let n=0; for (const nid of ids){ const idx=model.nodeIndex.get(nid); if (idx===undefined) continue; v.add(nodePosition(idx)); n++; } if (n>0) v.multiplyScalar(1/n); return v; }
    function midOf(n1,n2){ const a=nodePosition(model.nodeIndex.get(n1)); const b=nodePosition(model.nodeIndex.get(n2)); return a.add(b).multiplyScalar(0.5); }

    function nodePosition(idx){
      if (!points || !points.geometry || !points.geometry.attributes || !points.geometry.attributes.position) {
        const nid = model.indexToNid[idx];
        const n = model.nodes.get(nid);
        if (n) return nastranToThree(n.x, n.y, n.z);
        return new THREE.Vector3(0, 0, 0);
      }
      const pos = points.geometry.attributes.position;
      return new THREE.Vector3(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
    }
    function setNodePosition(idx, tx, ty, tz) {
      const pos = points.geometry.attributes.position;
      pos.setXYZ(idx, tx, ty, tz);
      pos.needsUpdate = true;
      buildGeometries(true);
      recomputeBBox();
    }
    function recomputeBBox(){
      let min = new THREE.Vector3(+Infinity,+Infinity,+Infinity);
      let max = new THREE.Vector3(-Infinity,-Infinity,-Infinity);
      if (points && points.geometry && points.geometry.attributes && points.geometry.attributes.position) {
        const posAttr = points.geometry.attributes.position;
        const v = new THREE.Vector3();
        for (let i=0; i<posAttr.count; i++) {
          v.set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
          min.min(v);
          max.max(v);
        }
      } else {
        for (const node of model.nodes.values()) {
          const p = nastranToThree(node.x, node.y, node.z);
          min.min(p);
          max.max(p);
        }
      }
      if (isFinite(min.x) && isFinite(min.y) && isFinite(min.z) &&
          isFinite(max.x) && isFinite(max.y) && isFinite(max.z)) {
        model.bbox = new THREE.Box3(min, max);
      } else if (!model.bbox) {
        model.bbox = new THREE.Box3(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
      if (typeof axesHelper !== 'undefined' && axesHelper && model.bbox) {
        const sizeVec = model.bbox.getSize(new THREE.Vector3());
        const diag = sizeVec.length();
        const scale = diag > 0 ? diag * 0.15 : 1;
        axesHelper.scale.setScalar(scale);
        axesHelper.position.set(0, 0, 0);
      }
    }

    function showTemporaryLabel(position, text) {
        if (tempLabelTimeout) clearTimeout(tempLabelTimeout);
        while(tempLabelGroup.children.length > 0) { tempLabelGroup.remove(tempLabelGroup.children[0]); }

        const el = document.createElement('div');
        el.className = 'label';
        el.textContent = String(text);
        el.style.color = '#ffd166'; // Highlight color
        el.style.fontSize = '14px';
        el.style.border = '1px solid #ffd166';
        el.style.padding = '4px 8px';
        el.style.zIndex = '10';

        const label = new CSS2DObject(el);
        label.position.copy(position);
        tempLabelGroup.add(label);

        tempLabelTimeout = setTimeout(() => {
            while(tempLabelGroup.children.length > 0) { tempLabelGroup.remove(tempLabelGroup.children[0]); }
            tempLabelTimeout = null;
        }, 3000);
    }

    function fitView(){
        if (!model.bbox) return;
        const box = model.bbox.clone();
        if (box.isEmpty()) {
            if (model.nodes.size > 0) {
                 const firstNodePos = nodePosition(0);
                 box.set(firstNodePos, firstNodePos);
            } else {
                 box.set(new THREE.Vector3(-0.5,-0.5,-0.5), new THREE.Vector3(0.5,0.5,0.5));
            }
        }
        if (box.min.equals(box.max)) { box.expandByScalar(0.5); }
        
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());

        controls.target.copy(center);
        const fitOffset = 1.25;
        const effectiveSize = size * fitOffset;

        const aspect = canvas.clientWidth / canvas.clientHeight;
        const fov = perspectiveCamera.fov * (Math.PI / 180);
        const distance = (camera.isOrthographicCamera) ? effectiveSize / 2 / Math.tan(Math.PI / 18) : effectiveSize / 2 / Math.tan(fov / 2);
        
        camera.position.copy(controls.target).add(new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance));
        
        if (camera.isOrthographicCamera) {
            const h = effectiveSize * 0.5;
            camera.left = -h * aspect;
            camera.right = h * aspect;
            camera.top = h;
            camera.bottom = -h;
            camera.zoom = 1.0;
        }

        camera.updateProjectionMatrix();
        controls.update();
        updateCameraClipping();
    }

    function updateCameraClipping() {
        if (!model.bbox || model.bbox.isEmpty()) return;

        const box = model.bbox.clone();
        box.union(new THREE.Box3().setFromObject(axesGroup)); // Include axes
        
        const viewMatrix = camera.matrixWorldInverse;
        const corners = [
            new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.min.y, box.max.z),
            new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.max.z),
            new THREE.Vector3(box.max.x, box.min.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z),
            new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.max.y, box.max.z),
        ];

        let minZ = Infinity, maxZ = -Infinity;
        for (const corner of corners) {
            const viewPos = corner.clone().applyMatrix4(viewMatrix);
            if (viewPos.z < minZ) minZ = viewPos.z;
            if (viewPos.z > maxZ) maxZ = viewPos.z;
        }

        const near = -maxZ - (maxZ - minZ) * 0.05;
        const far = -minZ + (maxZ - minZ) * 0.05;

        camera.near = Math.max(0.001, near);
        camera.far = Math.max(camera.near + 0.001, far);
        camera.updateProjectionMatrix();
    }


    function updateSelectionVisual() {
      if (!highlightPoints) return;
      const arr = [];
      if (selectMode === 'node') {
        for (const nid of selection.nodes) {
          const idx = model.nodeIndex.get(nid);
          if (idx !== undefined) {
            const p = nodePosition(idx);
            arr.push(p.x, p.y, p.z);
          }
        }
      }
      highlightPoints.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(arr), 3));
      highlightPoints.geometry.setDrawRange(0, arr.length / 3);
      if (highlightPoints.geometry.attributes.position) highlightPoints.geometry.attributes.position.needsUpdate = true;
      highlightPoints.visible = (selectMode === 'node') && arr.length > 0;
    }

    function highlightSelectedElementVisual() {
      if (selectedElemLines) {
        scene.remove(selectedElemLines);
        if (selectedElemLines.geometry) selectedElemLines.geometry.dispose();
        if (selectedElemLines.material) selectedElemLines.material.dispose();
        selectedElemLines = null;
      }
      const sel = Array.from(selection.elems);
      if (sel.length === 0) return;
      const positions = [];
      const allElems = [...model.elems.tri, ...model.elems.quad, ...model.elems.bar, ...model.elems.beam, ...model.elems.bush, ...model.elems.rbe2, ...model.elems.rbe3];

      for (const eid of sel) {
        const foundElem = allElems.find(e => e.eid === eid);
        if (!foundElem) continue;
        
        if (foundElem.type === 'RBE2' || foundElem.type === 'RBE3') {
            const depNodes = foundElem.deps || foundElem.inds;
            for (const depNid of depNodes) {
                const p0 = nodePosition(model.nodeIndex.get(foundElem.gn));
                const p1 = nodePosition(model.nodeIndex.get(depNid));
                if(p0 && p1) positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
        } else {
            const nodes = foundElem.n;
            for (let i = 0; i < nodes.length; i++) {
                const idx0 = model.nodeIndex.get(nodes[i]);
                const idx1 = model.nodeIndex.get(nodes[(i + 1) % nodes.length]);
                if (idx0 === undefined || idx1 === undefined) continue;
                const p0 = nodePosition(idx0);
                const p1 = nodePosition(idx1);
                positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
        }
      }

      if (positions.length > 0) {
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        selectedElemLines = new THREE.LineSegments(geom, new THREE.LineBasicMaterial({ color: 0xffd166, linewidth: 3 }));
        scene.add(selectedElemLines);
      }
    }

    function updateSelectionUI() {
      const editElemCard = document.getElementById('editElementCard');
      
      const selectionEditContainer = document.getElementById('selectionEditContainer');
      const btnCopySelectedNode = document.getElementById('btnCopySelectedNode');
      const nodeDetails = document.getElementById('nodeDetails');

      if (btnCopySelectedNode) {
          btnCopySelectedNode.disabled = !(selectMode === 'node' && selection.nodes.size === 1);
      }

      if (selCount) {
        const n = selection.nodes.size;
        const m = selection.elems.size;
        let countText;
        if (n === 0 && m === 0) countText = 'None';
        else if (m === 0) countText = n + ' node' + (n === 1 ? '' : 's');
        else if (n === 0) countText = m + ' element' + (m === 1 ? '' : 's');
        else countText = n + ' nodes, ' + m + ' elements';
        selCount.textContent = countText;
        if (selCountToolbar) selCountToolbar.textContent = countText;
      }
      
      const isSingleNodeSelected = (selectMode === 'node' && selection.nodes.size === 1);
      nodeDetails.style.display = isSingleNodeSelected ? '' : 'none';

      const hasMultiNodeSelection = (selectMode === 'node' && selection.nodes.size > 1);
      if (hasMultiNodeSelection) {
        selNid.value = '';
        selNid.placeholder = 'Multiple Selected';
      } else if (selection.elems.size === 1) {
        selNid.value = String(Array.from(selection.elems)[0]);
      } else if (selection.elems.size > 1) {
        selNid.value = '';
        selNid.placeholder = 'Multiple Selected';
      }

      if (isSingleNodeSelected) {
        const nid = Array.from(selection.nodes)[0];
        const node = model.nodes.get(nid);
        const idx = model.nodeIndex.get(nid);

        if (node && idx !== undefined) {
          selNid.value = String(nid);
          selX.value = node.x; selY.value = node.y; selZ.value = node.z;
          
          const globalPos = threeToNastran(nodePosition(idx));
          selGX.value = globalPos.x.toPrecision(5);
          selGY.value = globalPos.y.toPrecision(5);
          selGZ.value = globalPos.z.toPrecision(5);

          selCP.value = node.cp || 0; selCD.value = node.cd || 0;
        }
      } else if (selection.nodes.size === 0 && selection.elems.size === 0) {
          selNid.value = '';
          selNid.placeholder = 'Find by ID (Enter)';
      }

      const showElemEdit = (selectMode === 'element' && selection.elems.size === 1);
      editElemCard.style.display = showElemEdit ? '' : 'none';
      if (showElemEdit) {
        const eid = Array.from(selection.elems)[0];
        let elem;
        for (const type in model.elems) {
          const found = model.elems[type].find(e => e.eid === eid);
          if (found) { elem = found; break; }
        }
        if (elem) {
          document.getElementById('editEid').value = elem.eid;
          document.getElementById('editPid').value = elem.pid;
          const nodeFields = [ document.getElementById('editN1'), document.getElementById('editN2'), document.getElementById('editN3'), document.getElementById('editN4') ];
          nodeFields.forEach((nf, i) => {
            if (elem.n && i < elem.n.length) { nf.value = elem.n[i]; nf.parentElement.style.display = ''; } 
            else { nf.value = ''; nf.parentElement.style.display = 'none'; }
          });
          const advFields = document.getElementById('editCquad4AdvancedOptions');
          if (elem.type === 'CQUAD4') {
            advFields.style.display = '';
            document.getElementById('editThetaMcid').value = elem.thetaMcid ?? '';
            document.getElementById('editZoffs').value = elem.zoffs ?? '';
            document.getElementById('editTflag').value = elem.tflag ?? '';
            const t = elem.T || [];
            document.getElementById('editT1').value = t[0] ?? '';
            document.getElementById('editT2').value = t[1] ?? '';
            document.getElementById('editT3').value = t[2] ?? '';
            document.getElementById('editT4').value = t[3] ?? '';
          } else {
            advFields.style.display = 'none';
          }
        }
      }
      
      updateMeasureUI();
    }
    
    function updateMeasureUI() {
        const resultsEl = document.getElementById('measureResults');
        let html = '';

        if (selectMode === 'node' && selection.nodes.size > 1) {
            const selNodes = Array.from(selection.nodes);
            const centroid = {x:0, y:0, z:0};
            for(const nid of selNodes) {
                const pos = threeToNastran(nodePosition(model.nodeIndex.get(nid)));
                centroid.x += pos.x; centroid.y += pos.y; centroid.z += pos.z;
            }
            centroid.x /= selNodes.length; centroid.y /= selNodes.length; centroid.z /= selNodes.length;
            html += `<div class="row" style="margin-bottom:4px"><label style="width:auto;color:var(--text)"><b>Node Centroid</b></label></div>`;
            html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">X:</label><span>${centroid.x.toPrecision(5)}</span></div>`;
            html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">Y:</label><span>${centroid.y.toPrecision(5)}</span></div>`;
            html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">Z:</label><span>${centroid.z.toPrecision(5)}</span></div><hr style="border:none;border-top:1px solid var(--border);margin:8px 0">`;
        }

        if (selectMode === 'node' && selection.nodes.size === 2) {
          const [nid1, nid2] = Array.from(selection.nodes);
          const idx1 = model.nodeIndex.get(nid1);
          const idx2 = model.nodeIndex.get(nid2);

          if (idx1 !== undefined && idx2 !== undefined) {
              const n1 = nodePosition(idx1); const n2 = nodePosition(idx2);
              const v1 = threeToNastran(n1); const v2 = threeToNastran(n2);
              const dx = v2.x - v1.x, dy = v2.y - v1.y, dz = v2.z - v1.z;
              const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
              html += `<div class="row" style="margin-bottom:4px"><label style="width:auto;color:var(--text)"><b>Distance</b></label><span>${nid1} to ${nid2}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔX:</label><span>${dx.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔY:</label><span>${dy.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔZ:</label><span>${dz.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">Dist:</label><span><b>${dist.toPrecision(5)}</b></span></div><hr style="border:none;border-top:1px solid var(--border);margin:8px 0">`;
          }
        }
        
        if (selectMode === 'node' && selection.nodes.size === 3) {
            const [nid1, nid2, nid3] = Array.from(selection.nodes);
            const p1 = nodePosition(model.nodeIndex.get(nid1));
            const p2 = nodePosition(model.nodeIndex.get(nid2)); // Vertex
            const p3 = nodePosition(model.nodeIndex.get(nid3));
            if (p1 && p2 && p3) {
                const v1 = new THREE.Vector3().subVectors(p1, p2).normalize();
                const v2 = new THREE.Vector3().subVectors(p3, p2).normalize();
                const angleRad = v1.angleTo(v2);
                const angleDeg = angleRad * 180 / Math.PI;
                html += `<div class="row" style="margin-bottom:4px"><label style="width:auto;color:var(--text)"><b>Angle</b></label><span>${nid1}-${nid2}-${nid3}</span></div><div class="row"><label>Angle:</label><span><b>${angleDeg.toPrecision(5)}°</b></span></div><hr style="border:none;border-top:1px solid var(--border);margin:8px 0">`;
            }
        }
        
        if (selectMode === 'element' && selection.elems.size > 0) {
            let totalArea = 0;
            const centroid = new THREE.Vector3();
            const allShells = [...model.elems.tri, ...model.elems.quad];
            
            for (const eid of selection.elems) {
                const elem = allShells.find(e => e.eid === eid);
                if (!elem) continue;
                
                const p = elem.n.map(nid => nodePosition(model.nodeIndex.get(nid)));
                if (p.some(v => !v)) continue;

                if (elem.type === 'CTRIA3') {
                    const v1 = new THREE.Vector3().subVectors(p[1], p[0]);
                    const v2 = new THREE.Vector3().subVectors(p[2], p[0]);
                    const area = new THREE.Vector3().crossVectors(v1, v2).length() / 2;
                    const c = new THREE.Vector3().add(p[0]).add(p[1]).add(p[2]).divideScalar(3);
                    centroid.add(c.multiplyScalar(area));
                    totalArea += area;
                } else if (elem.type === 'CQUAD4') {
                    const v1_1 = new THREE.Vector3().subVectors(p[1], p[0]);
                    const v2_1 = new THREE.Vector3().subVectors(p[2], p[0]);
                    const area1 = new THREE.Vector3().crossVectors(v1_1, v2_1).length() / 2;
                    const c1 = new THREE.Vector3().add(p[0]).add(p[1]).add(p[2]).divideScalar(3);
                    centroid.add(c1.multiplyScalar(area1));
                    totalArea += area1;
                    
                    const v1_2 = new THREE.Vector3().subVectors(p[2], p[0]);
                    const v2_2 = new THREE.Vector3().subVectors(p[3], p[0]);
                    const area2 = new THREE.Vector3().crossVectors(v1_2, v2_2).length() / 2;
                    const c2 = new THREE.Vector3().add(p[0]).add(p[2]).add(p[3]).divideScalar(3);
                    centroid.add(c2.multiplyScalar(area2));
                    totalArea += area2;
                }
            }

            if (totalArea > 0) {
                centroid.divideScalar(totalArea);
                const c_vis = threeToNastran(centroid);
                html += `<div class="row" style="margin-bottom:4px"><label style="width:auto;color:var(--text)"><b>Element Properties</b></label></div>`;
                html += `<div class="row"><label>Total Area:</label><span>${totalArea.toPrecision(5)}</span></div>`;
                html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">Centroid X:</label><span>${c_vis.x.toPrecision(5)}</span></div>`;
                html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">Centroid Y:</label><span>${c_vis.y.toPrecision(5)}</span></div>`;
                html += `<div class="row" style="margin-bottom:4px"><label style="width:auto">Centroid Z:</label><span>${c_vis.z.toPrecision(5)}</span></div>`;
            }
        }

        if (html === '') {
            html = '<small>Select 2 nodes for distance.<br>Select 3 nodes for angle.<br>Select multiple nodes/elements for centroid & area.</small>';
        }

        resultsEl.innerHTML = html;
    }


    function populateModelTree() {
      if (!modelTreeContainer) return;
      modelTreeContainer.innerHTML = '';
      const root = document.createElement('ul');
      const nodesLi = document.createElement('li');
      nodesLi.textContent = 'Nodes (' + model.indexToNid.length + ')';
      nodesLi.addEventListener('click', (ev) => { ev.stopPropagation(); selection.nodes = new Set(model.indexToNid); selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(nodesLi);
      
      const totalElems = Object.values(model.elems).reduce((sum, arr) => sum + arr.length, 0);
      const elemsLi = document.createElement('li');
      elemsLi.textContent = 'Elements (' + totalElems + ')';
      const elemSub = document.createElement('ul');
      function addElemType(name, arr) {
        if (arr.length === 0) return;
        const li = document.createElement('li');
        li.textContent = name + ' (' + arr.length + ')';
        li.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const s = new Set();
          for (const e of arr) {
            const nodes = e.n || [e.gn, ...(e.deps || e.inds)];
            for (const nid of nodes) s.add(nid);
          }
          selection.nodes = s;
          selection.elems.clear();
          updateSelectionVisual();
          updateSelectionUI();
        });
        elemSub.appendChild(li);
      }
      addElemType('CTRIA3', model.elems.tri); addElemType('CQUAD4', model.elems.quad); addElemType('CBAR', model.elems.bar); addElemType('CBEAM', model.elems.beam); addElemType('CBUSH', model.elems.bush); addElemType('RBE2', model.elems.rbe2); addElemType('RBE3', model.elems.rbe3);
      elemsLi.appendChild(elemSub);
      elemsLi.addEventListener('click', (ev) => { if (ev.target === elemsLi) elemsLi.classList.toggle('open'); ev.stopPropagation(); });
      root.appendChild(elemsLi);

      const totalLoads = (model.loads.force?.length || 0) + (model.loads.pload?.length || 0) + (model.loads.moment?.length || 0);
      const loadsLi = document.createElement('li');
      loadsLi.textContent = 'Loads (' + totalLoads + ')';
      loadsLi.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); if (model.loads.force) for (const f of model.loads.force) s.add(f.nid); if (model.loads.moment) for (const m of model.loads.moment) s.add(m.nid); if (model.loads.pload) for (const pl of model.loads.pload) for (const nid of pl.nodes) s.add(nid); selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(loadsLi);
      
      const spcCount = model.spc1.reduce((sum, grp) => sum + grp.nodes.length, 0);
      const spcLi = document.createElement('li');
      spcLi.textContent = 'SPC1 (' + spcCount + ')';
      spcLi.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); for (const grp of model.spc1) { for (const nid of grp.nodes) s.add(nid); } selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(spcLi);
      
      if (model.coords.size > 0) {
        const coordsLi = document.createElement('li');
        coordsLi.textContent = 'Coord Sys ('+model.coords.size+')';
        const coordsSub = document.createElement('ul');
        for (const [cid, cs] of model.coords) {
          const li = document.createElement('li');
          li.textContent = cs.type + ' ' + cid;
          li.addEventListener('click', (ev) => { ev.stopPropagation(); if(cs.nodes) selection.nodes = new Set(cs.nodes); selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
          coordsSub.appendChild(li);
        }
        coordsLi.appendChild(coordsSub);
        coordsLi.addEventListener('click', (ev) => { if (ev.target === coordsLi) coordsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(coordsLi);
      }

      if (model.properties.size > 0) {
        const propsLi = document.createElement('li');
        propsLi.textContent = 'Properties (' + model.properties.size + ')';
        const propsSub = document.createElement('ul');
        for (const [pid, prop] of model.properties) {
          const li = document.createElement('li');
          li.textContent = prop.type + ' ' + pid;
          li.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); for (const t of Object.keys(model.elems)) { for (const e of model.elems[t]) { if (e.pid === pid) { const nodes = e.n || [e.gn, ...(e.deps || e.inds)]; for (const nid of nodes) s.add(nid); } } } selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
          propsSub.appendChild(li);
        }
        propsLi.appendChild(propsSub);
        propsLi.addEventListener('click', (ev) => { if (ev.target === propsLi) propsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(propsLi);
      }
      
      if (model.materials.size > 0) {
        const matsLi = document.createElement('li');
        matsLi.textContent = 'Materials (' + model.materials.size + ')';
        const matsSub = document.createElement('ul');
        for (const [mid, mat] of model.materials) { const li = document.createElement('li'); li.textContent = 'MAT1 ' + mid; matsSub.appendChild(li); }
        matsLi.appendChild(matsSub);
        matsLi.addEventListener('click', (ev) => { if (ev.target === matsLi) matsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(matsLi);
      }
      modelTreeContainer.appendChild(root);
    }

    // --------------- Interaction ---------------
    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let selectedIdx = -1;

    function onClick(ev) {
      if (ev.altKey || boxSelecting) return;
      if (isPolygonSelecting) {
        addPolygonPoint(ev);
        return;
      }
      if (contextMenu && contextMenu.style.display === 'block') { contextMenu.style.display = 'none'; return; }
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (selectMode === 'node') {
        if (!points || !model.indexToNid.length) return;
        
        // --- SELECTION FIX: Use pixel-based distance check for all node selections ---
        // This method is more accurate than raycasting for dense meshes, especially when zoomed.
        const rectCanvas = canvas.getBoundingClientRect();
        const cx = ev.clientX - rectCanvas.left;
        const cy = ev.clientY - rectCanvas.top;
        
        let bestDistSq = Infinity;
        let indexHit = -1;

        for (let i = 0; i < model.indexToNid.length; i++) {
            const p3 = nodePosition(i).clone().project(camera);
            
            // Cull nodes that are behind the camera plane
            if (p3.z > 1 || p3.z < -1) continue;

            const sx = (p3.x * 0.5 + 0.5) * rectCanvas.width;
            const sy = (-p3.y * 0.5 + 0.5) * rectCanvas.height;
            const dx = sx - cx;
            const dy = sy - cy;
            const dSq = dx * dx + dy * dy;

            if (dSq < bestDistSq) {
                bestDistSq = dSq;
                indexHit = i;
            }
        }
        
        // Only accept the hit if it's within a reasonable pixel distance (e.g., 20px radius)
        if (bestDistSq > 400) { // 20*20 = 400
            indexHit = -1;
        }
        // --- END SELECTION FIX ---

        if (indexHit >= 0) {
          const nid = model.indexToNid[indexHit];
          showTemporaryLabel(nodePosition(indexHit), nid);
          selectNode(indexHit);
          if (currentElemInput) {
            currentElemInput.value = String(nid);
            const order = [elemN1, elemN2, elemN3, elemN4, csysN1, csysN2, csysN3, document.getElementById('meshVecN1'), document.getElementById('meshVecN2'), document.getElementById('meshRadN1'), document.getElementById('meshRadN2'), document.getElementById('reflectN1'), document.getElementById('reflectN2'), document.getElementById('reflectN3')];
            const idxInput = order.indexOf(currentElemInput);
            if (idxInput >= 0) {
              let nextIndex = idxInput + 1;
              while (nextIndex < order.length && order[nextIndex]?.parentElement.closest('.row, .grid-3').style.display === 'none') nextIndex++;
              if (nextIndex < order.length && order[nextIndex]?.parentElement.closest('.row, .grid-3').style.display !== 'none') { currentElemInput = order[nextIndex]; order[nextIndex].focus(); } 
              else { currentElemInput = null; }
            } else { currentElemInput = null; }
          }
          if (multiSelectMode) { if (selection.nodes.has(nid)) selection.nodes.delete(nid); else selection.nodes.add(nid); } 
          else { selection.nodes = new Set([nid]); selection.elems.clear(); }
          updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI();
        }
      } else if (selectMode === 'element') {
        raycaster.params.Line.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.01 : 0.1);
        const intersectable = [meshShell, meshLines, bushGroup].filter(o => o && o.visible);
        const hits = raycaster.intersectObjects(intersectable, true);
        if (hits.length > 0) {
            let hitData;
            const hit = hits[0];
            if (hit.object.type === 'Sprite') { hitData = hit.object.userData; } 
            else if (hit.object === meshShell) { hitData = faceToElem[hit.faceIndex]; } 
            else if (hit.object === meshLines) { hitData = lineToElem[hit.faceIndex]; }
            if (hitData) {
              const { eid, nodes } = hitData;
              showTemporaryLabel(centroidOf(nodes), eid);
              if (multiSelectMode) { if (selection.elems.has(eid)) { selection.elems.delete(eid); } else { selection.elems.add(eid); } } 
              else { selection.elems = new Set([eid]); selection.nodes.clear(); }
              updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); statusMsg('Selected element ' + eid);
            }
        }
      }
    }
    function onDoubleClick(ev) {
        if (isPolygonSelecting) {
            finalizePolygonSelection();
            return;
        }

        const rect = canvas.getBoundingClientRect();
        mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersectable = [meshShell, meshLines, points, bushGroup].filter(o => o && o.visible);
        const hits = raycaster.intersectObjects(intersectable, true);

        if (hits.length > 0) {
            controls.target.copy(hits[0].point);
            statusMsg('Rotation point set.');
        } else {
            // Reset to center of bounding box if we click empty space
            if (model.bbox) {
                const center = model.bbox.getCenter(new THREE.Vector3());
                controls.target.copy(center);
                statusMsg('Rotation point reset to model center.');
            }
        }
        controls.update();
    }
    function selectNode(i){ 
        if (i < 0) return; selectedIdx=i; 
        const nid=model.indexToNid[i], p=nodePosition(i); 
        if (!selectionSphere){ selectionSphere=new THREE.Mesh(new THREE.SphereGeometry(1,16,12), new THREE.MeshBasicMaterial({ color: 0xffd166, transparent:true, opacity:0.7 })); scene.add(selectionSphere); }
        const size = model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() : 1;
        selectionSphere.scale.setScalar(size * 0.0025 * Number(symbolSize.value || 1.0));
        selectionSphere.position.copy(p); 
        statusMsg('Selected node '+nid); 
    }
    canvas.addEventListener('click', onClick);
    canvas.addEventListener('dblclick', onDoubleClick);

    for (const inp of nodeInputs) { if (!inp) continue; inp.addEventListener('focus', () => { currentElemInput = inp; }); }
    
    document.querySelectorAll('input[data-vis]').forEach(cb => { cb.addEventListener('change', () => { visibility[cb.dataset.vis] = cb.checked; buildGeometries(true); }); });
    if(opacitySlider) opacitySlider.addEventListener('input', updateOpacity);
    if (shadingToggle) shadingToggle.addEventListener('change', () => buildGeometries(true));
    if (showFreeEdges) showFreeEdges.addEventListener('change', () => buildGeometries(true));
    
    if(parallelToggle) {
        parallelToggle.addEventListener('change', (e) => {
            const oldCamera = camera;
            if (e.target.checked) {
                camera = orthographicCamera;
            } else {
                camera = perspectiveCamera;
            }
            camera.position.copy(oldCamera.position);
            camera.quaternion.copy(oldCamera.quaternion);
            fitView(); // Recalculate everything for the new camera type
            controls.object = camera;
            controls.update();
        });
    }

    if(bgColorPicker) bgColorPicker.addEventListener('input', (e) => { scene.background = new THREE.Color(e.target.value); });

    const sampleDatFile = `
$ START OF BULK DATA
$
$ WebMeshEditor Sample: FULL High-Density Delta Wing
$ This is the complete model with all elements generated.
$ Features a 4-element chord-wise mesh and varied property IDs
$ by bay to demonstrate property-based coloring.
$
$=======================================================================
$ 1. Grid Points (Nodes)
$=======================================================================
$ 13 span-wise stations, each with 10 nodes to define the chord.
$
$       --- X ---     --- Y ---    --- Z ---
GRID,101,0,0.000,0.000,5.000
GRID,102,0,20.000,0.000,5.000
GRID,103,0,40.000,0.000,5.000
GRID,104,0,60.000,0.000,5.000
GRID,105,0,80.000,0.000,5.000
GRID,106,0,0.000,0.000,-5.000
GRID,107,0,20.000,0.000,-5.000
GRID,108,0,40.000,0.000,-5.000
GRID,109,0,60.000,0.000,-5.000
GRID,110,0,80.000,0.000,-5.000
GRID,201,0,2.917,12.500,4.667
GRID,202,0,21.46,12.500,4.667
GRID,203,0,40.00,12.500,4.667
GRID,204,0,58.54,12.500,4.667
GRID,205,0,77.08,12.500,4.667
GRID,206,0,2.917,12.500,-4.667
GRID,207,0,21.46,12.500,-4.667
GRID,208,0,40.00,12.500,-4.667
GRID,209,0,58.54,12.500,-4.667
GRID,210,0,77.08,12.500,-4.667
GRID,301,0,5.833,25.000,4.333
GRID,302,0,22.92,25.000,4.333
GRID,303,0,40.00,25.000,4.333
GRID,304,0,57.08,25.000,4.333
GRID,305,0,74.17,25.000,4.333
GRID,306,0,5.833,25.000,-4.333
GRID,307,0,22.92,25.000,-4.333
GRID,308,0,40.00,25.000,-4.333
GRID,309,0,57.08,25.000,-4.333
GRID,310,0,74.17,25.000,-4.333
GRID,401,0,8.750,37.500,4.000
GRID,402,0,24.38,37.500,4.000
GRID,403,0,40.00,37.500,4.000
GRID,404,0,55.62,37.500,4.000
GRID,405,0,71.25,37.500,4.000
GRID,406,0,8.750,37.500,-4.000
GRID,407,0,24.38,37.500,-4.000
GRID,408,0,40.00,37.500,-4.000
GRID,409,0,55.62,37.500,-4.000
GRID,410,0,71.25,37.500,-4.000
GRID,501,0,11.67,50.000,3.667
GRID,502,0,25.83,50.000,3.667
GRID,503,0,40.00,50.000,3.667
GRID,504,0,54.17,50.000,3.667
GRID,505,0,68.33,50.000,3.667
GRID,506,0,11.67,50.000,-3.667
GRID,507,0,25.83,50.000,-3.667
GRID,508,0,40.00,50.000,-3.667
GRID,509,0,54.17,50.000,-3.667
GRID,510,0,68.33,50.000,-3.667
GRID,601,0,14.58,62.500,3.333
GRID,602,0,27.29,62.500,3.333
GRID,603,0,40.00,62.500,3.333
GRID,604,0,52.71,62.500,3.333
GRID,605,0,65.42,62.500,3.333
GRID,606,0,14.58,62.500,-3.333
GRID,607,0,27.29,62.500,-3.333
GRID,608,0,40.00,62.500,-3.333
GRID,609,0,52.71,62.500,-3.333
GRID,610,0,65.42,62.500,-3.333
GRID,701,0,17.50,75.000,3.000
GRID,702,0,28.75,75.000,3.000
GRID,703,0,40.00,75.000,3.000
GRID,704,0,51.25,75.000,3.000
GRID,705,0,62.50,75.000,3.000
GRID,706,0,17.50,75.000,-3.000
GRID,707,0,28.75,75.000,-3.000
GRID,708,0,40.00,75.000,-3.000
GRID,709,0,51.25,75.000,-3.000
GRID,710,0,62.50,75.000,-3.000
GRID,801,0,20.42,87.500,2.667
GRID,802,0,30.21,87.500,2.667
GRID,803,0,40.00,87.500,2.667
GRID,804,0,49.79,87.500,2.667
GRID,805,0,59.58,87.500,2.667
GRID,806,0,20.42,87.500,-2.667
GRID,807,0,30.21,87.500,-2.667
GRID,808,0,40.00,87.500,-2.667
GRID,809,0,49.79,87.500,-2.667
GRID,810,0,59.58,87.500,-2.667
GRID,901,0,23.33,100.00,2.333
GRID,902,0,31.67,100.00,2.333
GRID,903,0,40.00,100.00,2.333
GRID,904,0,48.33,100.00,2.333
GRID,905,0,56.67,100.00,2.333
GRID,906,0,23.33,100.00,-2.333
GRID,907,0,31.67,100.00,-2.333
GRID,908,0,40.00,100.00,-2.333
GRID,909,0,48.33,100.00,-2.333
GRID,910,0,56.67,100.00,-2.333
GRID,1001,0,26.25,112.50,2.000
GRID,1002,0,33.12,112.50,2.000
GRID,1003,0,40.00,112.50,2.000
GRID,1004,0,46.88,112.50,2.000
GRID,1005,0,53.75,112.50,2.000
GRID,1006,0,26.25,112.50,-2.000
GRID,1007,0,33.12,112.50,-2.000
GRID,1008,0,40.00,112.50,-2.000
GRID,1009,0,46.88,112.50,-2.000
GRID,1010,0,53.75,112.50,-2.000
GRID,1101,0,29.17,125.00,1.667
GRID,1102,0,34.58,125.00,1.667
GRID,1103,0,40.00,125.00,1.667
GRID,1104,0,45.42,125.00,1.667
GRID,1105,0,50.83,125.00,1.667
GRID,1106,0,29.17,125.00,-1.667
GRID,1107,0,34.58,125.00,-1.667
GRID,1108,0,40.00,125.00,-1.667
GRID,1109,0,45.42,125.00,-1.667
GRID,1110,0,50.83,125.00,-1.667
GRID,1201,0,32.08,137.50,1.333
GRID,1202,0,36.04,137.50,1.333
GRID,1203,0,40.00,137.50,1.333
GRID,1204,0,43.96,137.50,1.333
GRID,1205,0,47.92,137.50,1.333
GRID,1206,0,32.08,137.50,-1.333
GRID,1207,0,36.04,137.50,-1.333
GRID,1208,0,40.00,137.50,-1.333
GRID,1209,0,43.96,137.50,-1.333
GRID,1210,0,47.92,137.50,-1.333
GRID,1301,0,35.00,150.00,1.000
GRID,1302,0,37.50,150.00,1.000
GRID,1303,0,40.00,150.00,1.000
GRID,1304,0,42.50,150.00,1.000
GRID,1305,0,45.00,150.00,1.000
GRID,1306,0,35.00,150.00,-1.000
GRID,1307,0,37.50,150.00,-1.000
GRID,1308,0,40.00,150.00,-1.000
GRID,1309,0,42.50,150.00,-1.000
GRID,1310,0,45.00,150.00,-1.000
$
$ Pylon and Control Nodes
GRID,99,0,40.0,0.0,0.0         $ RBE2 Independent Node (Root Constraint)
GRID,1399,0,40.0,150.0,0.0      $ RBE3 Dependent Node (Tip Load)
GRID,791,0,28.75,75.0,-6.0      $ Pylon/Engine point (Fwd)
GRID,792,0,51.25,75.0,-6.0      $ Pylon/Engine point (Aft)
GRID,799,0,40.0,75.0,-6.0       $ RBE3 Dependent Node (Pylon Load)
$
$=======================================================================
$ 2. Elements
$=======================================================================
$ Elements are defined for all 12 bays.
$ Property IDs change for bays 1-4, 5-8, and 9-12.
$
$ --- Function to generate a bay (logic used to create this file) ---
$ def create_bay(bay_num, p_skin, p_web, p_beam, p_rib):
$   n_start = bay_num * 100
$   n_end = (bay_num + 1) * 100
$   ... generate connectivity ...
$
$ --- Bays 1-4 : Root Section Properties (PIDs 11, 12, 13, 14) ---
$ BAY 1
CQUAD4,1011,11,101,201,202,102
CQUAD4,1012,11,102,202,203,103
CQUAD4,1013,11,103,203,204,104
CQUAD4,1014,11,104,204,205,105
CQUAD4,1015,11,106,107,207,206
CQUAD4,1016,11,107,108,208,207
CQUAD4,1017,11,108,109,209,208
CQUAD4,1018,11,109,110,210,209
CQUAD4,1019,12,101,106,206,201
CQUAD4,1020,12,105,205,210,110
CBEAM,2011,13,101,201
CBEAM,2012,13,102,202
CBEAM,2013,13,103,203
CBEAM,2014,13,104,204
CBEAM,2015,13,105,205
CBEAM,2016,13,106,206
CBEAM,2017,13,107,207
CBEAM,2018,13,108,208
CBEAM,2019,13,109,209
CBEAM,2020,13,110,210
CBAR,3011,14,101,102
CBAR,3012,14,102,103
CBAR,3013,14,103,104
CBAR,3014,14,104,105
CBAR,3015,14,106,107
CBAR,3016,14,107,108
CBAR,3017,14,108,109
CBAR,3018,14,109,110
CBAR,3019,14,101,106
CBAR,3020,14,102,107
CBAR,3021,14,103,108
CBAR,3022,14,104,109
CBAR,3023,14,105,110
$ BAY 2
CQUAD4,1021,11,201,301,302,202
CQUAD4,1022,11,202,302,303,203
CQUAD4,1023,11,203,303,304,204
CQUAD4,1024,11,204,304,305,205
CQUAD4,1025,11,206,207,307,306
CQUAD4,1026,11,207,208,308,307
CQUAD4,1027,11,208,209,309,308
CQUAD4,1028,11,209,210,310,309
CQUAD4,1029,12,201,206,306,301
CQUAD4,1030,12,205,305,310,210
CBEAM,2021,13,201,301
CBEAM,2022,13,202,302
CBEAM,2023,13,203,303
CBEAM,2024,13,204,304
CBEAM,2025,13,205,305
CBEAM,2026,13,206,306
CBEAM,2027,13,207,307
CBEAM,2028,13,208,308
CBEAM,2029,13,209,309
CBEAM,2030,13,210,310
CBAR,3031,14,201,202
CBAR,3032,14,202,203
CBAR,3033,14,203,204
CBAR,3034,14,204,205
CBAR,3035,14,206,207
CBAR,3036,14,207,208
CBAR,3037,14,208,209
CBAR,3038,14,209,210
CBAR,3039,14,201,206
CBAR,3040,14,202,207
CBAR,3041,14,203,208
CBAR,3042,14,204,209
CBAR,3043,14,205,210
$ BAY 3
CQUAD4,1041,11,301,401,402,302
CQUAD4,1042,11,302,402,403,303
CQUAD4,1043,11,303,403,404,304
CQUAD4,1044,11,304,404,405,305
CQUAD4,1045,11,306,307,407,406
CQUAD4,1046,11,307,308,408,407
CQUAD4,1047,11,308,309,409,408
CQUAD4,1048,11,309,310,410,409
CQUAD4,1049,12,301,306,406,401
CQUAD4,1050,12,305,405,410,310
CBEAM,2041,13,301,401
CBEAM,2042,13,302,402
CBEAM,2043,13,303,403
CBEAM,2044,13,304,404
CBEAM,2045,13,305,405
CBEAM,2046,13,306,406
CBEAM,2047,13,307,407
CBEAM,2048,13,308,408
CBEAM,2049,13,309,409
CBEAM,2050,13,310,410
CBAR,3051,14,301,302
CBAR,3052,14,302,303
CBAR,3053,14,303,304
CBAR,3054,14,304,305
CBAR,3055,14,306,307
CBAR,3056,14,307,308
CBAR,3057,14,308,309
CBAR,3058,14,309,310
CBAR,3059,14,301,306
CBAR,3060,14,302,307
CBAR,3061,14,303,308
CBAR,3062,14,304,309
CBAR,3063,14,305,310
$ BAY 4
CQUAD4,1061,11,401,501,502,402
CQUAD4,1062,11,402,502,503,403
CQUAD4,1063,11,403,503,504,404
CQUAD4,1064,11,404,504,505,405
CQUAD4,1065,11,406,407,507,506
CQUAD4,1066,11,407,408,508,507
CQUAD4,1067,11,408,409,509,508
CQUAD4,1068,11,409,410,510,509
CQUAD4,1069,12,401,406,506,501
CQUAD4,1070,12,405,505,510,410
CBEAM,2061,13,401,501
CBEAM,2062,13,402,502
CBEAM,2063,13,403,503
CBEAM,2064,13,404,504
CBEAM,2065,13,405,505
CBEAM,2066,13,406,506
CBEAM,2067,13,407,507
CBEAM,2068,13,408,508
CBEAM,2069,13,409,509
CBEAM,2070,13,410,510
CBAR,3071,14,401,402
CBAR,3072,14,402,403
CBAR,3073,14,403,404
CBAR,3074,14,404,405
CBAR,3075,14,406,407
CBAR,3076,14,407,408
CBAR,3077,14,408,409
CBAR,3078,14,409,410
CBAR,3079,14,401,406
CBAR,3080,14,402,407
CBAR,3081,14,403,408
CBAR,3082,14,404,409
CBAR,3083,14,405,410
$
$ --- Bays 5-8 : Mid Section Properties (PIDs 21, 22, 23, 24) ---
$ BAY 5
CQUAD4,1081,21,501,601,602,502
CQUAD4,1082,21,502,602,603,503
CQUAD4,1083,21,503,603,604,504
CQUAD4,1084,21,504,604,605,505
CQUAD4,1085,21,506,507,607,606
CQUAD4,1086,21,507,508,608,607
CQUAD4,1087,21,508,509,609,608
CQUAD4,1088,21,509,510,610,609
CQUAD4,1089,22,501,506,606,601
CQUAD4,1090,22,505,605,610,510
CBEAM,2081,23,501,601
CBEAM,2082,23,502,602
CBEAM,2083,23,503,603
CBEAM,2084,23,504,604
CBEAM,2085,23,505,605
CBEAM,2086,23,506,606
CBEAM,2087,23,507,607
CBEAM,2088,23,508,608
CBEAM,2089,23,509,609
CBEAM,2090,23,510,610
CBAR,3091,24,501,502
CBAR,3092,24,502,503
CBAR,3093,24,503,504
CBAR,3094,24,504,505
CBAR,3095,24,506,507
CBAR,3096,24,507,508
CBAR,3097,24,508,509
CBAR,3098,24,509,510
CBAR,3099,24,501,506
CBAR,3100,24,502,507
CBAR,3101,24,503,508
CBAR,3102,24,504,509
CBAR,3103,24,505,510
$ BAY 6
CQUAD4,1101,21,601,701,702,602
CQUAD4,1102,21,602,702,703,603
CQUAD4,1103,21,603,703,704,604
CQUAD4,1104,21,604,704,705,605
CQUAD4,1105,21,606,607,707,706
CQUAD4,1106,21,607,608,708,707
CQUAD4,1107,21,608,609,709,708
CQUAD4,1108,21,609,610,710,709
CQUAD4,1109,22,601,606,706,701
CQUAD4,1110,22,605,705,710,610
CBEAM,2101,23,601,701
CBEAM,2102,23,602,702
CBEAM,2103,23,603,703
CBEAM,2104,23,604,704
CBEAM,2105,23,605,705
CBEAM,2106,23,606,706
CBEAM,2107,23,607,707
CBEAM,2108,23,608,708
CBEAM,2109,23,609,709
CBEAM,2110,23,610,710
CBAR,3111,24,601,602
CBAR,3112,24,602,603
CBAR,3113,24,603,604
CBAR,3114,24,604,605
CBAR,3115,24,606,607
CBAR,3116,24,607,608
CBAR,3117,24,608,609
CBAR,3118,24,609,610
CBAR,3119,24,601,606
CBAR,3120,24,602,607
CBAR,3121,24,603,608
CBAR,3122,24,604,609
CBAR,3123,24,605,610
$ BAY 7
CQUAD4,1121,21,701,801,802,702
CQUAD4,1122,21,702,802,803,703
CQUAD4,1123,21,703,803,804,704
CQUAD4,1124,21,704,804,805,705
CQUAD4,1125,21,706,707,807,806
CQUAD4,1126,21,707,708,808,807
CQUAD4,1127,21,708,709,809,808
CQUAD4,1128,21,709,710,810,809
CQUAD4,1129,22,701,706,806,801
CQUAD4,1130,22,705,805,810,710
CBEAM,2121,23,701,801
CBEAM,2122,23,702,802
CBEAM,2123,23,703,803
CBEAM,2124,23,704,804
CBEAM,2125,23,705,805
CBEAM,2126,23,706,806
CBEAM,2127,23,707,807
CBEAM,2128,23,708,808
CBEAM,2129,23,709,809
CBEAM,2130,23,710,810
CBAR,3131,24,701,702
CBAR,3132,24,702,703
CBAR,3133,24,703,704
CBAR,3134,24,704,705
CBAR,3135,24,706,707
CBAR,3136,24,707,708
CBAR,3137,24,708,709
CBAR,3138,24,709,710
CBAR,3139,24,701,706
CBAR,3140,24,702,707
CBAR,3141,24,703,708
CBAR,3142,24,704,709
CBAR,3143,24,705,710
$ BAY 8
CQUAD4,1141,21,801,901,902,802
CQUAD4,1142,21,802,902,903,803
CQUAD4,1143,21,803,903,904,804
CQUAD4,1144,21,804,904,905,805
CQUAD4,1145,21,806,807,907,906
CQUAD4,1146,21,807,808,908,907
CQUAD4,1147,21,808,809,909,908
CQUAD4,1148,21,809,810,910,909
CQUAD4,1149,22,801,806,906,901
CQUAD4,1150,22,805,905,910,810
CBEAM,2141,23,801,901
CBEAM,2142,23,802,902
CBEAM,2143,23,803,903
CBEAM,2144,23,804,904
CBEAM,2145,23,805,905
CBEAM,2146,23,806,906
CBEAM,2147,23,807,907
CBEAM,2148,23,808,908
CBEAM,2149,23,809,909
CBEAM,2150,23,810,910
CBAR,3151,24,801,802
CBAR,3152,24,802,803
CBAR,3153,24,803,804
CBAR,3154,24,804,805
CBAR,3155,24,806,807
CBAR,3156,24,807,808
CBAR,3157,24,808,809
CBAR,3158,24,809,810
CBAR,3159,24,801,806
CBAR,3160,24,802,807
CBAR,3161,24,803,808
CBAR,3162,24,804,809
CBAR,3163,24,805,810
$
$ --- Bays 9-12 : Tip Section Properties (PIDs 31, 32, 33, 34) ---
$ BAY 9
CQUAD4,1161,31,901,1001,1002,902
CQUAD4,1162,31,902,1002,1003,903
CQUAD4,1163,31,903,1003,1004,904
CQUAD4,1164,31,904,1004,1005,905
CQUAD4,1165,31,906,907,1007,1006
CQUAD4,1166,31,907,908,1008,1007
CQUAD4,1167,31,908,909,1009,1008
CQUAD4,1168,31,909,910,1010,1009
CQUAD4,1169,32,901,906,1006,1001
CQUAD4,1170,32,905,1005,1010,910
CBEAM,2161,33,901,1001
CBEAM,2162,33,902,1002
CBEAM,2163,33,903,1003
CBEAM,2164,33,904,1004
CBEAM,2165,33,905,1005
CBEAM,2166,33,906,1006
CBEAM,2167,33,907,1007
CBEAM,2168,33,908,1008
CBEAM,2169,33,909,1009
CBEAM,2170,33,910,1010
CBAR,3171,34,901,902
CBAR,3172,34,902,903
CBAR,3173,34,903,904
CBAR,3174,34,904,905
CBAR,3175,34,906,907
CBAR,3176,34,907,908
CBAR,3177,34,908,909
CBAR,3178,34,909,910
CBAR,3179,34,901,906
CBAR,3180,34,902,907
CBAR,3181,34,903,908
CBAR,3182,34,904,909
CBAR,3183,34,905,910
$ BAY 10
CQUAD4,1181,31,1001,1101,1102,1002
CQUAD4,1182,31,1002,1102,1103,1003
CQUAD4,1183,31,1003,1103,1104,1004
CQUAD4,1184,31,1004,1104,1105,1005
CQUAD4,1185,31,1006,1007,1107,1106
CQUAD4,1186,31,1007,1008,1108,1107
CQUAD4,1187,31,1008,1009,1109,1108
CQUAD4,1188,31,1009,1010,1110,1109
CQUAD4,1189,32,1001,1006,1106,1101
CQUAD4,1190,32,1005,1105,1110,1010
CBEAM,2181,33,1001,1101
CBEAM,2182,33,1002,1102
CBEAM,2183,33,1003,1103
CBEAM,2184,33,1004,1104
CBEAM,2185,33,1005,1105
CBEAM,2186,33,1006,1106
CBEAM,2187,33,1007,1107
CBEAM,2188,33,1008,1108
CBEAM,2189,33,1009,1109
CBEAM,2190,33,1010,1110
CBAR,3191,34,1001,1002
CBAR,3192,34,1002,1003
CBAR,3193,34,1003,1004
CBAR,3194,34,1004,1005
CBAR,3195,34,1006,1007
CBAR,3196,34,1007,1008
CBAR,3197,34,1008,1009
CBAR,3198,34,1009,1010
CBAR,3199,34,1001,1006
CBAR,3200,34,1002,1007
CBAR,3201,34,1003,1008
CBAR,3202,34,1004,1009
CBAR,3203,34,1005,1010
$ BAY 11
CQUAD4,1201,31,1101,1201,1202,1102
CQUAD4,1202,31,1102,1202,1203,1103
CQUAD4,1203,31,1103,1203,1204,1104
CQUAD4,1204,31,1104,1204,1205,1105
CQUAD4,1205,31,1106,1107,1207,1206
CQUAD4,1206,31,1107,1108,1208,1207
CQUAD4,1207,31,1108,1109,1209,1208
CQUAD4,1208,31,1109,1110,1210,1209
CQUAD4,1209,32,1101,1106,1206,1201
CQUAD4,1210,32,1105,1205,1210,1110
CBEAM,2201,33,1101,1201
CBEAM,2202,33,1102,1202
CBEAM,2203,33,1103,1203
CBEAM,2204,33,1104,1204
CBEAM,2205,33,1105,1205
CBEAM,2206,33,1106,1206
CBEAM,2207,33,1107,1207
CBEAM,2208,33,1108,1208
CBEAM,2209,33,1109,1209
CBEAM,2210,33,1110,1210
CBAR,3211,34,1101,1102
CBAR,3212,34,1102,1103
CBAR,3213,34,1103,1104
CBAR,3214,34,1104,1105
CBAR,3215,34,1106,1107
CBAR,3216,34,1107,1108
CBAR,3217,34,1108,1109
CBAR,3218,34,1109,1110
CBAR,3219,34,1101,1106
CBAR,3220,34,1102,1107
CBAR,3221,34,1103,1108
CBAR,3222,34,1104,1109
CBAR,3223,34,1105,1110
$ BAY 12
CQUAD4,1221,31,1201,1301,1302,1202
CQUAD4,1222,31,1202,1302,1303,1203
CQUAD4,1223,31,1203,1303,1304,1204
CQUAD4,1224,31,1204,1304,1305,1205
CQUAD4,1225,31,1206,1207,1307,1306
CQUAD4,1226,31,1207,1208,1308,1307
CQUAD4,1227,31,1208,1209,1309,1308
CQUAD4,1228,31,1209,1210,1310,1309
CQUAD4,1229,32,1201,1206,1306,1301
CQUAD4,1230,32,1205,1305,1310,1210
CBEAM,2221,33,1201,1301
CBEAM,2222,33,1202,1302
CBEAM,2223,33,1203,1303
CBEAM,2224,33,1204,1304
CBEAM,2225,33,1205,1305
CBEAM,2226,33,1206,1306
CBEAM,2227,33,1207,1307
CBEAM,2228,33,1208,1308
CBEAM,2229,33,1209,1309
CBEAM,2230,33,1210,1310
CBAR,3231,34,1201,1202
CBAR,3232,34,1202,1203
CBAR,3233,34,1203,1204
CBAR,3234,34,1204,1205
CBAR,3235,34,1206,1207
CBAR,3236,34,1207,1208
CBAR,3237,34,1208,1209
CBAR,3238,34,1209,1210
CBAR,3239,34,1201,1206
CBAR,3240,34,1202,1207
CBAR,3241,34,1203,1208
CBAR,3242,34,1204,1209
CBAR,3243,34,1205,1210
$ Final Rib at Tip
CBAR,3251,34,1301,1302
CBAR,3252,34,1302,1303
CBAR,3253,34,1303,1304
CBAR,3254,34,1304,1305
CBAR,3255,34,1306,1307
CBAR,3256,34,1307,1308
CBAR,3257,34,1308,1309
CBAR,3258,34,1309,1310
CBAR,3259,34,1301,1306
CBAR,3260,34,1302,1307
CBAR,3261,34,1303,1308
CBAR,3262,34,1304,1309
CBAR,3263,34,1305,1310
$
$ --- Bushes (PID 5) for Pylon Attachment at Y=75 (Station 7) ---
CBUSH,7001,5,707,791
CBUSH,7002,5,709,792
$
$=======================================================================
$ 3. Rigid Elements (RBEs)
$=======================================================================
$ RBE2 at root to connect all 10 nodes to fixed point 99
RBE2,8001,99,123456,101,102,103,104,105,106,107,108,109,110
$ RBE3 at tip to apply loads to all 10 tip nodes
RBE3,9001,1399,123,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310
$ RBE3 at pylon to apply engine weight
RBE3,9002,799,3,791,792
$
$=======================================================================
$ 4. Loads and Constraints
$=======================================================================
$ Load set ID = 1
$ Fix the RBE2 center node in all 6 DOF
SPC1,1,123456,99
$
$ Apply loads to the RBE3 center nodes.
$ 25,000 unit lift force (+Z) at the tip
FORCE,1,1399,0,25000.0,0.0,0.0,1.0
$ 150,000 unit nose-up pitching moment (+Y) at the tip
MOMENT,1,1399,0,150000.0,0.0,1.0,0.0
$ 5,000 unit engine weight force (-Z) at the pylon
FORCE,1,799,0,-5000.0,0.0,0.0,-1.0
$
$=======================================================================
$ 5. Properties and Materials
$=======================================================================
$ Single material (Aluminum)
MAT1,1,1.0E7,0.33,
$
$ --- Properties for Root Section (Bays 1-4) ---
PSHELL,11,1,0.15,1       $ PID 11: Skin, 0.15 thickness
PSHELL,12,1,0.25,1       $ PID 12: Spar Web, 0.25 thickness
PBEAM,13,1,1.2,0.3,0.15, $ PID 13: Spar Caps & Stringers
PBAR,14,1,0.6,0.15,      $ PID 14: Ribs
$ --- Properties for Mid Section (Bays 5-8) ---
PSHELL,21,1,0.10,1
PSHELL,22,1,0.20,1
PBEAM,23,1,1.0,0.2,0.1,
PBAR,24,1,0.5,0.1,
$ --- Properties for Tip Section (Bays 9-12) ---
PSHELL,31,1,0.08,1
PSHELL,32,1,0.15,1
PBEAM,33,1,0.8,0.15,0.08,
PBAR,34,1,0.4,0.08,
$ --- Pylon Bush Property ---
PBUSH,5,K,1.E6,1.E6,1.E6,1.E5,1.E5,1.E5
$
ENDDATA
`;
    if(btnSample) {
        btnSample.addEventListener('click', () => {
            loadFromText(sampleDatFile, 'sample.dat');
        });
    }

    if(csysMethod) { csysMethod.addEventListener('change', () => { csysNodes.style.display = csysMethod.value === 'nodes' ? '' : 'none'; csysCoords.style.display = csysMethod.value === 'coords' ? '' : 'none'; }); }
    if(advancedNodeToggle) { advancedNodeToggle.addEventListener('click', () => { const isHidden = advancedNodeOptions.style.display === 'none'; advancedNodeOptions.style.display = isHidden ? '' : 'none'; advancedNodeToggle.textContent = isHidden ? 'Advanced ▲' : 'Advanced ▼'; }); }


    if (multiSelectEl) { multiSelectMode = multiSelectEl.checked; multiSelectEl.addEventListener('change', () => { multiSelectMode = multiSelectEl.checked; }); }
    if (symbolSize) symbolSize.addEventListener('input', () => { buildGeometries(true); selectNode(selectedIdx); });
    if (springSize) springSize.addEventListener('input', () => { buildGeometries(true); });

    if (selectModeEl) {
      selectModeEl.addEventListener('change', (e) => {
        selectMode = e.target.value;
        currentElemInput = null;
        selection.nodes.clear();
        selection.elems.clear();
        updateSelectionVisual();
        highlightSelectedElementVisual();
        updateSelectionUI();
        const editElemCard = document.getElementById('editElementCard');
        if (selectMode !== 'element' && editElemCard.style.display !== 'none') {
            editElemCard.style.display = 'none';
        }
      });
    }
    if (colorMode) colorMode.addEventListener('change', () => { buildGeometries(true); });
    if (btnClearSelection) btnClearSelection.addEventListener('click', () => { selection.nodes.clear(); selection.elems.clear(); currentElemInput = null; updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); });

    function startPolygonSelection(ev) {
        isPolygonSelecting = true;
        controls.enabled = false;
        polygonPoints = [];
        polygonOverlay.style.display = 'block';
        addPolygonPoint(ev);
        statusMsg('Polygon Select: Click to add points, Dbl-Click to finish, Right-Click to cancel.');
    }
    
    function addPolygonPoint(ev) {
        const rect = viewportEl.getBoundingClientRect();
        polygonPoints.push({ x: ev.clientX - rect.left, y: ev.clientY - rect.top });
        updatePolygonVisual();
    }

    function updatePolygonVisual() {
        const pointsStr = polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
        polygonLine.setAttribute('points', pointsStr);
    }

    function cancelPolygonSelection() {
        isPolygonSelecting = false;
        controls.enabled = true;
        polygonPoints = [];
        polygonOverlay.style.display = 'none';
        polygonLine.setAttribute('points', '');
        statusMsg('Polygon selection cancelled.');
    }

    function finalizePolygonSelection() {
        if (polygonPoints.length < 3) {
            cancelPolygonSelection();
            return;
        }

        const rectCanvas = canvas.getBoundingClientRect();
        const selectedInPolygon = new Set();
        
        const isPointInPolygon = (point, vs) => {
            const x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].x, yi = vs[i].y;
                const xj = vs[j].x, yj = vs[j].y;
                const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        };
        
        const projectToScreen = (vec3) => {
            const p = vec3.clone().project(camera);
            return { x: (p.x * 0.5 + 0.5) * rectCanvas.width, y: (-p.y * 0.5 + 0.5) * rectCanvas.height };
        };

        if (selectMode === 'node') {
            for (let i = 0; i < model.indexToNid.length; i++) {
                const screenPos = projectToScreen(nodePosition(i));
                if (isPointInPolygon(screenPos, polygonPoints)) {
                    selectedInPolygon.add(model.indexToNid[i]);
                }
            }
            if (!multiSelectMode) selection.nodes.clear();
            selection.elems.clear();
            for (const nid of selectedInPolygon) selection.nodes.add(nid);

        } else if (selectMode === 'element') {
            const allElems = Object.values(model.elems).flat();
            for (const elem of allElems) {
                 if (hidden.elems && hidden.elems.has(elem.eid)) continue;
                 const nodes = elem.n || [elem.gn, ...(elem.deps || elem.inds)];
                 const centroid = centroidOf(nodes);
                 const screenPos = projectToScreen(centroid);
                 if (isPointInPolygon(screenPos, polygonPoints)) {
                    selectedInPolygon.add(elem.eid);
                 }
            }
            if (!multiSelectMode) { selection.elems.clear(); selection.nodes.clear(); }
            for (const eid of selectedInPolygon) selection.elems.add(eid);
        }
        
        updateSelectionVisual();
        highlightSelectedElementVisual();
        updateSelectionUI();
        statusMsg(`Selected ${selectedInPolygon.size} items with polygon.`);
        cancelPolygonSelection();
    }

    if (canvas && selectRect) {
      canvas.addEventListener('mousedown', (ev) => { 
        if (ev.ctrlKey && ev.shiftKey && ev.button === 0) {
            startPolygonSelection(ev);
            ev.preventDefault();
            return;
        }
        if (!ev.altKey) return; 
        const rect = viewportEl.getBoundingClientRect(); dragStart = { x: ev.clientX - rect.left, y: ev.clientY - rect.top }; boxSelecting = true; if (controls) controls.enabled = false; selectRect.style.display = 'block'; selectRect.style.left = dragStart.x + 'px'; selectRect.style.top = dragStart.y + 'px'; selectRect.style.width = '0px'; selectRect.style.height = '0px'; ev.preventDefault(); 
      });

      window.addEventListener('mousemove', (ev) => { 
        if(isPolygonSelecting) {
            const rect = viewportEl.getBoundingClientRect();
            const currentPoint = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
            const pointsStr = [...polygonPoints, currentPoint].map(p => `${p.x},${p.y}`).join(' ');
            polygonLine.setAttribute('points', pointsStr);
            return;
        }
        if (!dragStart) return; const rect = viewportEl.getBoundingClientRect(); const currentX = ev.clientX - rect.left, currentY = ev.clientY - rect.top; const x = Math.min(dragStart.x, currentX), y = Math.min(dragStart.y, currentY), w = Math.abs(currentX - dragStart.x), h = Math.abs(currentY - dragStart.y); selectRect.style.left = x + 'px'; selectRect.style.top = y + 'px'; selectRect.style.width = w + 'px'; selectRect.style.height = h + 'px'; 
      });
      
      window.addEventListener('mouseup', (ev) => {
        if (!dragStart) return;
        const rect = viewportEl.getBoundingClientRect(), endX = ev.clientX - rect.left, endY = ev.clientY - rect.top;
        const x1 = Math.min(dragStart.x, endX), x2 = Math.max(dragStart.x, endX), y1 = Math.min(dragStart.y, endY), y2 = Math.max(dragStart.y, endY);
        const rectCanvas = canvas.getBoundingClientRect();
        if (selectMode === 'node') {
          if (points) {
            const selectedInBox = [];
            for (let i = 0; i < model.indexToNid.length; i++) {
              const p = nodePosition(i).clone().project(camera);
              const sx = (p.x + 1) * 0.5 * rectCanvas.width, sy = (1 - p.y) * 0.5 * rectCanvas.height;
              if (sx >= x1 && sx <= x2 && sy >= y1 && sy <= y2) { selectedInBox.push(model.indexToNid[i]); }
            }
            if (!multiSelectMode) selection.nodes.clear();
            selection.elems.clear();
            for (const nid of selectedInBox) selection.nodes.add(nid);
            updateSelectionVisual(); updateSelectionUI();
          }
        } else if (selectMode === 'element') {
          const selectedElems = new Set();
          const projectToScreen = (vec3) => { const p = vec3.clone().project(camera); return { sx: (p.x + 1) * 0.5 * rectCanvas.width, sy: (1 - p.y) * 0.5 * rectCanvas.height }; };
          const checkElem = (e) => { if (hidden.elems && hidden.elems.has(e.eid)) return; const nodes = e.n || [e.gn, ...(e.deps || e.inds)]; const centroid = centroidOf(nodes); const { sx, sy } = projectToScreen(centroid); if (sx >= x1 && sx <= x2 && sy >= y1 && sy <= y2) { selectedElems.add(e.eid); } };
          Object.values(model.elems).flat().forEach(checkElem);
          if (!multiSelectMode) { selection.elems.clear(); selection.nodes.clear(); }
          for (const eid of selectedElems) {
            if (multiSelectMode && selection.elems.has(eid)) { selection.elems.delete(eid); } else { selection.elems.add(eid); }
          }
          updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI();
        }
        if (controls) controls.enabled = true;
        dragStart = null; boxSelecting = false;
        selectRect.style.display = 'none';
      });

      canvas.addEventListener('contextmenu', (e) => {
        if(isPolygonSelecting) {
            e.preventDefault();
            cancelPolygonSelection();
        }
      });
    }

    if(selNid) {
        selNid.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // If the input is empty, do nothing.
                if (selNid.value.trim() === '') return;

                const id = parseInt(selNid.value);
                if(isNaN(id)) { 
                    statusMsg('Please enter a valid numeric ID.', true); 
                    return; 
                }

                selection.nodes.clear();
                selection.elems.clear();
                let found = false;
                
                if (selectMode === 'node') {
                    if(model.nodes.has(id)) {
                        selection.nodes.add(id);
                        const idx = model.nodeIndex.get(id);
                        if (idx !== undefined) {
                            showTemporaryLabel(nodePosition(idx), id);
                        }
                        found = true;
                    }
                } else if (selectMode === 'element') {
                    const allElems = Object.values(model.elems).flat();
                    const elem = allElems.find(e => e.eid === id);
                    if (elem) {
                        selection.elems.add(id);
                        const nodesToSelect = elem.n || [elem.gn, ...(elem.deps || elem.inds)];
                        nodesToSelect.forEach(nid => selection.nodes.add(nid));
                        showTemporaryLabel(centroidOf(nodesToSelect), id);
                        found = true;
                    }
                }
                
                if (found) {
                    updateSelectionVisual();
                    highlightSelectedElementVisual();
                    updateSelectionUI();
                    statusMsg(`Found ${selectMode} ${id}.`);
                } else {
                    statusMsg(`Could not find ${selectMode} with ID ${id}.`, true);
                    updateSelectionVisual();
                    highlightSelectedElementVisual();
                    updateSelectionUI(); 
                }
            }
        });
    }

    fileInput.addEventListener('change', async (e)=>{ const f=e.target.files[0]; if (!f) return; const text=await f.text(); loadFromText(text, f.name); });
    btnClear.addEventListener('click', ()=>{ historyManager.recordAction(() => { resetModel(); clearScene(); refreshCounts(); statusMsg('Cleared model.'); }); });
    btnReset.addEventListener('click', fitView);
    btnExport.addEventListener('click', exportBDF);

    if (btnCopySelectedNode) {
        btnCopySelectedNode.addEventListener('click', () => {
            if (selectMode === 'node' && selection.nodes.size === 1) {
                const nid = Array.from(selection.nodes)[0];
                const node = model.nodes.get(nid);
                if (node) {
                    document.getElementById('newX').value = node.x;
                    document.getElementById('newY').value = node.y;
                    document.getElementById('newZ').value = node.z;
                    document.getElementById('newCP').value = node.cp || 0;
                    statusMsg(`Copied coords from node ${nid}.`);
                }
            }
        });
    }

    btnApplyChanges.addEventListener('click', ()=>{ 
        if (selection.nodes.size === 0) return;
        
        const newCP_val = selCP.value !== '' ? parseInt(selCP.value) : null;

        if (newCP_val !== null) {
            const csys = model.coords.get(newCP_val);
            if (csys && csys.nodes) {
                for (const nid of selection.nodes) {
                    if (csys.nodes.includes(nid)) {
                        statusMsg(`Error: Node ${nid} defines CSYS ${newCP_val} and cannot be defined in it.`, true);
                        return; 
                    }
                }
            }
        }
        
        historyManager.recordAction(() => {
            const newCD_val = selCD.value !== '' ? parseInt(selCD.value) : null;
            const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

            for(const nid of selection.nodes) {
                const node = model.nodes.get(nid);
                if(!node) continue;
                
                const originalCP = node.cp || 0;
                const newCP = newCP_val !== null ? newCP_val : originalCP;

                if (newCP !== originalCP) {
                    const globalPos = globalPositions.get(nid);
                    const newTransform = globalCoordTransforms.get(newCP);

                    if (!newTransform) {
                         statusMsg(`Error: CP ${newCP} has no transform (unresolved). Node ${nid} not changed.`, true);
                         continue; 
                    }

                    if (globalPos) {
                        const invNewTransform = newTransform.clone().invert();
                        const newLocalPos = globalPos.clone().applyMatrix4(invNewTransform);
                        
                        node.x = newLocalPos.x;
                        node.y = newLocalPos.y;
                        node.z = newLocalPos.z;
                        node.cp = newCP;
                    }
                } else if(selection.nodes.size === 1) {
                    node.x = Number(selX.value);
                    node.y = Number(selY.value);
                    node.z = Number(selZ.value);
                }

                if (newCD_val !== null && !isNaN(newCD_val)) node.cd = newCD_val;
            }
            buildGeometries(true);
            statusMsg(`Updated ${selection.nodes.size} node(s).`); 
        });
    });

    btnCancelChanges.addEventListener('click', updateSelectionUI);

    btnApplyElemEdit.addEventListener('click', () => {
        const eid = parseInt(document.getElementById('editEid').value); if (isNaN(eid)) return;
        historyManager.recordAction(() => {
            let elem; for (const type in model.elems) { const found = model.elems[type].find(e => e.eid === eid); if (found) { elem = found; break; } }
            if (!elem) { statusMsg(`Element ${eid} not found.`, true); return; }
            const newPid = parseInt(document.getElementById('editPid').value); if (!isNaN(newPid)) elem.pid = newPid;
            const nodeFields = [document.getElementById('editN1'), document.getElementById('editN2'), document.getElementById('editN3'), document.getElementById('editN4')];
            const newNodes = []; let allNodesValid = true;
            if(elem.n) {
              for (let i = 0; i < elem.n.length; i++) { const nVal = parseInt(nodeFields[i].value); if (isNaN(nVal) || !model.nodes.has(nVal)) { allNodesValid = false; break; } newNodes.push(nVal); }
              if (allNodesValid) { elem.n = newNodes; } 
              else { statusMsg(`Invalid node ID entered for element ${eid}. Aborting edit.`, true); return; }
            }
            if (elem.type === 'CQUAD4') {
                const getVal = (id, isInt = false) => {
                    const val = isInt ? parseInt(document.getElementById(id).value) : parseFloat(document.getElementById(id).value);
                    return isNaN(val) ? undefined : val;
                };
                elem.thetaMcid = getVal('editThetaMcid');
                elem.zoffs = getVal('editZoffs');
                elem.tflag = getVal('editTflag', true);
                const t = [getVal('editT1'), getVal('editT2'), getVal('editT3'), getVal('editT4')];
                elem.T = t.some(v => v !== undefined) ? t : undefined;
            }
            statusMsg(`Updated element ${eid}.`); buildGeometries(true); 
        });
        document.getElementById('editElementCard').style.display = 'none'; selection.elems.clear(); updateSelectionUI(); highlightSelectedElementVisual();
    });

    btnCancelElemEdit.addEventListener('click', () => { document.getElementById('editElementCard').style.display = 'none'; selection.elems.clear(); updateSelectionUI(); highlightSelectedElementVisual(); });

    function getTargetNodes() {
        const manualIds = loadNodeId.value.split(/[\s,]+/).map(s => parseInt(s.trim())).filter(v => !isNaN(v) && model.nodes.has(v));
        if (manualIds.length > 0) return manualIds;
        if (selection.nodes.size > 0) return Array.from(selection.nodes);
        return [];
    }

    btnAddForce.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), mag = Number(fMag.value||0), dir = [Number(fX.value||0),Number(fY.value||0),Number(fZ.value||0)]; let count = 0;
            for (const nid of targetNids) { model.loads.force.push({ type: 'FORCE', sid, nid, cid:0, mag, dir }); count++; }
            buildGeometries(true); refreshCounts(); statusMsg(`Added FORCE on ${count} node(s).`); loadNodeId.value = '';
        });
    });
    btnAddMoment.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), mag = Number(mMag.value||0), dir = [Number(mX.value||0),Number(mY.value||0),Number(mZ.value||0)]; let count = 0;
            for (const nid of targetNids) { model.loads.moment.push({ type: 'MOMENT', sid, nid, cid:0, mag, dir }); count++; }
            buildGeometries(true); refreshCounts(); statusMsg(`Added MOMENT on ${count} node(s).`); loadNodeId.value = '';
        });
    });
    btnAddSPC.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), components = (spcComp.value||'123'); 
            let grp = model.spc1.find(s=>s.sid===sid && s.components===components); if (!grp){ grp={sid, components, nodes:[]}; model.spc1.push(grp);} let count = 0;
            for (const nid of targetNids) { if (!grp.nodes.includes(nid)) { grp.nodes.push(nid); count++; } }
            buildGeometries(true); refreshCounts(); statusMsg(`Added SPC1 ${components} on ${count} node(s).`); loadNodeId.value = '';
        });
    });

    btnAddCsys.addEventListener('click', () => {
        const cid = parseInt(csysId.value), rid = parseInt(csysRid.value);
        if (isNaN(cid) || isNaN(rid)) { statusMsg('CSYS ID and Ref CID must be valid integers.', true); return; }
        if (model.coords.has(cid)) { statusMsg(`Coordinate system ${cid} already exists.`, true); return; }
        historyManager.recordAction(() => {
            if (csysMethod.value === 'nodes') {
                const n1 = parseInt(csysN1.value), n2 = parseInt(csysN2.value), n3 = parseInt(csysN3.value);
                if ([n1, n2, n3].some(isNaN)) { statusMsg('All node fields must be valid IDs.', true); return; }
                if (!model.nodes.has(n1) || !model.nodes.has(n2) || !model.nodes.has(n3)) { statusMsg('One or more defining nodes do not exist.', true); return; }
                model.coords.set(cid, { type: 'CORD2R', rid, nodes: [n1, n2, n3] });
            } else {
                const origin = [Number(document.getElementById('csysA1').value), Number(document.getElementById('csysA2').value), Number(document.getElementById('csysA3').value)];
                const zAxisPt = [Number(document.getElementById('csysB1').value), Number(document.getElementById('csysB2').value), Number(document.getElementById('csysB3').value)];
                const xzPlanePt = [Number(document.getElementById('csysC1').value), Number(document.getElementById('csysC2').value), Number(document.getElementById('csysC3').value)];
                if ([...origin, ...zAxisPt, ...xzPlanePt].some(isNaN)) { statusMsg('All coordinate fields must be valid numbers.', true); return; }
                model.coords.set(cid, { type: 'CORD2R', rid, origin, zAxisPt, xzPlanePt });
            }
            buildGeometries(true);
            statusMsg(`Added CORD2R ${cid}.`);
        });
    });
    
    // Label Toggles
    for (const el of [showNodeIds, showElemIds, showSPCLabels, showLoadLabels, loadLabelMode]) {
      if(el) el.addEventListener('change', rebuildLabels);
    }

    // Visibility Toggles
    document.querySelectorAll('[data-vis]').forEach(toggle => {
      toggle.addEventListener('change', () => {
        const visType = toggle.getAttribute('data-vis');
        if (visType === 'nodes' && points) {
          points.visible = toggle.checked;
        } else if (visType === 'edges' && meshLines) {
          meshLines.visible = toggle.checked;
        } else if (visType === 'forces') {
          forceGroup.visible = toggle.checked;
        } else if (visType === 'moments') {
          momentGroup.visible = toggle.checked;
        } else if (visType === 'spcs') {
          spcGroup.visible = toggle.checked;
        } else if (visType === 'coords') {
          coordSysGroup.visible = toggle.checked;
        } else if (meshShell) {
          // Handle element type visibility
          buildGeometries(true);
        }
      });
    });

    contextMenu.addEventListener('contextmenu', (ev) => {
      ev.preventDefault();
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      let entity = null, eType = null;
      const loadHits = raycaster.intersectObjects([forceGroup, momentGroup, ploadGroup], true);
      if (loadHits.length) { let parent = loadHits[0].object; while(parent && !parent.userData.type) parent = parent.parent; if(parent) { entity = parent; eType = parent.userData.type; } }
      if (!entity) { const spcHits = raycaster.intersectObjects(spcGroup.children, true); if (spcHits.length) { entity = spcHits[0].object; eType = 'spc'; } }
      if (!entity) {
        raycaster.params.Line.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.01 : 0.1);
        const hits = raycaster.intersectObjects([meshShell, meshLines, bushGroup].filter(Boolean), true);
        if (hits.length > 0) {
            eType = 'elem'; const hit = hits[0];
            if (hit.object.type === 'Sprite') { entity = hit.object.userData; } else if (hit.object === meshShell) { entity = faceToElem[hit.faceIndex]; } else if (hit.object === meshLines) { entity = lineToElem[hit.faceIndex]; }
        }
      }
      if (!entity && points) {
        raycaster.params.Points.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.005 : 0.1);
        const nhits = raycaster.intersectObject(points); if (nhits.length) { const i = nhits[0].index; entity = { i: i, nid: model.indexToNid[i] }; eType = 'node'; }
      }
      if (!entity) { contextMenu.style.display = 'none'; return; }
      contextMenu.innerHTML = '';
      const makeItem = (label, fn) => { const div = document.createElement('div'); div.textContent = label; div.addEventListener('click', () => { fn(); contextMenu.style.display = 'none'; }); return div; };
      if (eType === 'elem') {
          const targetEids = (selection.elems.size > 1 && selection.elems.has(entity.eid)) ? [...selection.elems] : [entity.eid];
          const plural = targetEids.length > 1 ? 's' : '';
          contextMenu.appendChild(makeItem(`Hide ${targetEids.length > 1 ? targetEids.length + ' ' : ''}Element${plural}`, () => { historyManager.recordAction(() => { targetEids.forEach(eid => hidden.elems.add(eid)); if (targetEids.length > 1) selection.elems.clear(); buildGeometries(true); updateSelectionUI(); highlightSelectedElementVisual(); }); }));
          contextMenu.appendChild(makeItem(`Delete ${targetEids.length > 1 ? targetEids.length + ' ' : ''}Element${plural}`, () => { historyManager.recordAction(() => { for (const eid of targetEids) { for (const type in model.elems) { const idx = model.elems[type].findIndex(e => e.eid === eid); if (idx > -1) { model.elems[type].splice(idx, 1); break; } } hidden.elems.delete(eid); } if (targetEids.length > 1) selection.elems.clear(); buildGeometries(true); refreshCounts(); rebuildLabels(); updateSelectionUI(); highlightSelectedElementVisual(); }); }));
          contextMenu.appendChild(makeItem('Edit', () => { selection.elems = new Set([entity.eid]); selection.nodes = new Set(entity.nodes); selectModeEl.value = 'element'; selectMode = 'element'; updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); }));
      } else {
         contextMenu.appendChild(makeItem('Hide', () => { historyManager.recordAction(() => { if (eType === 'load') { if (entity?.userData?.data) hidden.loads.add(entity.userData.data); buildGeometries(true); } else if (eType === 'spc') { if (entity?.userData?.key) hidden.spc.add(entity.userData.key); buildGeometries(true); } else if (eType === 'node') { hidden.nodes.add(entity.nid); statusMsg('Node hiding not supported.', true); } rebuildLabels(); }); }));
      }
      contextMenu.appendChild(makeItem('Show All', () => { hidden.elems.clear(); hidden.loads.clear(); hidden.spc.clear(); hidden.nodes.clear(); buildGeometries(true); rebuildLabels(); }));
      contextMenu.style.left = (ev.clientX + 2) + 'px'; contextMenu.style.top = (ev.clientY + 2) + 'px'; contextMenu.style.display = 'block';
    });
    document.addEventListener('click', (e) => { if (contextMenu && !contextMenu.contains(e.target)) { contextMenu.style.display = 'none'; } });

    if (btnAddNode) {
      btnAddNode.addEventListener('click', () => {
        historyManager.recordAction(() => {
            let val = newNid.value.trim(), nid = parseInt(val);
            if (isNaN(nid) || model.nodes.has(nid)) { nid = (model.nodes.size > 0 ? Math.max(...model.nodes.keys()) : 0) + 1; }
            const x = Number(newX.value||0), y=Number(newY.value||0), z=Number(newZ.value||0);
            const cp = Number(newCP.value || 0);
            const cd = Number(newCD.value || 0);
            const ps = newPS.value || '';
            const hadNodes = model.nodes.size > 0;
            model.nodes.set(nid, { x, y, z, cp, cd, ps });
            const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
            model.indexToNid = nidsArr;
            model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
            hidden.nodes.delete(nid);
            buildGeometries(hadNodes); if (!hadNodes) fitView();
            refreshCounts(); statusMsg('Added node ' + nid); newNid.value = '';
        });
      });
    }

    if (elemType) {
        const updateElemUI = () => {
            const type = elemType.value, card = document.getElementById('addElementCard'); if (!card) return;
            const showRow = (sel, cond) => { const el = card.querySelector(sel); if(el) el.closest('.row').style.display = cond ? '' : 'none'; };
            const n1Label = document.getElementById('elemN1Label');
            showRow('#elemN2', /cbar|cbeam|cbush|ctria3|cquad4/.test(type)); showRow('#elemN3', /ctria3|cquad4/.test(type)); showRow('#elemN4', type === 'cquad4'); showRow('#elemCmRow', /rbe2|rbe3/.test(type)); showRow('#elemDepNodesRow', type === 'rbe2'); showRow('#elemIndNodesRow', type === 'rbe3'); showRow('#elemPid', !/rbe2|rbe3/.test(type));
            if (type === 'rbe2') { n1Label.textContent = 'Indep Node'; } else if (type === 'rbe3') { n1Label.textContent = 'Dep Node'; } else { n1Label.textContent = 'Node 1'; }
            const cquad4ToggleRow = document.getElementById('cquad4AdvancedToggleRow');
            const cquad4Options = document.getElementById('cquad4AdvancedOptions');
            cquad4ToggleRow.style.display = (type === 'cquad4') ? '' : 'none';
            if(type !== 'cquad4' && cquad4Options.style.display !== 'none') {
              cquad4Options.style.display = 'none';
              document.getElementById('cquad4AdvancedToggle').textContent = 'Advanced ▼';
            }
        };
        elemType.addEventListener('change', updateElemUI);
        const cquad4Toggle = document.getElementById('cquad4AdvancedToggle');
        const cquad4Options = document.getElementById('cquad4AdvancedOptions');
        if (cquad4Toggle && cquad4Options) {
          cquad4Toggle.addEventListener('click', () => {
              const isHidden = cquad4Options.style.display === 'none';
              cquad4Options.style.display = isHidden ? '' : 'none';
              cquad4Toggle.textContent = isHidden ? 'Advanced ▲' : 'Advanced ▼';
          });
        }
        updateElemUI();
    }

    if (btnAddElement) {
        btnAddElement.addEventListener('click', () => {
            historyManager.recordAction(() => {
                let eid = parseInt(elemEid.value);
                if (isNaN(eid)) {
                    const allEids = Object.values(model.elems).flat().map(e => e.eid);
                    eid = allEids.length > 0 ? Math.max(...allEids) + 1 : 1;
                }
                const type = elemType.value, pid=Number(elemPid.value||1), n1=parseInt(elemN1.value), n2=parseInt(elemN2.value), n3=parseInt(elemN3.value), n4=parseInt(elemN4.value), cm = elemCm.value||'123456';
                const getRbeNodes = (inputEl) => { const csv = inputEl.value.split(/[\s,]+/).map(s => parseInt(s)).filter(v => !isNaN(v) && model.nodes.has(v)); return csv.length > 0 ? csv : Array.from(selection.nodes).filter(nid => nid !== n1); };
                const deps = type === 'rbe2' ? getRbeNodes(elemDepNodes) : [], inds = type === 'rbe3' ? getRbeNodes(elemIndNodes) : [];
                let newElem, msg = '';
                try {
                    switch (type) {
                        case 'cquad4': {
                          if ([n1, n2, n3, n4].some(isNaN)) throw new Error('CQUAD4 requires 4 valid node IDs.');
                          newElem = { eid, pid, n: [n1, n2, n3, n4], type: 'CQUAD4' };
                          const getVal = (id, isInt=false) => {
                              const val = isInt ? parseInt(document.getElementById(id).value) : parseFloat(document.getElementById(id).value);
                              return isNaN(val) ? undefined : val;
                          };
                          newElem.thetaMcid = getVal('elemThetaMcid');
                          newElem.zoffs = getVal('elemZoffs');
                          newElem.tflag = getVal('elemTflag', true);
                          const t = [getVal('elemT1'), getVal('elemT2'), getVal('elemT3'), getVal('elemT4')];
                          if (t.some(v => v !== undefined)) newElem.T = t;
                          model.elems.quad.push(newElem);
                          msg = `Added CQUAD4 ${eid}`;
                          break;
                        }
                        case 'ctria3': if ([n1,n2,n3].some(isNaN)) throw new Error('CTRIA3 requires 3 valid node IDs.'); newElem = { eid, pid, n: [n1, n2, n3], type: 'CTRIA3' }; model.elems.tri.push(newElem); msg = `Added CTRIA3 ${eid}`; break;
                        case 'cbar': case 'cbeam': case 'cbush': if ([n1,n2].some(isNaN)) throw new Error(`${type.toUpperCase()} requires 2 valid node IDs.`); newElem = { eid, pid, n: [n1, n2], type: type.toUpperCase() }; model.elems[type.replace('c','')].push(newElem); msg = `Added ${type.toUpperCase()} ${eid}`; break;
                        case 'rbe2': if (isNaN(n1) || deps.length === 0) throw new Error('RBE2 requires a GN and dependent nodes.'); newElem = { eid, gn: n1, cm, deps, type: 'RBE2' }; model.elems.rbe2.push(newElem); msg = `Added RBE2 ${eid}`; break;
                        case 'rbe3': if (isNaN(n1) || inds.length === 0) throw new Error('RBE3 requires a GN and independent nodes.'); newElem = { eid, gn: n1, cm, inds, type: 'RBE3' }; model.elems.rbe3.push(newElem); msg = `Added RBE3 ${eid}`; break;
                    }
                    statusMsg(msg); buildGeometries(true); recomputeBBox(); refreshCounts();
                    // FIX: Clear node inputs and set focus for next element
                    elemN1.value = '';
                    elemN2.value = '';
                    elemN3.value = '';
                    elemN4.value = '';
                    elemDepNodes.value = '';
                    elemIndNodes.value = '';
                    elemN1.focus();
                } catch (e) { statusMsg(e.message, true); }
            });
        });
    }

    // START: Transform Tools Functions
    function getHighestIds() {
        let maxNid = 0;
        for (const nid of model.nodes.keys()) { if (nid > maxNid) maxNid = nid; }
        let maxEid = 0;
        for (const key in model.elems) {
            for (const elem of model.elems[key]) { if (elem.eid > maxEid) maxEid = elem.eid; }
        }
        return { maxNid, maxEid };
    }
    
    function getExpandedSelection() {
        const selNodes = new Set(selection.nodes);
        const selElems = new Set(); // set of elem objects
        const allElems = Object.values(model.elems).flat();

        // First, get all explicitly selected elements
        selection.elems.forEach(eid => {
            const elem = allElems.find(e => e.eid === eid);
            if (elem) selElems.add(elem);
        });

        // Add nodes from explicitly selected elements
        selElems.forEach(elem => {
            const nodesToInclude = elem.n || [elem.gn, ...(elem.deps || elem.inds)];
            nodesToInclude.forEach(nid => selNodes.add(nid));
        });

        // Second, find elements defined ONLY by currently selected nodes
        allElems.forEach(elem => {
            if (selElems.has(elem)) return; // Already included
            const nodes = elem.n || (elem.type === 'RBE2' ? [elem.gn, ...elem.deps] : (elem.type === 'RBE3' ? [elem.gn, ...elem.inds] : null));
            if (nodes && nodes.length > 0 && nodes.every(nid => selNodes.has(nid))) {
                selElems.add(elem);
            }
        });
        return { selNodes, selElems };
    }

    function getLinearTransform() {
        let dx, dy, dz;
        const method = document.getElementById('copyMethod').value;
        if (method === 'offset') {
            dx = Number(document.getElementById('meshDeltaX').value) || 0;
            dy = Number(document.getElementById('meshDeltaY').value) || 0;
            dz = Number(document.getElementById('meshDeltaZ').value) || 0;
        } else {
            const n1_id = parseInt(document.getElementById('meshVecN1').value);
            const n2_id = parseInt(document.getElementById('meshVecN2').value);
            if (isNaN(n1_id) || isNaN(n2_id)) { throw new Error("Please select two nodes to define the vector."); }
            const node1 = model.nodes.get(n1_id); const node2 = model.nodes.get(n2_id);
            if (!node1 || !node2) { throw new Error("One or both nodes for the vector do not exist."); }
            
            if (node1.cp !== node2.cp) { console.warn("Vector nodes are in different coordinate systems. Using local coords, which may be inaccurate.");}
            dx = node2.x - node1.x; dy = node2.y - node1.y; dz = node2.z - node1.z;
        }
        if (dx === 0 && dy === 0 && dz === 0) { throw new Error("No translation offset defined."); }
        return { dx, dy, dz };
    }

    function getRadialTransform() {
        const method = document.getElementById('radialAxisMethod').value;
        let center, axis;

        if (method === 'vector') {
            const cx = Number(document.getElementById('meshRadCenterX').value);
            const cy = Number(document.getElementById('meshRadCenterY').value);
            const cz = Number(document.getElementById('meshRadCenterZ').value);
            const ax = Number(document.getElementById('meshRadAxisX').value);
            const ay = Number(document.getElementById('meshRadAxisY').value);
            const az = Number(document.getElementById('meshRadAxisZ').value);
            if ([cx,cy,cz,ax,ay,az].some(isNaN)) { throw new Error("Invalid number in radial vector/center input."); }
            // FIX: Directly use UI values in Three.js coordinate space (Y-up)
            center = new THREE.Vector3(cx, cy, cz);
            axis = new THREE.Vector3(ax, ay, az).normalize();
        } else {
            const n1_id = parseInt(document.getElementById('meshRadN1').value);
            const n2_id = parseInt(document.getElementById('meshRadN2').value);
            if (isNaN(n1_id) || isNaN(n2_id)) { throw new Error("Please select two nodes to define the rotation axis."); }
            
            const { globalPositions } = resolveAllTransforms();
            const p1_global = globalPositions.get(n1_id); const p2_global = globalPositions.get(n2_id);
            if (!p1_global || !p2_global) { throw new Error("Could not resolve global positions for axis nodes."); }
            
            center = p1_global.clone();
            axis = new THREE.Vector3().subVectors(p2_global, p1_global).normalize();
        }

        const angle = Number(document.getElementById('meshRadAngle').value) * Math.PI / 180;
        if (isNaN(angle)) throw new Error("Invalid angle.");
        
        return { center, axis, angle };
    }
    
    function transformSelection(isMove, isRadial) {
        historyManager.recordAction(() => {
            try {
                const { selNodes } = getExpandedSelection();
                if (selNodes.size === 0) { throw new Error("No nodes selected to transform."); }

                const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

                if (isRadial) {
                    const { center, axis, angle } = getRadialTransform();
                    const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
                    for (const nid of selNodes) {
                        const node = model.nodes.get(nid);
                        if (!node) continue;
                        
                        const globalPos = globalPositions.get(nid);
                        if (!globalPos) continue;

                        const transformedGlobalPos = globalPos.clone().sub(center).applyMatrix4(rotationMatrix).add(center);
                        const coordTransform = globalCoordTransforms.get(node.cp || 0);
                        const invCoordTransform = coordTransform.clone().invert();
                        const newLocalPos = transformedGlobalPos.applyMatrix4(invCoordTransform);
                        
                        node.x = newLocalPos.x; node.y = newLocalPos.y; node.z = newLocalPos.z;
                    }
                } else { // Linear
                    const { dx, dy, dz } = getLinearTransform();
                    const deltaVec = nastranToThree(dx, dy, dz);

                     for (const nid of selNodes) {
                        const node = model.nodes.get(nid);
                        if (!node) continue;
                        
                        const globalPos = globalPositions.get(nid);
                        if (!globalPos) continue;

                        const transformedGlobalPos = globalPos.clone().add(deltaVec);
                        const coordTransform = globalCoordTransforms.get(node.cp || 0);
                        const invCoordTransform = coordTransform.clone().invert();
                        const newLocalPos = transformedGlobalPos.applyMatrix4(invCoordTransform);
                        
                        node.x = newLocalPos.x; node.y = newLocalPos.y; node.z = newLocalPos.z;
                    }
                }
                buildGeometries(true);
                statusMsg(`Moved ${selNodes.size} nodes.`);
            } catch(e) {
                statusMsg(e.message, true);
            }
        });
    }

    function copySelection(isRadial) {
        historyManager.recordAction(() => {
            try {
                const copies = isRadial 
                    ? parseInt(document.getElementById('meshRadCopies').value) 
                    : parseInt(document.getElementById('meshLinearCopies').value);
                if (isNaN(copies) || copies < 1) { throw new Error("Repeat/copy count must be a positive integer."); }
                
                const { selNodes, selElems } = getExpandedSelection();

                if (selNodes.size === 0) { throw new Error("No nodes or elements selected to copy."); }
                
                const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

                let totalNodesCopied = 0;
                let totalElemsCopied = 0;
                const newSelection = { nodes: new Set(), elems: new Set() };

                for(let i=1; i<=copies; i++){
                    let { maxNid, maxEid } = getHighestIds();
                    const nodeMap = new Map();

                    for (const oldNid of selNodes) {
                        const oldNode = model.nodes.get(oldNid);
                        if (!oldNode) continue;

                        const globalPos = globalPositions.get(oldNid);
                        if (!globalPos) continue;
                        
                        let newGlobalPos;
                        if (isRadial) {
                            const { center, axis, angle } = getRadialTransform();
                            const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axis, angle * i);
                            newGlobalPos = globalPos.clone().sub(center).applyMatrix4(rotationMatrix).add(center);
                        } else {
                            const { dx, dy, dz } = getLinearTransform();
                            const deltaVec = nastranToThree(dx, dy, dz).multiplyScalar(i);
                            newGlobalPos = globalPos.clone().add(deltaVec);
                        }

                        const newNid = ++maxNid;
                        nodeMap.set(oldNid, newNid);
                        
                        const coordTransform = globalCoordTransforms.get(oldNode.cp || 0);
                        const invCoordTransform = coordTransform.clone().invert();
                        const newLocalPos = newGlobalPos.applyMatrix4(invCoordTransform);
                        
                        const newNode = { ...oldNode, x: newLocalPos.x, y: newLocalPos.y, z: newLocalPos.z };
                        model.nodes.set(newNid, newNode);
                        newSelection.nodes.add(newNid);
                    }
                    totalNodesCopied += nodeMap.size;
                    
                    for (const oldElem of selElems) {
                        const newEid = ++maxEid;
                        const newElem = { ...oldElem, eid: newEid };
                        let allNodesMapped = true;

                        if (newElem.n) { 
                            newElem.n = newElem.n.map(nid => { const mapped = nodeMap.get(nid); if (!mapped) allNodesMapped = false; return mapped; }); 
                        }
                        if (newElem.gn) { const mapped = nodeMap.get(newElem.gn); if (!mapped) allNodesMapped = false; newElem.gn = mapped; }
                        if (newElem.deps) { newElem.deps = newElem.deps.map(nid => { const mapped = nodeMap.get(nid); if (!mapped) allNodesMapped = false; return mapped; }); }
                        if (newElem.inds) { newElem.inds = newElem.inds.map(nid => { const mapped = nodeMap.get(nid); if (!mapped) allNodesMapped = false; return mapped; }); }
                        
                        if (!allNodesMapped) continue;

                        const elemTypeMap = {
                            'CTRIA3': 'tri',
                            'CQUAD4': 'quad',
                            'CBAR': 'bar',
                            'CBEAM': 'beam',
                            'CBUSH': 'bush',
                            'RBE2': 'rbe2',
                            'RBE3': 'rbe3'
                        };
                        const targetArrayKey = elemTypeMap[oldElem.type];
                        
                        if (targetArrayKey && model.elems[targetArrayKey]) {
                            model.elems[targetArrayKey].push(newElem);
                            newSelection.elems.add(newEid);
                            totalElemsCopied++;
                        }
                    }
                }

                selection.nodes = newSelection.nodes;
                selection.elems = newSelection.elems;
                const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
                model.indexToNid = nidsArr;
                model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
                buildGeometries(true);
                statusMsg(`Copied ${totalNodesCopied} nodes and ${totalElemsCopied} elements over ${copies} repeats.`);
            } catch(e) {
                statusMsg(e.message, true);
                console.error(e);
            }
        });
    }
    
    function mergeNodes() {
        historyManager.recordAction(() => {
            const tol = Number(document.getElementById('meshMergeTol').value);
            const keepRule = document.getElementById('meshMergeKeep').value;
            if (isNaN(tol) || tol < 0) { statusMsg("Invalid merge tolerance.", true); return; }
            
            const { globalPositions } = resolveAllTransforms();
            const nodes = Array.from(globalPositions.entries());
            const nodeIdMap = new Map();
            const nodesToDelete = new Set();
            let mergedCount = 0;
            const tolSq = tol * tol;

            for (let i = 0; i < nodes.length; i++) {
                const [nid1, pos1] = nodes[i];
                if (nodesToDelete.has(nid1)) continue;
                for (let j = i + 1; j < nodes.length; j++) {
                    const [nid2, pos2] = nodes[j];
                    if (nodesToDelete.has(nid2)) continue;
                    
                    if (pos1.distanceToSquared(pos2) < tolSq) {
                        const keepNid = keepRule === 'lower' ? Math.min(nid1, nid2) : Math.max(nid1, nid2);
                        const delNid = keepRule === 'lower' ? Math.max(nid1, nid2) : Math.min(nid1, nid2);
                        nodeIdMap.set(delNid, keepNid);
                        nodesToDelete.add(delNid);
                        mergedCount++;
                    }
                }
            }

            if (mergedCount === 0) { statusMsg("No nodes found to merge.", false); return; }
            for (const key in model.elems) {
                for (const elem of model.elems[key]) {
                    if (elem.n) { elem.n = elem.n.map(nid => nodeIdMap.get(nid) || nid); }
                    if (elem.gn && nodeIdMap.has(elem.gn)) { elem.gn = nodeIdMap.get(elem.gn); }
                    if (elem.deps) { elem.deps = elem.deps.map(nid => nodeIdMap.get(nid) || nid); }
                    if (elem.inds) { elem.inds = elem.inds.map(nid => nodeIdMap.get(nid) || nid); }
                }
            }
            for(const key in model.loads){
                for(const load of model.loads[key]){
                    if(load.nid && nodeIdMap.has(load.nid)) load.nid = nodeIdMap.get(load.nid);
                    if(load.nodes) load.nodes = load.nodes.map(nid => nodeIdMap.get(nid) || nid);
                }
            }
            for(const spc of model.spc1) { spc.nodes = spc.nodes.map(nid => nodeIdMap.get(nid) || nid); }
            for (const nid of nodesToDelete) { model.nodes.delete(nid); }
            const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
            model.indexToNid = nidsArr;
            model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
            buildGeometries(true);
            statusMsg(`Merged ${mergedCount} nodes.`);
        });
    }

    document.getElementById('btnMove').addEventListener('click', () => transformSelection(true, false));
    document.getElementById('btnCopy').addEventListener('click', () => copySelection(false));
    document.getElementById('btnMergeNodes').addEventListener('click', mergeNodes);
    document.getElementById('btnRadialMove').addEventListener('click', () => transformSelection(true, true));
    document.getElementById('btnRadialCopy').addEventListener('click', () => copySelection(true));
    
    const copyMethodEl = document.getElementById('copyMethod');
    if(copyMethodEl) {
        copyMethodEl.addEventListener('change', () => {
            const isOffset = copyMethodEl.value === 'offset';
            document.getElementById('copyOffsetFields').style.display = isOffset ? '' : 'none';
            document.getElementById('copyVectorFields').style.display = isOffset ? 'none' : '';
        });
    }

    const radialAxisMethodEl = document.getElementById('radialAxisMethod');
    if(radialAxisMethodEl) {
        radialAxisMethodEl.addEventListener('change', () => {
            const isVector = radialAxisMethodEl.value === 'vector';
            document.getElementById('radialVectorFields').style.display = isVector ? '' : 'none';
            document.getElementById('radialNodeFields').style.display = isVector ? 'none' : '';
        });
    }

    const reflectMethodEl = document.getElementById('reflectMethod');
    if (reflectMethodEl) {
        reflectMethodEl.addEventListener('change', () => {
            const isPlane = reflectMethodEl.value === 'plane';
            document.getElementById('reflectPlaneFields').style.display = isPlane ? '' : 'none';
            document.getElementById('reflectNodeFields').style.display = isPlane ? 'none' : '';
        });
    }

    function drawFreeEdges() {
        if (!showFreeEdges.checked) {
            if (freeEdgeLines) freeEdgeLines.visible = false;
            return;
        }

        const edgeMap = new Map();
        const shellElems = [...model.elems.tri, ...model.elems.quad];
        for (const elem of shellElems) {
            for (let i = 0; i < elem.n.length; i++) {
                const n1 = elem.n[i];
                const n2 = elem.n[(i + 1) % elem.n.length];
                const key = n1 < n2 ? `${n1}-${n2}` : `${n2}-${n1}`;
                edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
            }
        }
        
        const freeEdgePositions = [];
        for (const [key, count] of edgeMap.entries()) {
            if (count === 1) {
                const [n1_id, n2_id] = key.split('-').map(Number);
                const idx1 = model.nodeIndex.get(n1_id);
                const idx2 = model.nodeIndex.get(n2_id);
                if (idx1 !== undefined && idx2 !== undefined) {
                    const p1 = nodePosition(idx1);
                    const p2 = nodePosition(idx2);
                    freeEdgePositions.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
                }
            }
        }

        if (freeEdgeLines) {
            scene.remove(freeEdgeLines);
            freeEdgeLines.geometry.dispose();
            freeEdgeLines.material.dispose();
            freeEdgeLines = null;
        }

        if (freeEdgePositions.length > 0) {
            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.Float32BufferAttribute(freeEdgePositions, 3));
            const mat = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 });
            mat.clippingPlanes = [clippingPlane];
            freeEdgeLines = new THREE.LineSegments(geom, mat);
            scene.add(freeEdgeLines);
        }
    }

    document.getElementById('btnReflect').addEventListener('click', () => {
        historyManager.recordAction(() => {
            try {
                const { globalPositions, globalCoordTransforms } = resolveAllTransforms();
                const { selNodes, selElems } = getExpandedSelection();

                if (selNodes.size === 0) throw new Error("No items selected to reflect.");

                let plane = new THREE.Plane();
                const method = document.getElementById('reflectMethod').value;
                if(method === 'plane') {
                    const planeType = document.getElementById('meshReflectPlane').value;
                    const offset = Number(document.getElementById('meshReflectOffset').value) || 0;
                    if (planeType === 'yz') plane.set(new THREE.Vector3(1, 0, 0), -offset);
                    else if (planeType === 'xz') plane.set(new THREE.Vector3(0, 1, 0), -offset);
                    else plane.set(new THREE.Vector3(0, 0, 1), -offset);
                } else {
                    const n1_id = parseInt(document.getElementById('reflectN1').value);
                    const n2_id = parseInt(document.getElementById('reflectN2').value);
                    const n3_id = parseInt(document.getElementById('reflectN3').value);
                    if ([n1_id, n2_id, n3_id].some(isNaN)) throw new Error("Please select 3 nodes to define the reflection plane.");
                    const p1 = globalPositions.get(n1_id);
                    const p2 = globalPositions.get(n2_id);
                    const p3 = globalPositions.get(n3_id);
                    if (!p1 || !p2 || !p3) throw new Error("One or more plane-defining nodes do not exist.");
                    plane.setFromCoplanarPoints(p1, p2, p3);
                }

                let { maxNid, maxEid } = getHighestIds();
                const nodeMap = new Map();
                for (const nid of selNodes) {
                    const pos = globalPositions.get(nid);
                    if (!pos) continue;
                    const reflectedPos = new THREE.Vector3();
                    plane.projectPoint(pos, reflectedPos);
                    const offsetVec = new THREE.Vector3().subVectors(reflectedPos, pos);
                    reflectedPos.add(offsetVec);
                    
                    const newNid = ++maxNid;
                    nodeMap.set(nid, newNid);
                    
                    const oldNode = model.nodes.get(nid);
                    const coordTransform = globalCoordTransforms.get(oldNode.cp || 0);
                    const invCoordTransform = coordTransform.clone().invert();
                    const newLocalPos = reflectedPos.applyMatrix4(invCoordTransform);

                    model.nodes.set(newNid, { ...oldNode, x: newLocalPos.x, y: newLocalPos.y, z: newLocalPos.z });
                }

                for (const elem of selElems) {
                    const newEid = ++maxEid;
                    const newElem = JSON.parse(JSON.stringify(elem));
                    newElem.eid = newEid;
                    if (newElem.n) {
                        newElem.n = newElem.n.map(nid => nodeMap.get(nid));
                        if(elem.type === 'CQUAD4' || elem.type === 'CTRIA3') { // Reverse winding order
                           newElem.n.reverse();
                        }
                    }
                     if (newElem.gn) newElem.gn = nodeMap.get(newElem.gn) || newElem.gn;
                     if (newElem.deps) newElem.deps = newElem.deps.map(nid => nodeMap.get(nid) || nid);
                     if (newElem.inds) newElem.inds = newElem.inds.map(nid => nodeMap.get(nid) || nid);

                    const typeKey = elem.type.toLowerCase().replace('c', '').replace(/[34]/g, '');
                    const targetKey = typeKey === 'ctria' ? 'tri' : (typeKey === 'cquad' ? 'quad' : typeKey);
                    if (model.elems[targetKey]) model.elems[targetKey].push(newElem);
                }
                
                const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
                model.indexToNid = nidsArr;
                model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
                buildGeometries(true);
                statusMsg(`Reflected ${selNodes.size} nodes and ${selElems.size} elements.`);

            } catch (e) { statusMsg(e.message, true); }
        });
    });

    document.getElementById('btnRefineMesh').addEventListener('click', () => {
        historyManager.recordAction(() => {
            try {
                const selElems = [...selection.elems].map(eid => Object.values(model.elems).flat().find(e => e.eid === eid)).filter(e => e && (e.type === 'CQUAD4' || e.type === 'CTRIA3'));
                if (selElems.length === 0) throw new Error("No shell elements selected to refine.");

                let { maxNid, maxEid } = getHighestIds();
                const midNodeCache = new Map();
                
                const getOrCreateMidNode = (nid1, nid2) => {
                    const key = nid1 < nid2 ? `${nid1}-${nid2}` : `${nid2}-${nid1}`;
                    if (midNodeCache.has(key)) return midNodeCache.get(key);
                    const node1 = model.nodes.get(nid1); 
                    const node2 = model.nodes.get(nid2);
                    const newNid = ++maxNid;
                    model.nodes.set(newNid, { x: (node1.x + node2.x)/2, y: (node1.y + node2.y)/2, z: (node1.z + node2.z)/2, cp: node1.cp });
                    midNodeCache.set(key, newNid);
                    return newNid;
                };

                for (const elem of selElems) {
                    if (elem.type === 'CQUAD4') {
                        const [n1, n2, n3, n4] = elem.n;
                        const n5 = getOrCreateMidNode(n1, n2); const n6 = getOrCreateMidNode(n2, n3);
                        const n7 = getOrCreateMidNode(n3, n4); const n8 = getOrCreateMidNode(n4, n1);
                        const n9 = ++maxNid;
                        const p1=model.nodes.get(n1), p2=model.nodes.get(n2), p3=model.nodes.get(n3), p4=model.nodes.get(n4);
                        model.nodes.set(n9, { x: (p1.x+p2.x+p3.x+p4.x)/4, y: (p1.y+p2.y+p3.y+p4.y)/4, z: (p1.z+p2.z+p3.z+p4.z)/4, cp: p1.cp });

                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n1, n5, n9, n8], type: 'CQUAD4' });
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n5, n2, n6, n9], type: 'CQUAD4' });
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n9, n6, n3, n7], type: 'CQUAD4' });
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n8, n9, n7, n4], type: 'CQUAD4' });
                    } else { // CTRIA3
                        const [n1, n2, n3] = elem.n;
                        const p1=model.nodes.get(n1), p2=model.nodes.get(n2), p3=model.nodes.get(n3);
                        const n4 = getOrCreateMidNode(n1, n2);
                        const n5 = getOrCreateMidNode(n2, n3);
                        const n6 = getOrCreateMidNode(n3, n1);
                        const n7 = ++maxNid; // Centroid node
                        model.nodes.set(n7, { x: (p1.x+p2.x+p3.x)/3, y: (p1.y+p2.y+p3.y)/3, z: (p1.z+p2.z+p3.z)/3, cp: p1.cp });
                        
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n1, n4, n7, n6], type: 'CQUAD4' });
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n4, n2, n5, n7], type: 'CQUAD4' });
                        model.elems.quad.push({ eid: ++maxEid, pid: elem.pid, n: [n6, n7, n5, n3], type: 'CQUAD4' });
                    }
                     // Delete original element
                    const typeKey = elem.type === 'CTRIA3' ? 'tri' : 'quad';
                    const index = model.elems[typeKey].findIndex(e => e.eid === elem.eid);
                    if (index > -1) model.elems[typeKey].splice(index, 1);
                }
                const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
                model.indexToNid = nidsArr;
                model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
                buildGeometries(true);
                statusMsg(`Refined ${selElems.length} elements.`);
            } catch (e) {
                statusMsg(e.message, true);
                console.error(e);
            }
        });
    });

    window.addEventListener('dragover', (e)=>{ e.preventDefault(); dropzone.style.display='flex'; });
    window.addEventListener('dragleave', (e)=>{ if (e.target.id === 'app') dropzone.style.display='none'; });
    window.addEventListener('drop', async (e)=>{ e.preventDefault(); dropzone.style.display='none'; const f=e.dataTransfer.files?.[0]; if (!f) return; const text=await f.text(); loadFromText(text, f.name); });
    function loadFromText(text, name='model.dat') { 
        try { 
            parseBDF(text); 
            buildGeometries(); 
            
            // Apply visibility settings from toggles
            document.querySelectorAll('[data-vis]').forEach(toggle => {
                const visType = toggle.getAttribute('data-vis');
                if (visType === 'nodes' && points) {
                    points.visible = toggle.checked;
                } else if (visType === 'edges' && meshLines) {
                    meshLines.visible = toggle.checked;
                } else if (visType === 'forces') {
                    forceGroup.visible = toggle.checked;
                } else if (visType === 'moments') {
                    momentGroup.visible = toggle.checked;
                } else if (visType === 'spcs') {
                    spcGroup.visible = toggle.checked;
                } else if (visType === 'coords') {
                    coordSysGroup.visible = toggle.checked;
                }
            });
            
            // Apply parallel view setting
            if (parallelToggle && parallelToggle.checked) {
                camera = orthographicCamera;
                controls.object = camera;
                controls.update();
            }
            
            statusMsg('Loaded '+name+'. Nodes: '+model.indexToNid.length); 
            historyManager.clear(); 
            updateClipSliderRange(); 
        } catch (e) { 
            console.error(e); 
            statusMsg('Failed to load file (see console).', true); 
        } 
    }
    function refreshCounts(){ const nNodes=model.indexToNid.length, nElems=Object.values(model.elems).reduce((s, a)=>s+a.length,0), nLoads=(model.loads.force?.length||0)+(model.loads.pload?.length||0)+(model.loads.moment?.length||0), nSPC=model.spc1.reduce((s,g)=>s+g.nodes.length,0); }
    function statusMsg(msg, isErr=false){ if(statusEl) { statusEl.textContent=msg; statusEl.classList.toggle('danger', !!isErr); } }
    function onResize(){
        const r=document.getElementById('viewport').getBoundingClientRect();
        const aspect = r.width / r.height;

        renderer.setSize(r.width, r.height, false);
        labelRenderer.setSize(r.width, r.height);

        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();

        const h = orthographicCamera.top;
        orthographicCamera.left = -h * aspect;
        orthographicCamera.right = h * aspect;
        orthographicCamera.updateProjectionMatrix();

        if (camera.isOrthographicCamera) {
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        } else {
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }
    }
    window.addEventListener('resize', onResize); onResize();

    function updateUndoRedoButtons() { btnUndo.disabled = historyManager.pointer <= 0; btnRedo.disabled = historyManager.pointer >= historyManager.stack.length - 1; }
    btnUndo.addEventListener('click', () => historyManager.undo());
    btnRedo.addEventListener('click', () => historyManager.redo());
    window.addEventListener('keydown', (e) => { 
        if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); btnUndo.click(); } 
        if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); btnRedo.click(); }
        if (isPolygonSelecting && e.key === 'Escape') { cancelPolygonSelection(); }
    });
    
    document.querySelectorAll('.card-header').forEach(header => {
        header.addEventListener('click', () => {
            header.parentElement.classList.toggle('collapsed');
        });
    });

    function updateClipSliderRange() {
        if (model.bbox && !model.bbox.isEmpty()) {
            const box = model.bbox;
            const normal = clippingPlane.normal;
            const corners = [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.max.y, box.max.z),
            ];
            let min_d = Infinity, max_d = -Infinity;
            corners.forEach(corner => {
                const d = corner.dot(normal);
                if (d < min_d) min_d = d;
                if (d > max_d) max_d = d;
            });
            const buffer = (max_d - min_d) * 0.05; 
            min_d -= buffer;
            max_d += buffer;
            clipOffsetSlider.min = min_d;
            clipOffsetSlider.max = max_d;
            clipOffsetSlider.step = (max_d - min_d) / 200;
        }
        updateClipSliderFromPlane();
    }

    function updateClipSliderFromPlane() {
        clipOffsetSlider.value = -clippingPlane.constant;
    }
    
    clippingToggle.addEventListener('change', (e) => {
        renderer.localClippingEnabled = e.target.checked;
        if(clipPlaneHelper) clipPlaneHelper.visible = e.target.checked;
    });

    clipPlaneSelect.addEventListener('change', () => {
        const val = clipPlaneSelect.value;
        const currentOriginPoint = new THREE.Vector3(0,0,0);
        if (model.bbox) model.bbox.getCenter(currentOriginPoint);

        const normal = new THREE.Vector3();
        if (val === 'x') normal.set(1, 0, 0); 
        else if (val === 'y') normal.set(0, 1, 0); 
        else if (val === 'z') normal.set(0, 0, 1);

        clippingPlane.setFromNormalAndCoplanarPoint(normal, currentOriginPoint);
        updateClipSliderRange();
    });

    flipClipPlane.addEventListener('click', () => {
        clippingPlane.negate();
        updateClipSliderFromPlane();
    });
    
    setClipOriginToSelection.addEventListener('click', () => {
        if (selection.nodes.size > 0) {
            const centroid = centroidOf(selection.nodes);
            clippingPlane.setFromNormalAndCoplanarPoint(clippingPlane.normal, centroid);
            updateClipSliderRange();
        } else {
            statusMsg('Select one or more nodes to set clipping origin.', true);
        }
    });

    clipOffsetSlider.addEventListener('input', () => {
        clippingPlane.constant = -parseFloat(clipOffsetSlider.value);
    });

    canvas.addEventListener('wheel', (e) => {
        if (e.ctrlKey && renderer.localClippingEnabled) {
            e.preventDefault();
            e.stopPropagation();
            const range = parseFloat(clipOffsetSlider.max) - parseFloat(clipOffsetSlider.min);
            if (range === 0) return;
            const step = range / 200;
            const newValue = parseFloat(clipOffsetSlider.value) - Math.sign(e.deltaY) * step;
            
            clipOffsetSlider.value = Math.max(parseFloat(clipOffsetSlider.min), Math.min(parseFloat(clipOffsetSlider.max), newValue));
            clippingPlane.constant = -parseFloat(clipOffsetSlider.value);
        }
    }, { passive: false });

    function updateLabelVisibility() {
        allLabelGroups.forEach(group => group.children.forEach(lbl => lbl.visible = lbl.parent.visible));
    }

(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  updateCameraClipping(); // Dynamic clipping update
  const staticScale = Number(symbolSize.value || 1.0);
  if (staticScale > 0) {
    const dist = camera.position.distanceTo(controls.target);
    const scaleFactor = dist * 0.007;
    const updateSymbolScale = (obj) => { if (obj.userData.isStaticSymbol) { const newScale = scaleFactor * obj.userData.baseScale * staticScale; if (newScale > 1e-5) { obj.scale.set(newScale, newScale, newScale); } } };
    for (const child of forceGroup.children) updateSymbolScale(child); for (const child of momentGroup.children) updateSymbolScale(child); for (const child of ploadGroup.children) updateSymbolScale(child); for (const child of spcGroup.children) updateSymbolScale(child);
  }
  
  if (camera.position.distanceToSquared(lastCameraPos) > CULLING_THRESHOLD_SQUARED || 
      !camera.quaternion.equals(lastCameraQuat)) {
      updateLabelVisibility();
      lastCameraPos.copy(camera.position);
      lastCameraQuat.copy(camera.quaternion);
  }

  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  if (compassRenderer) {
      // Keep the compass pinned and driven only by the main view direction
      const viewDir = camera.position.clone().sub(controls.target).normalize();
      compassCamera.position.copy(viewDir.multiplyScalar(2.5));
      compassCamera.up.copy(camera.up);
      compassCamera.lookAt(0,0,0);
      compassRenderer.render(compassScene, compassCamera);
  }
})();
  
    historyManager.clear();
  </script>
</body>
</html>