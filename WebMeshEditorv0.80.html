<!DOCTYPE html>
<!-- 
  Version: 0.80 (Milestone 1 Complete + UX/Render Fixes)
Key Changes:

**New Feature: Clipping Plane Tool:** Added a "Clipping" card to slice the model along XY, YZ, or XZ planes. Position can be set to a selected node, and the offset is adjustable with a slider or Ctrl+Mouse Wheel.
**New Feature: Label Culling:** Added a "Cull Labels" option (on by default) to intelligently hide overlapping labels and prevent visual clutter on dense models. The flickering issue has been resolved.
**UX Enhancements:**
* Sidebar cards are now collapsible.
* Double-click anywhere on the model to set the camera's rotation pivot point.
* Added a "Copy Selected Node Coords" button to the Add Node card.
* Parallel View (Orthographic Camera) is now fully functional.
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebMesh Editor v0.80</title>
  <style>
    :root {
      --bg: #0f1115; --panel: #141821; --text: #e6e8ee; --muted: #9aa3b2; --accent: #5aa9ff; --danger: #ff6b6b; --ok: #4ad295; --border: #1f2430;
    }
    html, body { 
      height: 100%; 
      margin: 0; 
      background: var(--bg); 
      color: var(--text); 
      font: 14px/1.4 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden; /* Prevent body from scrolling */
    }
    #app { 
      display: grid; 
      grid-template-columns: 320px 1fr; 
      grid-template-rows: auto 1fr; 
      height: 100vh; /* Use viewport height */
    }
    header { grid-column: 1 / -1; display: flex; align-items: center; gap: 12px; padding: 10px 14px; border-bottom: 1px solid var(--border); background: #10131a; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    header .spacer { flex: 1; }
    header .btn { background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px 12px; cursor: pointer; }
    header .btn:hover { border-color: #2b3242; }
    header .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    #sidebar { 
      background: var(--panel); 
      border-right: 1px solid var(--border); 
      padding: 12px; 
      overflow-y: auto; /* Explicitly set vertical scroll */
      grid-row: 2;
    }
    /* Collapsible card styles */
    .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 4px 0;
        user-select: none;
    }
    .card-header h2 { font-size: 13px; letter-spacing: .04em; text-transform: uppercase; margin: 0; color: var(--muted); }
    .card-header::after {
        content: '▲';
        transition: transform 0.2s ease-in-out;
        font-size: 10px;
        color: var(--muted);
    }
    .card-content {
        max-height: 1000px; /* Set a large max-height for transition */
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
    }
    .card.collapsed .card-content {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    .card.collapsed .card-header::after {
        transform: rotate(180deg);
    }

    .card { background: #0f1320; border: 1px solid var(--border); border-radius: 12px; padding: 10px; margin-bottom: 10px; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
    .row label { width: 100px; color: var(--muted); flex-shrink: 0; }
    input[type="text"], input[type="number"], select { width: 100%; background: #0d111a; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 6px 8px; }
    input[type="file"] { width: 100%; }
    input[type="range"] { width: 100%; accent-color: var(--accent); }
    button { background: #1a2130; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; cursor: pointer; }
    button:hover { border-color: #2b3242; }
    #viewport { 
      position: relative; 
      grid-row: 2;
      overflow: hidden; /* Prevent viewport from causing scroll */
    }
    #canvas { width: 100%; height: 100%; display: block; }
    #dropzone { position: absolute; inset: 0; border: 2px dashed #2b3242; border-radius: 16px; display: none; align-items: center; justify-content: center; color: var(--muted); background: rgba(20, 24, 33, 0.6); pointer-events: none; }
    #status { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color: var(--muted); white-space: pre-wrap; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 12px; background: #0c1220; border: 1px solid var(--border); color: var(--muted); font-size: 12px; margin-right: 6px; }
    .danger { color: var(--danger); }
    .ok { color: var(--ok); }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 0 12px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .grid-3 label { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; font-size: 12px;}
    .grid-2 .row label { width: auto; }
    .label { font-size: 11px; line-height: 1; padding: 2px 6px; background: rgba(0,0,0,0.55); border: 1px solid var(--border); border-radius: 6px; color: var(--text); pointer-events: none; transition: opacity 0.2s; }
    .label.muted { opacity: 0.8; }
    /* Model tree styles */
    #modelTreeContainer ul { list-style: none; padding-left: 12px; margin: 0; }
    #modelTreeContainer li { cursor: pointer; user-select: none; position: relative; }
    #modelTreeContainer li ul { display: none; }
    #modelTreeContainer li.open > ul { display: block; }
    #modelTreeContainer li::before { content: '►'; display: inline-block; width: 1em; color: var(--muted); }
    #modelTreeContainer li.open::before { content: '▼'; }
    /* Selection rectangle overlay */
    #selectRect { position: absolute; border: 1px dashed var(--accent); background: rgba(90,169,255,0.15); pointer-events: none; display: none; z-index: 10; }
    /* Context menu */
    #contextMenu { position: fixed; z-index: 20; background: #0d111a; border: 1px solid var(--border); border-radius: 6px; padding: 4px 0; display: none; box-shadow: 0 2px 6px rgba(0,0,0,0.5); }
    #contextMenu div { padding: 4px 12px; cursor: pointer; white-space: nowrap; }
    #contextMenu div:hover { background: #1a2130; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>WebMesh Editor v0.80</h1>
      <span class="pill">Rotate: LMB</span>
      <span class="pill">Pan: RMB</span>
      <span class="pill">Zoom: Wheel</span>
      <span class="pill">Set Pivot: Dbl-Click</span>
      <span class="pill">Box Select: Alt+Drag</span>
      <span class="pill">Move Clip: Ctrl+Wheel</span>
      <div class="spacer"></div>
      <button class="btn" id="btnUndo" disabled>Undo</button>
      <button class="btn" id="btnRedo" disabled>Redo</button>
      <button class="btn" id="btnReset">Reset View</button>
      <button class="btn" id="btnExport">Export .dat</button>
    </header>

    <aside id="sidebar">
      <div class="card">
        <div class="card-header"><h2>File</h2></div>
        <div class="card-content">
            <div class="row"><input id="file" type="file" accept=".dat,.bdf" /></div>
            <div class="row" style="justify-content: space-between">
              <button id="btnSample">Load sample</button>
              <button id="btnClear">Clear</button>
            </div>
            <div class="row" style="margin-top:6px">
              <small class="muted">You can also drag & drop a .dat/.bdf anywhere</small>
            </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Model Info</h2></div>
        <div class="card-content">
            <div id="modelTreeContainer"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Display Settings</h2></div>
        <div class="card-content">
            <div class="row"><label>Symbol Size</label><input id="symbolSize" type="number" step="0.1" value="1.0"></div>
            <div class="row"><label>Spring Size</label><input id="springSize" type="number" step="0.1" value="1.0"></div>
            <div class="row"><label>Color Mode</label>
              <select id="colorMode">
                <option value="default">Default</option>
                <option value="property" selected>Property</option>
              </select>
            </div>
            <div class="row"><label>Background</label><input id="bgColor" type="color" value="#0f1115"></div>
            <div class="row"><label>Shading</label><input type="checkbox" id="shadingToggle"></div>
            <div class="row"><label>Parallel View</label><input type="checkbox" id="parallelToggle"></div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Visibility</h2></div>
        <div class="card-content">
            <div class="row"><label>Opacity</label><input id="opacitySlider" type="range" min="0" max="1" step="0.05" value="1.0"></div>
            <div class="grid-2">
                <div class="row"><label>Nodes</label><input type="checkbox" data-vis="nodes" checked></div>
                <div class="row"><label>Forces</label><input type="checkbox" data-vis="forces" checked></div>
                <div class="row"><label>Moments</label><input type="checkbox" data-vis="moments" checked></div>
                <div class="row"><label>SPCs</label><input type="checkbox" data-vis="spcs" checked></div>
                <div class="row"><label>Edges</label><input type="checkbox" data-vis="edges" checked></div>
                <div class="row"><label>Coord Sys</label><input type="checkbox" data-vis="coords" checked></div>
                <div class="row"><label>CQUAD4</label><input type="checkbox" data-vis="cquad4" checked></div>
                <div class="row"><label>CTRIA3</label><input type="checkbox" data-vis="ctria3" checked></div>
                <div class="row"><label>CBAR</label><input type="checkbox" data-vis="cbar" checked></div>
                <div class="row"><label>CBEAM</label><input type="checkbox" data-vis="cbeam" checked></div>
                <div class="row"><label>CBUSH</label><input type="checkbox" data-vis="cbush" checked></div>
                <div class="row"><label>RBE2</label><input type="checkbox" data-vis="rbe2" checked></div>
                <div class="row"><label>RBE3</label><input type="checkbox" data-vis="rbe3" checked></div>
            </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Clipping</h2></div>
        <div class="card-content">
          <div class="row"><label>Enable</label><input id="clippingToggle" type="checkbox"></div>
          <div class="row"><label>Plane</label>
            <select id="clipPlaneSelect">
              <option value="x">YZ Plane (Normal X)</option>
              <option value="y">XY Plane (Normal Z)</option>
              <option value="z" selected>XZ Plane (Normal Y)</option>
            </select>
          </div>
          <div class="row"><label>Offset</label><input id="clipOffsetSlider" type="range" min="-1" max="1" step="0.01" value="0"></div>
           <div class="row" style="justify-content: space-between">
              <button id="setClipOriginToSelection">Set to Selection</button>
              <button id="flipClipPlane">Flip</button>
            </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Labels</h2></div>
        <div class="card-content">
            <div class="row"><label>Cull Labels</label><input id="cullLabelsToggle" type="checkbox" checked></div>
            <div class="row"><label>Node IDs</label><input id="showNodeIds" type="checkbox"></div>
            <div class="row"><label>Element IDs</label><input id="showElemIds" type="checkbox"></div>
            <div class="row"><label>SPC DOF</label><input id="showSPCLabels" type="checkbox"></div>
            <div class="row"><label>Load Labels</label><input id="showLoadLabels" type="checkbox"></div>
            <div class="row"><label>Load Mode</label>
              <select id="loadLabelMode">
                <option value="resultant" selected>Resultant</option>
                <option value="components">Components</option>
              </select>
            </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Selection</h2></div>
        <div class="card-content">
            <div class="row" style="justify-content: space-between">
              <span id="selCount">None</span>
              <button id="btnClearSelection">Clear Selection</button>
            </div>
            <div class="row">
              <label>Select Mode</label>
              <select id="selectMode">
                <option value="node" selected>Nodes</option>
                <option value="element">Elements</option>
                <option value="load">Loads</option>
                <option value="constraint">Constraints</option>
              </select>
            </div>
            <div class="row">
              <label>Multi Select</label>
              <input id="multiSelect" type="checkbox">
            </div>
            <div id="selectionEditContainer" style="display:none">
              <div class="row"><label>Node ID</label><input id="selNid" type="text" placeholder="—" disabled></div>
              <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
              <div class="grid-2">
                <div>
                  <div class="row"><label style="color: var(--text);"><b>Local Coords</b></label></div>
                  <div class="row"><label>X</label><input id="selX" type="number" step="any"></div>
                  <div class="row"><label>Y</label><input id="selY" type="number" step="any"></div>
                  <div class="row"><label>Z</label><input id="selZ" type="number" step="any"></div>
                </div>
                <div>
                  <div class="row"><label style="color: var(--text);"><b>Global Coords</b></label></div>
                  <div class="row"><label>X</label><input id="selGX" type="text" disabled></div>
                  <div class="row"><label>Y</label><input id="selGY" type="text" disabled></div>
                  <div class="row"><label>Z</label><input id="selGZ" type="text" disabled></div>
                </div>
              </div>
              <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
              <div class="row"><label>CP</label><input id="selCP" type="number" step="1"></div>
              <div class="row"><label>CD</label><input id="selCD" type="number" step="1"></div>
              <div class="row" style="justify-content: space-between">
                <button id="btnApplyChanges">Apply Changes</button>
                <button id="btnCancelChanges">Cancel</button>
              </div>
            </div>
            <div id="measureResultsContainer" style="display: none; border-top: 1px solid var(--border); margin-top: 12px; padding-top: 12px;">
              <h2 style="margin: 0 0 8px; font-size:13px;">Measure Results</h2>
              <div id="measureResults"></div>
            </div>
        </div>
      </div>

      <div class="card" id="editElementCard" style="display: none;">
        <div class="card-header"><h2>Edit Element</h2></div>
        <div class="card-content">
          <div class="row"><label>EID</label><input id="editEid" type="number" disabled></div>
          <div class="row"><label>PID</label><input id="editPid" type="number"></div>
          <div class="row edit-elem-nodes"><label>Node 1</label><input id="editN1" type="number"></div>
          <div class="row edit-elem-nodes"><label>Node 2</label><input id="editN2" type="number"></div>
          <div class="row edit-elem-nodes"><label>Node 3</label><input id="editN3" type="number"></div>
          <div class="row edit-elem-nodes"><label>Node 4</label><input id="editN4" type="number"></div>
          <div id="editCquad4AdvancedOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
              <div class="row"><label>THETA/MCID</label><input id="editThetaMcid" type="number" step="any"></div>
              <div class="row"><label>ZOFFS</label><input id="editZoffs" type="number" step="any"></div>
              <div class="row"><label>TFLAG</label><input id="editTflag" type="number" step="1"></div>
              <div class="row"><label>Thicknesses</label></div>
              <div class="grid-2">
                  <div class="row"><label>T1</label><input id="editT1" type="number" step="any"></div>
                  <div class="row"><label>T2</label><input id="editT2" type="number" step="any"></div>
                  <div class="row"><label>T3</label><input id="editT3" type="number" step="any"></div>
                  <div class="row"><label>T4</label><input id="editT4" type="number" step="any"></div>
              </div>
          </div>
          <div class="row" style="justify-content: space-between">
            <button id="btnApplyElemEdit">Apply Edit</button>
            <button id="btnCancelElemEdit">Cancel</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Add Node</h2></div>
        <div class="card-content">
            <div class="row"><label>NID</label><input id="newNid" type="number" placeholder="Auto"></div>
            <div class="row"><label>X</label><input id="newX" type="number" step="any" value="0"></div>
            <div class="row"><label>Y</label><input id="newY" type="number" step="any" value="0"></div>
            <div class="row"><label>Z</label><input id="newZ" type="number" step="any" value="0"></div>
            <div class="row">
              <button id="advancedNodeToggle" style="width:auto; padding: 2px 8px; font-size: 12px; background: none; border: none; color: var(--muted); cursor:pointer;">Advanced ▼</button>
            </div>
            <div id="advancedNodeOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                <div class="row"><label>CP</label><input id="newCP" type="number" step="1" value="0"></div>
                <div class="row"><label>CD</label><input id="newCD" type="number" step="1" value="0"></div>
                <div class="row"><label>PS</label><input id="newPS" type="text" placeholder="e.g., 123"></div>
            </div>
            <div class="row" style="margin-top: 8px;"><button id="btnCopySelectedNode" disabled>Copy Selected Node Coords</button></div>
            <div class="row" style="margin-top: 8px;"><button id="btnAddNode">Add Node</button></div>
        </div>
      </div>

      <div class="card" id="addElementCard">
        <div class="card-header"><h2>Add Element</h2></div>
        <div class="card-content">
            <div class="row"><label>Type</label>
              <select id="elemType">
                <option value="cquad4" selected>CQUAD4</option>
                <option value="ctria3">CTRIA3</option>
                <option value="cbar">CBAR</option>
                <option value="cbeam">CBEAM</option>
                <option value="cbush">CBUSH</option>
                <option value="rbe2">RBE2</option>
                <option value="rbe3">RBE3</option>
              </select>
            </div>
            <div class="row"><label>EID</label><input id="elemEid" type="number" placeholder="Auto"></div>
            <div class="row"><label>PID</label><input id="elemPid" type="number" value="1"></div>
            <div class="row elem-nodes"><label id="elemN1Label">Node 1</label><input id="elemN1" type="number" placeholder="Use selected"></div>
            <div class="row elem-nodes"><label>Node 2</label><input id="elemN2" type="number"></div>
            <div class="row elem-nodes"><label>Node 3</label><input id="elemN3" type="number"></div>
            <div class="row elem-nodes"><label>Node 4</label><input id="elemN4" type="number"></div>
            <div class="row" id="elemCmRow" style="display:none;"><label>CM</label><input id="elemCm" type="text" value="123456"></div>
            <div class="row" id="elemDepNodesRow" style="display:none;"><label>Deps</label><input id="elemDepNodes" type="text" placeholder="Multi-select or CSV"></div>
            <div class="row" id="elemIndNodesRow" style="display:none;"><label>Indeps</label><input id="elemIndNodes" type="text" placeholder="Multi-select or CSV"></div>
            <div class="row" id="cquad4AdvancedToggleRow" style="display:none;">
                <button id="cquad4AdvancedToggle" style="width:auto; padding: 2px 8px; font-size: 12px; background: none; border: none; color: var(--muted); cursor:pointer;">Advanced ▼</button>
            </div>
            <div id="cquad4AdvancedOptions" style="display:none; border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                <div class="row"><label>THETA/MCID</label><input id="elemThetaMcid" type="number" step="any" placeholder="Default 0.0"></div>
                <div class="row"><label>ZOFFS</label><input id="elemZoffs" type="number" step="any" placeholder="Optional"></div>
                <div class="row"><label>TFLAG</label><input id="elemTflag" type="number" step="1" placeholder="0 or 1"></div>
                <div class="row"><label>Thicknesses</label></div>
                <div class="grid-2">
                    <div class="row"><label>T1</label><input id="elemT1" type="number" step="any"></div>
                    <div class="row"><label>T2</label><input id="elemT2" type="number" step="any"></div>
                    <div class="row"><label>T3</label><input id="elemT3" type="number" step="any"></div>
                    <div class="row"><label>T4</label><input id="elemT4" type="number" step="any"></div>
                </div>
            </div>
            <div class="row"><button id="btnAddElement">Add Element</button></div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Add CORD2R System</h2></div>
        <div class="card-content">
              <div class="row"><label>CSYS ID</label><input id="csysId" type="number" value="1"></div>
              <div class="row"><label>Ref CID</label><input id="csysRid" type="number" value="0" placeholder="0 for basic"></div>
              <div class="row"><label>Method</label>
                <select id="csysMethod">
                    <option value="nodes" selected>By Node IDs</option>
                    <option value="coords">By Coordinates</option>
                </select>
              </div>
              <div id="csysNodes">
                  <div class="grid-3">
                    <label>Origin (G1)</label>
                    <label>Z-Axis (G2)</label>
                    <label>XZ-Plane (G3)</label>
                    <input id="csysN1" type="number" placeholder="NID">
                    <input id="csysN2" type="number" placeholder="NID">
                    <input id="csysN3" type="number" placeholder="NID">
                  </div>
              </div>
              <div id="csysCoords" style="display:none;">
                 <div class="grid-3">
                    <label>Origin X</label><label>Origin Y</label><label>Origin Z</label>
                    <input type="number" id="csysA1" value="0"><input type="number" id="csysA2" value="0"><input type="number" id="csysA3" value="0">
                    <label>Z-Axis X</label><label>Z-Axis Y</label><label>Z-Axis Z</label>
                    <input type="number" id="csysB1" value="0"><input type="number" id="csysB2" value="0"><input type="number" id="csysB3" value="1">
                    <label>XZ-Plane X</label><label>XZ-Plane Y</label><label>XZ-Plane Z</label>
                    <input type="number" id="csysC1" value="1"><input type="number" id="csysC2" value="0"><input type="number" id="csysC3" value="0">
                 </div>
              </div>
              <div class="row" style="margin-top:8px"><button id="btnAddCsys">Add CORD2R</button></div>
          </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Add Load / Constraint</h2></div>
        <div class="card-content">
            <div class="row"><label>Node ID(s)</label><input id="loadNodeId" type="text" placeholder="Selected or CSV"></div>
            <div class="row"><label>SID</label><input id="sid" type="number" value="1"></div>
            <div class="row"><label>FORCE</label><input id="fMag" type="number" step="any" value="1000"></div>
            <div class="row"><label>Dir X</label><input id="fX" type="number" step="any" value="1"></div>
            <div class="row"><label>Dir Y</label><input id="fY" type="number" step="any" value="0"></div>
            <div class="row"><label>Dir Z</label><input id="fZ" type="number" step="any" value="0"></div>
            <div class="row"><button id="btnAddForce">Add FORCE</button></div>
            <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
            <div class="row"><label>MOMENT</label><input id="mMag" type="number" step="any" value="500"></div>
            <div class="row"><label>Dir X</label><input id="mX" type="number" step="any" value="0"></div>
            <div class="row"><label>Dir Y</label><input id="mY" type="number" step="any" value="1"></div>
            <div class="row"><label>Dir Z</label><input id="mZ" type="number" step="any" value="0"></div>
            <div class="row"><button id="btnAddMoment">Add MOMENT</button></div>
            <hr style="border:none;border-top:1px solid var(--border);margin:8px 0">
            <div class="row"><label>SPC1</label><input id="spcComp" type="text" value="123"></div>
            <div class="row"><button id="btnAddSPC">Add SPC1</button></div>
        </div>
      </div>

      <div class="card">
        <div class="card-header"><h2>Status</h2></div>
        <div class="card-content" id="status">Drop a .dat/.bdf file to begin…</div>
      </div>
    </aside>

    <section id="viewport">
      <canvas id="canvas"></canvas>
      <div id="selectRect"></div>
      <div id="dropzone">Drop .dat/.bdf to load</div>
      <!-- Mini reference compass for global orientation -->
      <div id="compass" style="position:absolute; bottom:10px; left:10px; width:80px; height:80px; pointer-events:none;"></div>
    </section>
    <div id="contextMenu"></div>
  </div>

  <!-- Three.js import map + modules -->
  <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

    // ---------------- Model ----------------
    const model = {
      nodes: new Map(), // nid -> {x,y,z,cp,cd,ps}
      nodeIndex: new Map(), // nid -> idx
      indexToNid: [], // idx -> nid
      elems: { tri: [], quad: [], bar: [], beam: [], bush: [], rbe2: [], rbe3: [] },
      loads: { force: [], pload: [], moment: [] }, // {sid,nid,cid,mag,dir:[x,y,z]}
      spc1: [], // {sid,components,nodes:[nid,...]}
      coords: new Map(), // cid -> {type, rid, nodes?, origin?, zAxisPt?, xzPlanePt?}
      bbox: null,
      properties: new Map(),
      materials: new Map(),
      preLines: [],
      postLines: [],
    };

    // ---------------- UI State & Helpers ----------------
    const selection = { nodes: new Set(), elems: new Set() };
    const hidden = { elems: new Set(), loads: new Set(), spc: new Set(), nodes: new Set() };
    let selectMode = 'node';
    let faceToElem = [];
    let lineToElem = [];
    let selectedElemLines = null;
    let highlightPoints = null;
    const propertyColorMap = new Map();
    var currentElemInput = null;
    var dragStart = null;
    var boxSelecting = false;
    var multiSelectMode = false;
    const visibility = {
        nodes: true, forces: true, moments: true, spcs: true, edges: true, coords: true,
        cquad4: true, ctria3: true, cbar: true, cbeam: true,
        cbush: true, rbe2: true, rbe3: true
    };
    const clippingPlane = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
    let clipPlaneHelper;

    let lastCameraPos = new THREE.Vector3();
    let lastCameraQuat = new THREE.Quaternion();
    const CULLING_THRESHOLD_SQUARED = 0.00001; // Small threshold to avoid floating point issues

    // --------------- UI hooks (DECLARED EARLY TO PREVENT INITIALIZATION ERRORS) ---------------
    const fileInput=document.getElementById('file'), btnSample=document.getElementById('btnSample'), btnClear=document.getElementById('btnClear'), btnReset=document.getElementById('btnReset'), btnExport=document.getElementById('btnExport'), dropzone=document.getElementById('dropzone'), statusEl=document.getElementById('status'), btnUndo = document.getElementById('btnUndo'), btnRedo = document.getElementById('btnRedo'), selNid=document.getElementById('selNid'), selX=document.getElementById('selX'), selY=document.getElementById('selY'), selZ=document.getElementById('selZ'), selCP=document.getElementById('selCP'), selCD=document.getElementById('selCD'), selGX=document.getElementById('selGX'), selGY=document.getElementById('selGY'), selGZ=document.getElementById('selGZ'), btnApplyChanges=document.getElementById('btnApplyChanges'), btnCancelChanges=document.getElementById('btnCancelChanges'), sidEl=document.getElementById('sid'), fMag=document.getElementById('fMag'), fX=document.getElementById('fX'), fY=document.getElementById('fY'), fZ=document.getElementById('fZ'), btnAddForce=document.getElementById('btnAddForce'), spcComp=document.getElementById('spcComp'), btnAddSPC=document.getElementById('btnAddSPC'), mMag=document.getElementById('mMag'), mX=document.getElementById('mX'), mY=document.getElementById('mY'), mZ=document.getElementById('mZ'), btnAddMoment=document.getElementById('btnAddMoment'), loadNodeId = document.getElementById('loadNodeId'), showNodeIds=document.getElementById('showNodeIds'), showElemIds=document.getElementById('showElemIds'), showSPCLabels=document.getElementById('showSPCLabels'), showLoadLabels=document.getElementById('showLoadLabels'), loadLabelMode=document.getElementById('loadLabelMode'), elemType = document.getElementById('elemType'), elemEid = document.getElementById('elemEid'), elemPid = document.getElementById('elemPid'), elemN1 = document.getElementById('elemN1'), elemN2 = document.getElementById('elemN2'), elemN3 = document.getElementById('elemN3'), elemN4 = document.getElementById('elemN4'), elemCm = document.getElementById('elemCm'), elemDepNodes = document.getElementById('elemDepNodes'), elemIndNodes = document.getElementById('elemIndNodes'), btnAddElement = document.getElementById('btnAddElement'), newNid=document.getElementById('newNid'), newY=document.getElementById('newY'), newZ=document.getElementById('newZ'), btnAddNode=document.getElementById('btnAddNode'), newCP = document.getElementById('newCP'), newCD = document.getElementById('newCD'), newPS = document.getElementById('newPS'), advancedNodeToggle = document.getElementById('advancedNodeToggle'), advancedNodeOptions = document.getElementById('advancedNodeOptions');
    const csysId = document.getElementById('csysId'), csysRid = document.getElementById('csysRid'), csysMethod = document.getElementById('csysMethod'), csysNodes = document.getElementById('csysNodes'), csysCoords = document.getElementById('csysCoords'), csysN1 = document.getElementById('csysN1'), csysN2 = document.getElementById('csysN2'), csysN3 = document.getElementById('csysN3'), btnAddCsys = document.getElementById('btnAddCsys');
    const modelTreeContainer=document.getElementById('modelTreeContainer'), colorMode=document.getElementById('colorMode'), selCount=document.getElementById('selCount'), btnClearSelection=document.getElementById('btnClearSelection'), selectionEditContainer=document.getElementById('selectionEditContainer'), selectRect=document.getElementById('selectRect'), multiSelectEl=document.getElementById('multiSelect'), symbolSize = document.getElementById('symbolSize'), springSize = document.getElementById('springSize'), btnApplyElemEdit = document.getElementById('btnApplyElemEdit'), btnCancelElemEdit = document.getElementById('btnCancelElemEdit'), opacitySlider = document.getElementById('opacitySlider'), shadingToggle = document.getElementById('shadingToggle'), bgColorPicker = document.getElementById('bgColor');
    const contextMenu = document.getElementById('contextMenu');
    const clippingToggle = document.getElementById('clippingToggle');
    const clipPlaneSelect = document.getElementById('clipPlaneSelect');
    const clipOffsetSlider = document.getElementById('clipOffsetSlider');
    const setClipOriginToSelection = document.getElementById('setClipOriginToSelection');
    const flipClipPlane = document.getElementById('flipClipPlane');
    const cullLabelsToggle = document.getElementById('cullLabelsToggle');
    const nodeInputs = [elemN1, elemN2, elemN3, elemN4, elemDepNodes, elemIndNodes, csysN1, csysN2, csysN3];
    const selectModeEl = document.getElementById('selectMode');

    const historyManager = {
      stack: [], pointer: -1, maxSize: 50,
      cloneState: function() { return { nodes: new Map(JSON.parse(JSON.stringify(Array.from(model.nodes)))), elems: JSON.parse(JSON.stringify(model.elems)), loads: JSON.parse(JSON.stringify(model.loads)), spc1: JSON.parse(JSON.stringify(model.spc1)), coords: new Map(JSON.parse(JSON.stringify(Array.from(model.coords)))), properties: new Map(JSON.parse(JSON.stringify(Array.from(model.properties)))), materials: new Map(JSON.parse(JSON.stringify(Array.from(model.materials)))) }; },
      recordAction: function(actionFn) { if (this.pointer < this.stack.length - 1) { this.stack.splice(this.pointer + 1); } actionFn(); this.stack.push(this.cloneState()); if (this.stack.length > this.maxSize) { this.stack.shift(); } else { this.pointer++; } updateUndoRedoButtons(); },
      undo: function() { if (this.pointer > 0) { this.pointer--; this.restoreState(this.stack[this.pointer]); } },
      redo: function() { if (this.pointer < this.stack.length - 1) { this.pointer++; this.restoreState(this.stack[this.pointer]); } },
      restoreState: function(state) {
        model.nodes=new Map(state.nodes); model.elems=JSON.parse(JSON.stringify(state.elems)); model.loads=JSON.parse(JSON.stringify(state.loads)); model.spc1=JSON.parse(JSON.stringify(state.spc1)); model.coords=new Map(state.coords); model.properties=new Map(state.properties); model.materials=new Map(state.materials);
        const nids = Array.from(model.nodes.keys()).sort((a,b)=>a-b); model.indexToNid=nids; model.nodeIndex=new Map(nids.map((nid,i)=>[nid,i]));
        buildGeometries(true); updateUndoRedoButtons();
      },
      clear: function() { this.stack = []; this.pointer = -1; this.stack.push(this.cloneState()); this.pointer = 0; updateUndoRedoButtons(); }
    };
    
    function updateOpacity() { 
        if (meshShell) { 
            const val = parseFloat(opacitySlider.value); 
            meshShell.material.opacity = val; 
            meshShell.material.transparent = val < 1.0; 
            meshShell.material.needsUpdate = true; 
        } 
    };

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [r, g, b];
    }

    function getPropColor(pid) {
      if (propertyColorMap.has(pid)) return propertyColorMap.get(pid);
      const golden = 0.618033988749895;
      const h = (pid * golden) % 1;
      const [r, g, b] = hslToRgb(h, 0.7, 0.6);
      const col = [r, g, b];
      propertyColorMap.set(pid, col);
      return col;
    }

    function resetModel() {
      model.nodes.clear();
      model.nodeIndex = new Map();
      model.indexToNid.length = 0;
      model.elems = { tri: [], quad: [], bar: [], beam: [], bush: [], rbe2: [], rbe3: [] };
      model.loads = { force: [], pload: [], moment: [] };
      model.spc1 = [];
      model.coords.clear();
      model.bbox = null;
      model.properties = new Map();
      model.materials = new Map();
      model.preLines = [];
    }

    // --------------- Parsing ---------------
    function parseTokens(line) {
      if (line.includes(',')) { // Free format
        return line.split(',').map(t => t.trim());
      }
      // Fixed format
      const toks = [];
      for (let i = 0; i < line.length; i += 8) {
        toks.push(line.slice(i, i + 8));
      }
      return toks.map(t => t.trim());
    }

    function parseBDF(text) {
        resetModel();
        const rawLines = text.split(/\r?\n/);
        const lines = [];

        // Pre-processor to handle line continuations
        for (let i = 0; i < rawLines.length; i++) {
            let currentLine = rawLines[i];
            const commentIndex = currentLine.indexOf('$');
            if (commentIndex >= 0) currentLine = currentLine.slice(0, commentIndex);
            if (currentLine.trim() === '') continue;

            // Look ahead for continuations
            while (i + 1 < rawLines.length) {
                const nextLineRaw = rawLines[i + 1];
                const commentIndexNext = nextLineRaw.indexOf('$');
                const nextLineFull = (commentIndexNext >= 0 ? nextLineRaw.slice(0, commentIndexNext) : nextLineRaw);
                const nextLineTrimLeft = nextLineFull.replace(/^\s+/, '');

                const isFree = currentLine.includes(',');
                if (isFree) {
                  const currEndsWithComma = /,\s*$/.test(currentLine);
                  const nextStartsWithComma = nextLineTrimLeft.startsWith(',');
                  if (!(currEndsWithComma || nextStartsWithComma)) break; // no continuation
                  // join: remove trailing comma from current; remove leading comma from next
                  const curr = currentLine.replace(/,\s*$/, '');
                  const next = nextLineTrimLeft.replace(/^,\s*/, '');
                  currentLine = curr + ',' + next;
                  i++; // consumed next line
                  continue;
                }

                // Fixed small-field: continuation only if '+' in column 1
                const isFixedCont = nextLineFull.startsWith('+');
                if (!isFixedCont) break;
                currentLine += nextLineFull.substring(8); // append fields after col 8
                i++; // consumed next line
            }
            lines.push(currentLine);
        }

      const asNum = (s) => (s === '' || s === undefined ? NaN : Number(s));

      for (const line of lines) {
        const tokens = parseTokens(line);
        if (!tokens.length || tokens[0] === '') continue;
        const card = tokens[0].toUpperCase();
        try {
          switch (card) {
            case 'GRID': {
              const nid = asNum(tokens[1]);
              const cp = asNum(tokens[2] || '0');
              const x = asNum(tokens[3]);
              const y = asNum(tokens[4]);
              const z = asNum(tokens[5]);
              const cd = asNum(tokens[6] || '0');
              const ps = tokens[7] || '';
              if (!isNaN(nid) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                model.nodes.set(nid, { x, y, z, cp, cd, ps });
              }
              break; }
            case 'CTRIA3': {
              const [eid,pid,n1,n2,n3] = tokens.slice(1).map(v=>parseInt(v));
              model.elems.tri.push({ eid, pid, n:[n1,n2,n3], type: 'CTRIA3' });
              break; }
            case 'CQUAD4': {
              const eid = asNum(tokens[1]), pid = asNum(tokens[2]);
              const n1 = asNum(tokens[3]), n2 = asNum(tokens[4]), n3 = asNum(tokens[5]), n4 = asNum(tokens[6]);
              const elem = { eid, pid, n:[n1,n2,n3,n4], type: 'CQUAD4' };
              const thetaMcid = asNum(tokens[7]); if (!isNaN(thetaMcid)) elem.thetaMcid = thetaMcid;
              const zoffs = asNum(tokens[8]); if (!isNaN(zoffs)) elem.zoffs = zoffs;
              const tflag = asNum(tokens[9]); if (!isNaN(tflag)) elem.tflag = tflag;
              const t1 = asNum(tokens[10]), t2 = asNum(tokens[11]), t3 = asNum(tokens[12]), t4 = asNum(tokens[13]);
              if (![t1,t2,t3,t4].every(isNaN)) elem.T = [t1,t2,t3,t4].map(v => isNaN(v) ? undefined : v);
              model.elems.quad.push(elem);
              break; }
            case 'CBAR':
            case 'CBEAM': {
              const eid = parseInt(tokens[1]);
              const pid = parseInt(tokens[2]);
              const n1 = parseInt(tokens[3]);
              const n2 = parseInt(tokens[4]);
              const key = card === 'CBAR' ? 'bar' : 'beam';
              model.elems[key].push({ eid, pid, n:[n1,n2], type: card });
              break; }
            case 'CBUSH': {
              const eid = parseInt(tokens[1]);
              const pid = parseInt(tokens[2]);
              const ga = parseInt(tokens[3]);
              const gb = parseInt(tokens[4]);
              model.elems.bush.push({ eid, pid, n:[ga,gb], type: 'CBUSH' });
              break; }
            case 'RBE2': {
              const eid = parseInt(tokens[1]);
              const gn  = parseInt(tokens[2]);
              const cm  = tokens[3] || '123456';
              const deps = tokens.slice(4).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.elems.rbe2.push({ eid, gn, cm, deps, type: 'RBE2' });
              break; }
            case 'RBE3': {
              const eid = parseInt(tokens[1]);
              const gn  = parseInt(tokens[2]);
              const cm  = tokens[3] || '123456';
              const inds = tokens.slice(4).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.elems.rbe3.push({ eid, gn, cm, inds, type: 'RBE3' });
              break; }
            case 'FORCE': {
              const sid = parseInt(tokens[1]);
              const nid = parseInt(tokens[2]);
              const cid = parseInt(tokens[3] || '0');
              const mag = Number(tokens[4]);
              const dir = [Number(tokens[5]||0), Number(tokens[6]||0), Number(tokens[7]||0)];
              model.loads.force.push({ type: 'FORCE', sid, nid, cid, mag, dir });
              break; }
            case 'MOMENT': {
              const sid = parseInt(tokens[1]);
              const nid = parseInt(tokens[2]);
              const cid = parseInt(tokens[3] || '0');
              const mag = Number(tokens[4]);
              const dir = [Number(tokens[5]||0), Number(tokens[6]||0), Number(tokens[7]||0)];
              model.loads.moment.push({ type: 'MOMENT', sid, nid, cid, mag, dir });
              break; }
            case 'PLOAD': {
              const sid = parseInt(tokens[1]);
              let pRaw = tokens[2];
              let pVal = Number(pRaw);
              if ((isNaN(pVal) || !isFinite(pVal)) && typeof pRaw === 'string') {
                const plusIndex = pRaw.indexOf('+');
                if (plusIndex > 0) {
                  const baseStr = pRaw.slice(0, plusIndex);
                  const expStr = pRaw.slice(plusIndex + 1);
                  const base = parseFloat(baseStr);
                  const exp = parseInt(expStr);
                  if (!isNaN(base) && !isNaN(exp)) {
                    pVal = base * Math.pow(10, exp);
                  }
                }
              }
              if (isNaN(pVal) || !isFinite(pVal)) pVal = 0;
              const pts = tokens.slice(3).map(t => parseInt(t)).filter(v => !isNaN(v));
              if (pts.length >= 2) {
                const nodes = pts.slice(0, 4);
                while (nodes.length < 4) nodes.push(nodes[nodes.length - 1]);
                model.loads.pload.push({ type: 'PLOAD', sid, p: pVal, nodes });
              }
              break; }
            case 'SPC1': {
              const sid = parseInt(tokens[1]);
              const comp = tokens[2];
              const nodes = tokens.slice(3).map(t=>parseInt(t)).filter(v=>!isNaN(v));
              model.spc1.push({ sid, components: comp, nodes });
              break; }
            case 'CORD2R': {
              const toInt = s => parseInt(s, 10);
              const cid = toInt(tokens[1]);
              const rid = toInt(tokens[2] || '0');
              const remaining = tokens.slice(3).filter(t => t.length > 0);

              if (remaining.length >= 9) { // Coords form
                const coords = remaining.slice(0, 9).map(Number);
                if (coords.some(isNaN)) {
                  console.warn(`Could not parse CORD2R ${cid} due to invalid coordinate numbers.`);
                } else {
                  model.coords.set(cid, { type: 'CORD2R', rid, origin: coords.slice(0,3), zAxisPt: coords.slice(3,6), xzPlanePt: coords.slice(6,9) });
                }
              } else if (remaining.length >= 3) { // Nodes form
                const nodes = remaining.slice(0, 3).map(toInt);
                if (nodes.some(isNaN)) {
                  console.warn(`Could not parse CORD2R ${cid} due to invalid node IDs.`);
                } else {
                  model.coords.set(cid, { type: 'CORD2R', rid, nodes });
                }
              } else {
                console.warn(`Could not parse CORD2R ${cid}: not enough fields.`);
              }
              break;
            }
            case 'PSHELL': {
              const pid = parseInt(tokens[1]);
              const mid = parseInt(tokens[2]);
              const t = Number(tokens[3]);
              model.properties.set(pid, { type: 'PSHELL', mid, t });
              break; }
            case 'PBAR':
            case 'PBEAM': {
              const pid = parseInt(tokens[1]);
              const mid = parseInt(tokens[2]);
              model.properties.set(pid, { type: card, mid });
              break; }
            case 'MAT1': {
              const mid = parseInt(tokens[1]);
              const e = Number(tokens[2]);
              let nu = NaN;
              if (tokens.length > 3) {
                const val = Number(tokens[3]);
                if (!isNaN(val)) nu = val;
              }
              model.materials.set(mid, { type: 'MAT1', E: e, Nu: nu });
              break; }
            default:
              model.preLines.push(line);
              break;
          }
        } catch (e) { console.warn('Parse warning:', card, line, e); }
      }

      const nids = Array.from(model.nodes.keys()).sort((a,b)=>a-b);
      model.indexToNid = nids;
      model.nodeIndex = new Map(nids.map((nid,i)=>[nid,i]));

      if (!model.bbox) {
        model.bbox = new THREE.Box3(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
    }

    // --------------- Export ---------------
    function exportBDF() {
      const pad8 = (val) => {
        let s = val === undefined || val === null ? '' : String(val);
        if (s.length > 8) s = s.slice(0, 8);
        return s.padEnd(8, ' ');
      };
      const lines = [];

      const writeContinuationCard = (cardName, fixedFields, nodeList, nodesPerFirst, nodesPerCont) => {
          const nodes = [...nodeList];
          let line = pad8(cardName);
          fixedFields.forEach(f => line += pad8(f));
          const firstLineNodes = nodes.splice(0, nodesPerFirst);
          firstLineNodes.forEach(n => line += pad8(n));
          lines.push(line.slice(0, 72));
          while(nodes.length > 0) {
              const continuationNodes = nodes.splice(0, nodesPerCont);
              let continuationLine = ' '.padEnd(8, ' ');
              continuationNodes.forEach(n => continuationLine += pad8(n));
              lines.push(continuationLine.slice(0, 72));
          }
      };

      if (model.preLines && model.preLines.length) {
        for (const l of model.preLines) lines.push(l);
      }
      for (const nid of model.indexToNid) {
        const node = model.nodes.get(nid);
        lines.push(('GRID'.padEnd(8) + pad8(nid) + pad8(node.cp ?? 0) + pad8(node.x) + pad8(node.y) + pad8(node.z) + pad8(node.cd ?? 0) + pad8(node.ps || '')).slice(0,72) );
      }
      
      const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

      for (const [cid, cs] of model.coords) {
          if (cs.type === 'CORD2R') {
              let line1 = 'CORD2R'.padEnd(8) + pad8(cid) + pad8(cs.rid || 0);
              let line2 = '+'.padEnd(8);
              let originCoords, zAxisPtCoords, xzPlanePtCoords;

              if (cs.nodes) {
                  const refTransform = globalCoordTransforms.get(cs.rid || 0) || new THREE.Matrix4();
                  const invRefTransform = refTransform.clone().invert();
                  
                  const p1Global = globalPositions.get(cs.nodes[0]);
                  const p2Global = globalPositions.get(cs.nodes[1]);
                  const p3Global = globalPositions.get(cs.nodes[2]);
                  
                  if (!p1Global || !p2Global || !p3Global) continue;

                  const p1Ref = p1Global.clone().applyMatrix4(invRefTransform);
                  const p2Ref = p2Global.clone().applyMatrix4(invRefTransform);
                  const p3Ref = p3Global.clone().applyMatrix4(invRefTransform);

                  originCoords = [p1Ref.x, p1Ref.y, p1Ref.z];
                  zAxisPtCoords = [p2Ref.x, p2Ref.y, p2Ref.z];
                  xzPlanePtCoords = [p3Ref.x, p3Ref.y, p3Ref.z];

              } else if (cs.origin) {
                  originCoords = cs.origin;
                  zAxisPtCoords = cs.zAxisPt;
                  xzPlanePtCoords = cs.xzPlanePt;
              }

              if(originCoords) {
                line1 += originCoords.map(pad8).join('');
                line1 += zAxisPtCoords.map(pad8).join('');
                lines.push(line1.slice(0, 72));
                
                line2 += xzPlanePtCoords.map(pad8).join('');
                lines.push(line2.slice(0, 72));
              }
          }
      }
      for (const e of model.elems.tri) lines.push(('CTRIA3'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1]) + pad8(e.n[2])).slice(0,72));
      
      for (const e of model.elems.quad) {
        let line1 = 'CQUAD4'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1]) + pad8(e.n[2]) + pad8(e.n[3]);
        const hasT = e.tflag !== undefined || (e.T && e.T.some(t => t !== undefined && !isNaN(t)));
        const hasAdvanced = e.thetaMcid !== undefined || e.zoffs !== undefined || hasT;
        
        if (hasAdvanced) {
            line1 += pad8(e.thetaMcid ?? '');
            line1 += pad8(e.zoffs ?? '');
            lines.push(line1.slice(0, 72));
            
            if (hasT) {
                let line2 = ' '.padEnd(8); // Continuation line
                line2 += pad8(e.tflag ?? '');
                const tVals = e.T || [];
                line2 += pad8(tVals[0] ?? '');
                line2 += pad8(tVals[1] ?? '');
                line2 += pad8(tVals[2] ?? '');
                line2 += pad8(tVals[3] ?? '');
                lines.push(line2.slice(0, 72));
            }
        } else {
            lines.push(line1.slice(0, 72));
        }
      }

      for (const e of model.elems.bar) lines.push(('CBAR'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      for (const e of model.elems.beam) lines.push(('CBEAM'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      for (const e of model.elems.bush) lines.push(('CBUSH'.padEnd(8) + pad8(e.eid) + pad8(e.pid) + pad8(e.n[0]) + pad8(e.n[1])).slice(0,72));
      
      for (const e of model.elems.rbe2) writeContinuationCard('RBE2', [e.eid, e.gn, e.cm], e.deps, 5, 8);
      for (const e of model.elems.rbe3) writeContinuationCard('RBE3', [e.eid, e.gn, e.cm], e.inds, 5, 8);
      
      for (const f of model.loads.force) lines.push(('FORCE'.padEnd(8) + pad8(f.sid) + pad8(f.nid) + pad8(f.cid ?? 0) + String(f.mag).padEnd(8) + pad8(f.dir[0]) + pad8(f.dir[1]) + pad8(f.dir[2])).slice(0,72));
      for (const m of model.loads.moment) lines.push(('MOMENT'.padEnd(8) + pad8(m.sid) + pad8(m.nid) + pad8(m.cid ?? 0) + String(m.mag).padEnd(8) + pad8(m.dir[0]) + pad8(m.dir[1]) + pad8(m.dir[2])).slice(0,72));
      for (const pl of model.loads.pload) lines.push(('PLOAD'.padEnd(8) + pad8(pl.sid) + String(pl.p).padEnd(8) + pl.nodes.map(nid=>pad8(nid)).join('')).slice(0,72));
      
      for (const s of model.spc1) {
        if (s.nodes.length) writeContinuationCard('SPC1', [s.sid, s.components], s.nodes, 6, 8);
      }

      lines.push('ENDDATA');
      const blob = new Blob([lines.join('\n')+'\n'], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'model_modified.dat'; a.click(); URL.revokeObjectURL(url);
    }
    const fmt = (v) => Number(v).toString();

    // --------------- Coordinate System Transformation ---------------
    function visualToThree(vx, vy, vz) { return new THREE.Vector3(vx, vz, -vy); }
    function threeToVisual(p) { return { x: p.x, y: -p.z, z: p.y }; }

    // --------------- Three.js setup ---------------
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.localClippingEnabled = false;
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0f1115);

    let camera, perspectiveCamera, orthographicCamera;

    perspectiveCamera = new THREE.PerspectiveCamera(45, 1, 0.01, 10000);
    perspectiveCamera.position.set(2.5, 2.2, 2.5);

    // Placeholder for ortho camera, will be configured in fitView
    const aspect = canvas.clientWidth / canvas.clientHeight;
    orthographicCamera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.01, 10000);
    orthographicCamera.position.copy(perspectiveCamera.position);
    orthographicCamera.zoom = 0.1; // Initial zoom

    camera = perspectiveCamera; // Start in perspective mode

    const controls = new OrbitControls(camera, canvas); controls.enableDamping = false; controls.rotateSpeed = 0.7;
    
    // Enhanced lighting setup for better shading
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    keyLight.position.set(5, 5, 5); // Position relative to camera
    camera.add(keyLight); // Attach light to camera
    scene.add(camera); // Make sure camera is in the scene so its children are processed

    const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
    fillLight.position.set(-5, 2, -5);
    scene.add(fillLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); // Reduced ambient
    scene.add(ambientLight);

    function makeTextSprite(message, parameters) {
        if (parameters === undefined) parameters = {};
        const fontface = parameters.fontface || 'Arial';
        const fontsize = parameters.fontsize || 24;
        const borderThickness = parameters.borderThickness || 0;
        const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 1.0 };
        const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.0 };
        const textColor = parameters.textColor || { r: 255, g: 255, b: 255, a: 1.0 };
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = "Bold " + fontsize + "px " + fontface;
        const metrics = context.measureText(message);
        const textWidth = metrics.width;
        canvas.width = textWidth + borderThickness * 2;
        canvas.height = fontsize + borderThickness * 2;
        context.font = "Bold " + fontsize + "px " + fontface;
        context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
        context.lineWidth = borderThickness;
        context.fillStyle = "rgba(" + textColor.r + "," + textColor.g + "," + textColor.b + "," + textColor.a + ")";
        context.fillText(message, borderThickness, fontsize - borderThickness);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        const spriteScale = 0.15; 
        sprite.scale.set(spriteScale * (canvas.width / fontsize), spriteScale, 1);
        return sprite;
    }

    const axesGroup = new THREE.Group();
    const axisMatX = new THREE.LineBasicMaterial({ color: 0xff4b4b });
    const axisMatY = new THREE.LineBasicMaterial({ color: 0x4bff4b });
    const axisMatZ = new THREE.LineBasicMaterial({ color: 0x4b4bff });
    const makeAxis = (dir, mat) => {
      const pts = [ new THREE.Vector3(0, 0, 0), visualToThree(dir.x, dir.y, dir.z) ];
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      return new THREE.Line(geom, mat);
    };
    axesGroup.add(makeAxis(new THREE.Vector3(1, 0, 0), axisMatX));
    axesGroup.add(makeAxis(new THREE.Vector3(0, 1, 0), axisMatY));
    axesGroup.add(makeAxis(new THREE.Vector3(0, 0, 1), axisMatZ));
    const axisLabelX = makeTextSprite("X", { fontsize: 32, textColor: { r: 255, g: 75, b: 75, a: 1.0 } });
    axisLabelX.position.copy(visualToThree(1.1, 0, 0));
    axesGroup.add(axisLabelX);
    const axisLabelY = makeTextSprite("Y", { fontsize: 32, textColor: { r: 75, g: 255, b: 75, a: 1.0 } });
    axisLabelY.position.copy(visualToThree(0, 1.1, 0));
    axesGroup.add(axisLabelY);
    const axisLabelZ = makeTextSprite("Z", { fontsize: 32, textColor: { r: 75, g: 75, b: 255, a: 1.0 } });
    axisLabelZ.position.copy(visualToThree(0, 0, 1.1));
    axesGroup.add(axisLabelZ);
    scene.add(axesGroup);
    
    const viewportEl = document.getElementById('viewport');
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    viewportEl.appendChild(labelRenderer.domElement);
    
    const compassDiv = document.getElementById('compass');
    let compassRenderer, compassScene, compassCamera, compassAxes;
    if (compassDiv) {
      compassRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      compassRenderer.setSize(compassDiv.clientWidth, compassDiv.clientHeight);
      compassRenderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      compassDiv.appendChild(compassRenderer.domElement);
      compassScene = new THREE.Scene();
      const w = compassDiv.clientWidth;
      const h = compassDiv.clientHeight;
      compassCamera = new THREE.OrthographicCamera(-w/80, w/80, h/80, -h/80, 1, 100);
      compassCamera.position.z = 2.5;
      compassCamera.lookAt(0, 0, 0);
      compassCamera.updateProjectionMatrix();
      compassAxes = new THREE.Group();
      const makeCompAxis = (dir, mat) => new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), visualToThree(dir.x, dir.y, dir.z)]), mat);
      compassAxes.add(makeCompAxis(new THREE.Vector3(0.6, 0, 0), axisMatX));
      compassAxes.add(makeCompAxis(new THREE.Vector3(0, 0.6, 0), axisMatY));
      compassAxes.add(makeCompAxis(new THREE.Vector3(0, 0, 0.6), axisMatZ));
      const compassLabelX = makeTextSprite("X", { fontsize: 48, textColor: { r: 255, g: 75, b: 75, a: 1.0 } });
      compassLabelX.position.copy(visualToThree(0.8, 0, 0));
      compassAxes.add(compassLabelX);
      const compassLabelY = makeTextSprite("Y", { fontsize: 48, textColor: { r: 75, g: 255, b: 75, a: 1.0 } });
      compassLabelY.position.copy(visualToThree(0, 0.8, 0));
      compassAxes.add(compassLabelY);
      const compassLabelZ = makeTextSprite("Z", { fontsize: 48, textColor: { r: 75, g: 75, b: 255, a: 1.0 } });
      compassLabelZ.position.copy(visualToThree(0, 0, 0.8));
      compassAxes.add(compassLabelZ);
      compassScene.add(compassAxes);
    }
    
    let meshShell = null, meshWire = null, meshLines = null, bushGroup = null, coordSysGroup = null;
    const nodeLabelGroup = new THREE.Group();
    const elemLabelGroup = new THREE.Group();
    const spcLabelGroup = new THREE.Group();
    const loadLabelGroup = new THREE.Group();
    const allLabelGroups = [nodeLabelGroup, elemLabelGroup, spcLabelGroup, loadLabelGroup];
    scene.add(nodeLabelGroup, elemLabelGroup, spcLabelGroup, loadLabelGroup);
    let points = null, selectionSphere = null;
    const forceGroup = new THREE.Group();
    const momentGroup = new THREE.Group();
    const ploadGroup = new THREE.Group();
    const spcGroup = new THREE.Group();
    scene.add(forceGroup, momentGroup, ploadGroup, spcGroup);

    function clearScene() {
      for (const obj of [meshShell, meshWire, meshLines, points, selectionSphere, highlightPoints, bushGroup, coordSysGroup, clipPlaneHelper]) { if (obj) scene.remove(obj); }
      meshShell = meshWire = meshLines = points = selectionSphere = highlightPoints = bushGroup = coordSysGroup = clipPlaneHelper = null;
      forceGroup.clear(); momentGroup.clear(); ploadGroup.clear(); spcGroup.clear();
      nodeLabelGroup.clear(); elemLabelGroup.clear(); spcLabelGroup.clear(); loadLabelGroup.clear();
    }

    function createBushSpriteMaterial() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.arc(32, 32, 28, 0, Math.PI * 2);
      ctx.strokeStyle = '#ffa657';
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(16, 32);
      ctx.lineTo(22, 26);
      ctx.lineTo(28, 38);
      ctx.lineTo(34, 26);
      ctx.lineTo(40, 38);
      ctx.lineTo(46, 26);
      ctx.lineTo(52, 32);
      ctx.lineWidth = 3;
      ctx.stroke();
      const texture = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, color: 0xffa657 });
      mat.clippingPlanes = [clippingPlane];
      return mat;
    }
    const bushMaterial = createBushSpriteMaterial();

    function createMomentArrow(origin, direction, length, color) {
        const headLength = length * 0.3; 
        const headWidth = length * 0.2;
        const arrow = new THREE.ArrowHelper(direction, origin, length, color, headLength, headWidth);
        arrow.line.material.clippingPlanes = [clippingPlane];
        arrow.cone.material.clippingPlanes = [clippingPlane];
        const cone2 = arrow.cone.clone();
        cone2.position.copy(arrow.cone.position);
        cone2.position.y -= headLength * 0.8; 
        arrow.add(cone2);
        return arrow;
    }
    
    function resolveAllTransforms() {
        const globalPositions = new Map();
        const globalCoordTransforms = new Map();

        const basicToThree = new THREE.Matrix4().makeBasis(
          new THREE.Vector3(1, 0, 0),   // Visual X -> Three.js X
          new THREE.Vector3(0, 0, -1),  // Visual Y -> Three.js -Z
          new THREE.Vector3(0, 1, 0)    // Visual Z -> Three.js Y
        );
        globalCoordTransforms.set(0, basicToThree);

        // Phase A: Seed all GRID nodes defined in the basic coordinate system
        for (const nid of model.indexToNid) {
            const n = model.nodes.get(nid);
            if ((n.cp ?? 0) === 0) {
                const p = new THREE.Vector3(n.x, n.y, n.z).applyMatrix4(basicToThree);
                globalPositions.set(nid, p);
            }
        }

        // Phase B: Iteratively resolve CORD2R systems, respecting RID dependencies
        const pending = new Set(model.coords.keys());
        let progressed = true;
        while (pending.size > 0 && progressed) {
            progressed = false;
            for (const cid of Array.from(pending)) {
                const cs = model.coords.get(cid);
                const parentTransform = globalCoordTransforms.get(cs.rid || 0);
                if (!parentTransform) continue; // Parent not resolved yet, skip for now

                let transform;
                if (cs.origin) { // Defined by coordinates
                    const A = new THREE.Vector3(...cs.origin).applyMatrix4(parentTransform);
                    const B = new THREE.Vector3(...cs.zAxisPt).applyMatrix4(parentTransform);
                    const C = new THREE.Vector3(...cs.xzPlanePt).applyMatrix4(parentTransform);
                    
                    const zDir = B.clone().sub(A).normalize();
                    const inPlane = C.clone().sub(A);
                    const xDir = inPlane.sub(zDir.clone().multiplyScalar(inPlane.dot(zDir))).normalize();
                    const yDir = new THREE.Vector3().crossVectors(zDir, xDir).normalize();
                    transform = new THREE.Matrix4().makeBasis(xDir, yDir, zDir).setPosition(A);

                } else if (cs.nodes) { // Defined by nodes
                    const p1 = globalPositions.get(cs.nodes[0]);
                    const p2 = globalPositions.get(cs.nodes[1]);
                    const p3 = globalPositions.get(cs.nodes[2]);
                    if (!p1 || !p2 || !p3) continue; // Defining nodes not resolved yet

                    const zDir = p2.clone().sub(p1).normalize();
                    const t = p3.clone().sub(p1);
                    const xDir = t.sub(zDir.clone().multiplyScalar(t.dot(zDir))).normalize();
                    const yDir = new THREE.Vector3().crossVectors(zDir, xDir).normalize();
                    transform = new THREE.Matrix4().makeBasis(xDir, yDir, zDir).setPosition(p1);
                }

                if (transform) {
                    globalCoordTransforms.set(cid, transform);
                    pending.delete(cid);
                    progressed = true;
                }
            }
        }
        
        if (pending.size > 0) {
            console.warn('Unresolved CORD2R due to cycles or missing parent RID:', Array.from(pending));
        }

        // Phase C: Resolve all remaining GRID nodes using their CP transform
        for (const nid of model.indexToNid) {
            if (globalPositions.has(nid)) continue; // Already resolved in Phase A
            const n = model.nodes.get(nid);
            const T = globalCoordTransforms.get(n.cp || 0);
            if (!T) {
                 continue;
            }
            const local = new THREE.Vector3(n.x, n.y, n.z);
            globalPositions.set(nid, local.applyMatrix4(T));
        }

        return { globalPositions, globalCoordTransforms };
    }

    function buildGeometries(preserveView = false) {
      let prevCamPos, prevTarget;
      if (preserveView) {
        prevCamPos = camera.position.clone();
        prevTarget = controls.target.clone();
      }
      clearScene();
      const N = model.indexToNid.length;
      const pos = new Float32Array(N*3);
      
      const { globalPositions, globalCoordTransforms } = resolveAllTransforms();
      
      for(let i=0; i<N; i++) {
          const nid = model.indexToNid[i];
          const gp = globalPositions.get(nid);
          if (gp) {
            pos[3*i]   = gp.x; 
            pos[3*i+1] = gp.y; 
            pos[3*i+2] = gp.z;
          } else {
            const n = model.nodes.get(nid);
            const local = new THREE.Vector3(n.x, n.y, n.z);
            const basicTransform = globalCoordTransforms.get(0) || new THREE.Matrix4().makeBasis(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,-1), new THREE.Vector3(0,1,0));
            local.applyMatrix4(basicTransform);
            pos[3*i]   = local.x; 
            pos[3*i+1] = local.y; 
            pos[3*i+2] = local.z;
          }
      }

      const bbox = new THREE.Box3();
      if (N > 0) {
          bbox.setFromArray(pos);
      } else {
          bbox.set(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
      model.bbox = bbox;

      const ptsGeom = new THREE.BufferGeometry();
      ptsGeom.setAttribute('position', new THREE.BufferAttribute(pos,3));
      points = new THREE.Points(ptsGeom, new THREE.PointsMaterial({ size: 7, sizeAttenuation: false, color: 0x66ccff, clippingPlanes: [clippingPlane] })); 
      points.visible = visibility.nodes;
      scene.add(points);

      const hlGeom = new THREE.BufferGeometry();
      hlGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
      highlightPoints = new THREE.Points(hlGeom, new THREE.PointsMaterial({ size: 12, sizeAttenuation: false, color: 0xffd166, clippingPlanes: [clippingPlane] }));
      scene.add(highlightPoints);

      const shellPositions = [], shellColors = [], shellIndices = [];
      faceToElem = [];
      const usePropColors = colorMode && colorMode.value === 'property';
      let shellVertCounter = 0;

      const processShell = (elem, isQuad) => {
        const nodes = elem.n;
        const [n1,n2,n3,n4] = nodes.map(nid=>model.nodeIndex.get(nid));
        if(nodes.some(nid=>model.nodeIndex.get(nid) === undefined)) return;
        
        let cr, cg, cb;
        if (usePropColors) { [cr,cg,cb] = getPropColor(elem.pid || 0); } 
        else { [cr,cg,cb] = [0x1f/255, 0x6f/255, 0xeb/255]; }

        const p1 = [pos[3*n1],pos[3*n1+1],pos[3*n1+2]];
        const p2 = [pos[3*n2],pos[3*n2+1],pos[3*n2+2]];
        const p3 = [pos[3*n3],pos[3*n3+1],pos[3*n3+2]];
        shellPositions.push(...p1, ...p2, ...p3);
        shellColors.push(cr,cg,cb, cr,cg,cb, cr,cg,cb);
        shellIndices.push(shellVertCounter, shellVertCounter + 1, shellVertCounter + 2);
        shellVertCounter += 3;
        faceToElem.push({ etype:elem.type, eid: elem.eid, nodes: elem.n.slice() });

        if(isQuad) {
            const p4 = [pos[3*n4],pos[3*n4+1],pos[3*n4+2]];
            shellPositions.push(...p4);
            shellColors.push(cr,cg,cb);
            shellIndices.push(shellVertCounter-3, shellVertCounter-1, shellVertCounter);
            shellVertCounter += 1;
            faceToElem.push({ etype:elem.type, eid: elem.eid, nodes: elem.n.slice() });
        }
      };

      if(visibility.ctria3) for(const e of model.elems.tri) { if(!hidden.elems.has(e.eid)) processShell(e, false); }
      if(visibility.cquad4) for(const e of model.elems.quad) { if(!hidden.elems.has(e.eid)) processShell(e, true); }
      
      if(shellPositions.length > 0) {
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.Float32BufferAttribute(shellPositions, 3));
        g.setAttribute('color', new THREE.Float32BufferAttribute(shellColors, 3));
        g.setIndex(shellIndices);
        g.computeVertexNormals();
        const useShading = shadingToggle.checked;
        const mat = useShading ? new THREE.MeshPhongMaterial({ vertexColors: true, side: THREE.DoubleSide, shininess: 25, clippingPlanes: [clippingPlane] }) : new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, clippingPlanes: [clippingPlane] });
        meshShell = new THREE.Mesh(g, mat);
        scene.add(meshShell);
        updateOpacity();

        if(visibility.edges) {
            const edgePositions = [];
            const addEdge = (n1, n2) => {
                if (n1 === undefined || n2 === undefined) return;
                edgePositions.push(pos[3*n1], pos[3*n1+1], pos[3*n1+2], pos[3*n2], pos[3*n2+1], pos[3*n2+2]);
            };
            if(visibility.ctria3) for(const e of model.elems.tri) { if(!hidden.elems.has(e.eid)) { const [n1, n2, n3] = e.n.map(nid => model.nodeIndex.get(nid)); addEdge(n1, n2); addEdge(n2, n3); addEdge(n3, n1); }}
            if(visibility.cquad4) for(const e of model.elems.quad) { if(!hidden.elems.has(e.eid)) { const [n1, n2, n3, n4] = e.n.map(nid => model.nodeIndex.get(nid)); addEdge(n1, n2); addEdge(n2, n3); addEdge(n3, n4); addEdge(n4, n1); }}
            if(edgePositions.length > 0) {
                const edgeGeom = new THREE.BufferGeometry();
                edgeGeom.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
                meshWire = new THREE.LineSegments(edgeGeom, new THREE.LineBasicMaterial({ color: 0x000000, clippingPlanes: [clippingPlane] }));
                scene.add(meshWire);
            }
        }
      }

      lineToElem = [];
      const linePos = [], lineColor = [];
      const cbarColor = {r:0.9, g:0.9, b:0.9}, cbeamColor = {r:0.6, g:0.6, b:1.0}, cbushColor = {r:0xff/255, g:0xa6/255, b:0x57/255}, rbe2Color = {r:0x58/255, g:0xa6/255, b:0xff/255}, rbe3Color = {r:0xff/255, g:0xa6/255, b:0x57/255};
      const addLineSegment = (n1, n2, color, elemData) => {
        const i0 = model.nodeIndex.get(n1), i1 = model.nodeIndex.get(n2);
        if (i0 === undefined || i1 === undefined) return;
        linePos.push(pos[3*i0],pos[3*i0+1],pos[3*i0+2], pos[3*i1],pos[3*i1+1],pos[3*i1+2]);
        lineColor.push(color.r, color.g, color.b, color.r, color.g, color.b);
        lineToElem.push(elemData);
      };

      if(visibility.cbar) for (const e of model.elems.bar) { if (!hidden.elems.has(e.eid)) addLineSegment(e.n[0], e.n[1], cbarColor, { etype: e.type, eid: e.eid, nodes: e.n.slice() }); }
      if(visibility.cbeam) for (const e of model.elems.beam) { if (!hidden.elems.has(e.eid)) addLineSegment(e.n[0], e.n[1], cbeamColor, { etype: e.type, eid: e.eid, nodes: e.n.slice() }); }
      if(visibility.rbe2) for (const e of model.elems.rbe2) { if (!hidden.elems.has(e.eid)) for (const dep of e.deps) addLineSegment(e.gn, dep, rbe2Color, { etype: 'RBE2', eid: e.eid, nodes: [e.gn, ...e.deps] }); }
      if(visibility.rbe3) for (const e of model.elems.rbe3) { if (!hidden.elems.has(e.eid)) for (const ind of e.inds) addLineSegment(e.gn, ind, rbe3Color, { etype: 'RBE3', eid: e.eid, nodes: [e.gn, ...e.inds] }); }
      if(visibility.cbush) for (const b of model.elems.bush) { if (!hidden.elems.has(b.eid)) addLineSegment(b.n[0], b.n[1], cbushColor, { etype: b.type, eid: b.eid, nodes: b.n.slice() }); }
      
      if (linePos.length > 0) {
        const lg = new THREE.BufferGeometry();
        lg.setAttribute('position', new THREE.Float32BufferAttribute(linePos,3));
        lg.setAttribute('color', new THREE.Float32BufferAttribute(lineColor,3));
        meshLines = new THREE.LineSegments(lg, new THREE.LineBasicMaterial({ vertexColors: true, clippingPlanes: [clippingPlane] }));
        scene.add(meshLines);
      }
      
      if(visibility.cbush) {
        bushGroup = new THREE.Group();
        for (const b of model.elems.bush) {
            if (hidden.elems.has(b.eid)) continue;
            const p1 = nodePosition(model.nodeIndex.get(b.n[0]));
            const p2 = nodePosition(model.nodeIndex.get(b.n[1]));
            if(!p1 || !p2) continue;
            const bushSprite = new THREE.Sprite(bushMaterial);
            bushSprite.position.copy(p1).add(p2).multiplyScalar(0.5);
            const scale = 0.025 * Number(springSize.value || 1.0);
            bushSprite.scale.set(scale, scale, 1);
            bushSprite.userData = { etype: 'CBUSH', eid: b.eid, nodes: b.n.slice() };
            bushGroup.add(bushSprite);
        }
        if(bushGroup.children.length > 0) scene.add(bushGroup);
      }
      
      clipPlaneHelper = new THREE.PlaneHelper(clippingPlane, model.bbox.getSize(new THREE.Vector3()).length(), 0xffffff);
      if (clippingToggle.checked) scene.add(clipPlaneHelper);

      drawOverlays(globalPositions, globalCoordTransforms);
      if (!preserveView) { fitView(); } 
      else { camera.position.copy(prevCamPos); controls.target.copy(prevTarget); controls.update(); }
      
      refreshCounts();
      if (typeof populateModelTree === 'function') populateModelTree();
      updateSelectionVisual();
      highlightSelectedElementVisual();
      updateSelectionUI();
    }

    function drawOverlays(globalPositions, globalCoordTransforms) {
      forceGroup.clear(); momentGroup.clear(); ploadGroup.clear(); spcGroup.clear();
      if(coordSysGroup) coordSysGroup.clear(); else coordSysGroup = new THREE.Group();
      
      for (const f of model.loads.force) {
        if (hidden.loads.has(f)) continue;
        const p = globalPositions.get(f.nid);
        if (!p) continue;
        const dir = visualToThree(f.dir[0], f.dir[1], f.dir[2]).normalize();
        if (dir.lengthSq() === 0) continue;
        const arrowLength = 1.0;
        const arrow = new THREE.ArrowHelper(dir, p, arrowLength, 0xffa500, arrowLength * 0.3, arrowLength * 0.2);
        arrow.line.material.clippingPlanes = [clippingPlane];
        arrow.cone.material.clippingPlanes = [clippingPlane];
        arrow.userData = { type: 'load', data: f, isStaticSymbol: true, baseScale: 2.5 };
        arrow.children.forEach(c => { c.userData = arrow.userData; c.renderOrder = 999; });
        forceGroup.add(arrow);
      }
      
      for (const m of model.loads.moment) {
        if (hidden.loads.has(m)) continue;
        const p = globalPositions.get(m.nid);
        if (!p) continue;
        const dir = visualToThree(m.dir[0], m.dir[1], m.dir[2]).normalize();
        if (dir.lengthSq() === 0) continue;
        const arrowLength = 1.0;
        const arrow = createMomentArrow(p, dir, arrowLength, 0x9b59b6);
        arrow.userData = { type: 'load', data: m, isStaticSymbol: true, baseScale: 4.125 };
        arrow.children.forEach(c => c.userData = arrow.userData);
        momentGroup.add(arrow);
      }

      if (Array.isArray(model.loads.pload)) {
        for (const pl of model.loads.pload) {
          if (hidden.loads.has(pl)) continue;
          const pts = pl.nodes.map(nid => globalPositions.get(nid)).filter(Boolean);
          if (pts.length !== pl.nodes.length) continue;
          const centroid = new THREE.Vector3();
          for (const pt of pts) centroid.add(pt);
          centroid.divideScalar(pts.length);
          let normal = new THREE.Vector3(0,0,1);
          if (pts.length >= 3) {
            const v1 = new THREE.Vector3().subVectors(pts[1], pts[0]);
            const v2 = new THREE.Vector3().subVectors(pts[pts.length - 1], pts[0]);
            normal.crossVectors(v1, v2).normalize();
            if (normal.lengthSq() < 1e-8) normal.set(0,0,1);
          }
          const arrowLength = 1.0;
          const arrow = new THREE.ArrowHelper(normal, centroid, arrowLength, 0xff77aa, arrowLength * 0.3, arrowLength * 0.2);
          arrow.line.material.clippingPlanes = [clippingPlane];
          arrow.cone.material.clippingPlanes = [clippingPlane];
          arrow.userData = { type: 'load', data: pl, isStaticSymbol: true, baseScale: 2.5 };
          arrow.children.forEach(c => c.userData = arrow.userData);
          ploadGroup.add(arrow);
        }
      }

      for (const s1 of model.spc1) {
        for (const nid of s1.nodes) {
          const p = globalPositions.get(nid);
          if (!p) continue;
          const key = s1.sid + ':' + nid;
          if (hidden.spc.has(key)) continue;
          const pyramidSize = 1.0;
          const pyramidHeight = pyramidSize * 1.2;
          const pyramidGeom = new THREE.ConeGeometry(pyramidSize, pyramidHeight, 4);
          pyramidGeom.translate(0, -pyramidHeight / 2, 0); 
          const pyramid = new THREE.Mesh(pyramidGeom, new THREE.MeshPhongMaterial({ color: 0x7ee787, clippingPlanes: [clippingPlane] }));
          pyramid.position.copy(p);
          pyramid.userData = { type:'spc', data:{ sid:s1.sid, components:s1.components, nid:nid }, key: key, isStaticSymbol: true, baseScale: 1.0 };
          spcGroup.add(pyramid);
        }
      }

      for (const [cid, transform] of globalCoordTransforms) {
          if (cid === 0) continue;
          if (!transform) continue;
          const origin = new THREE.Vector3().setFromMatrixPosition(transform);
          const xAxis = new THREE.Vector3().setFromMatrixColumn(transform, 0).normalize();
          const yAxis = new THREE.Vector3().setFromMatrixColumn(transform, 1).normalize();
          const zAxis = new THREE.Vector3().setFromMatrixColumn(transform, 2).normalize();
          const length = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() : 1) * 0.05;
          coordSysGroup.add(new THREE.ArrowHelper(xAxis, origin, length, 0xff4b4b));
          coordSysGroup.add(new THREE.ArrowHelper(yAxis, origin, length, 0x4bff4b));
          coordSysGroup.add(new THREE.ArrowHelper(zAxis, origin, length, 0x4b4bff));
      }
      scene.add(coordSysGroup);

      forceGroup.visible = visibility.forces;
      momentGroup.visible = visibility.moments;
      ploadGroup.visible = visibility.forces;
      spcGroup.visible = visibility.spcs;
      coordSysGroup.visible = visibility.coords;
      rebuildLabels();
    }

    // ---- Labels ----
    function clearGroup(g){ while(g.children.length > 0) { const child = g.children[0]; g.remove(child); } }
    function makeLabel(text, cls=''){ const el=document.createElement('div'); el.className='label '+cls; el.textContent=text; return new CSS2DObject(el); }
    function rebuildLabels(){ 
      allLabelGroups.forEach(clearGroup);
      const checked = { nodes: showNodeIds.checked, elems: showElemIds.checked, spcs: showSPCLabels.checked, loads: showLoadLabels.checked };
      if (!points) return; 
      if (checked.nodes) buildNodeLabels(); 
      if (checked.elems) buildElemLabels(); 
      if (checked.spcs) buildSPCLabels(); 
      if (checked.loads) buildLoadLabels(); 
    }
    function buildNodeLabels(){ for (let i=0;i<model.indexToNid.length;i++){ const nid=model.indexToNid[i]; const p=nodePosition(i); const lbl=makeLabel(String(nid),'muted'); lbl.position.copy(p); nodeLabelGroup.add(lbl);} }
    function centroidOf(ids){ const v=new THREE.Vector3(); let n=0; for (const nid of ids){ const idx=model.nodeIndex.get(nid); if (idx===undefined) continue; v.add(nodePosition(idx)); n++; } if (n>0) v.multiplyScalar(1/n); return v; }
    function midOf(n1,n2){ const a=nodePosition(model.nodeIndex.get(n1)); const b=nodePosition(model.nodeIndex.get(n2)); return a.add(b).multiplyScalar(0.5); }
    function buildElemLabels(){ for (const e of model.elems.tri){ const c=centroidOf(e.n); const l=makeLabel(String(e.eid)); l.position.copy(c); elemLabelGroup.add(l);} for (const e of model.elems.quad){ const c=centroidOf(e.n); const l=makeLabel(String(e.eid)); l.position.copy(c); elemLabelGroup.add(l);} for (const e of model.elems.bar){ const c=midOf(e.n[0],e.n[1]); const l=makeLabel(String(e.eid)); l.position.copy(c); elemLabelGroup.add(l);} for (const e of model.elems.beam){ const c=midOf(e.n[0],e.n[1]); const l=makeLabel(String(e.eid)); l.position.copy(c); elemLabelGroup.add(l);} for (const e of model.elems.bush){ const c=midOf(e.n[0],e.n[1]); const l=makeLabel(String(e.eid)); l.position.copy(c); elemLabelGroup.add(l);} for (const e of model.elems.rbe2){ const idx=model.nodeIndex.get(e.gn); if (idx!==undefined){ const p=nodePosition(idx); const l=makeLabel(String(e.eid)); l.position.copy(p); elemLabelGroup.add(l);} } for (const e of model.elems.rbe3){ const idx=model.nodeIndex.get(e.gn); if (idx!==undefined){ const p=nodePosition(idx); const l=makeLabel(String(e.eid)); l.position.copy(p); elemLabelGroup.add(l);} } }
    function buildSPCLabels(){ for (const s of model.spc1){ for (const nid of s.nodes){ const idx=model.nodeIndex.get(nid); if (idx===undefined) continue; const p=nodePosition(idx); const l=makeLabel('SID '+s.sid+' '+s.components,'muted'); l.position.copy(p.clone()); spcLabelGroup.add(l);} } }
    function buildLoadLabels() {
      const staticScale = Number(symbolSize.value || 1.0);
      const allLoads = [...model.loads.force, ...model.loads.moment, ...model.loads.pload];
      for (const load of allLoads) {
        if(hidden.loads.has(load)) continue;
        let tip, txt;
        const mode = loadLabelMode.value;
        const dist = camera.position.distanceTo(controls.target);
        let arrowLength = dist * 0.01 * staticScale * (load.type === 'MOMENT' ? 4.125 : 2.5);
        if (load.type === 'FORCE' || load.type === 'MOMENT') {
            const idx = model.nodeIndex.get(load.nid); if (idx === undefined) continue;
            const p = nodePosition(idx);
            const d = visualToThree(load.dir[0], load.dir[1], load.dir[2]).normalize(); if (d.lengthSq() === 0) continue;
            tip = p.clone().add(d.clone().multiplyScalar(arrowLength * 1.1));
            if (mode === 'components') { const [dx, dy, dz] = load.dir; txt = `${load.type[0]}x ${(load.mag * dx).toPrecision(3)}, ${load.type[0]}y ${(load.mag * dy).toPrecision(3)}, ${load.type[0]}z ${(load.mag * dz).toPrecision(3)}`; } 
            else { txt = `${load.type[0]} ${load.mag}`; }
        } else if (load.type === 'PLOAD') {
          const indices = load.nodes.map(nid => model.nodeIndex.get(nid)); if (indices.some(idx => idx === undefined)) continue;
          const centroid = new THREE.Vector3();
          for (const i of indices) centroid.add(nodePosition(i));
          centroid.divideScalar(indices.length);
          let normal = new THREE.Vector3(0, 0, 1);
          if (indices.length >= 3) { const p0=nodePosition(indices[0]), p1=nodePosition(indices[1]), p2=nodePosition(indices[indices.length-1]); normal.crossVectors(new THREE.Vector3().subVectors(p1, p0), new THREE.Vector3().subVectors(p2, p0)).normalize(); }
          tip = centroid.clone().add(normal.clone().multiplyScalar(arrowLength * 1.1));
          txt = 'P ' + load.p;
        }
        if(tip && txt) { const l = makeLabel(txt); l.position.copy(tip); loadLabelGroup.add(l); }
      }
    }

    function nodePosition(idx){
      if (!points || !points.geometry || !points.geometry.attributes || !points.geometry.attributes.position) {
        const nid = model.indexToNid[idx];
        const n = model.nodes.get(nid);
        if (n) return visualToThree(n.x, n.y, n.z);
        return new THREE.Vector3(0, 0, 0);
      }
      const pos = points.geometry.attributes.position;
      return new THREE.Vector3(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
    }
    function setNodePosition(idx, tx, ty, tz) {
      const pos = points.geometry.attributes.position;
      pos.setXYZ(idx, tx, ty, tz);
      pos.needsUpdate = true;
      buildGeometries(true);
      recomputeBBox();
    }
function recomputeBBox(){
      let min = new THREE.Vector3(+Infinity,+Infinity,+Infinity);
      let max = new THREE.Vector3(-Infinity,-Infinity,-Infinity);
      if (points && points.geometry && points.geometry.attributes && points.geometry.attributes.position) {
        const posAttr = points.geometry.attributes.position;
        const v = new THREE.Vector3();
        for (let i=0; i<posAttr.count; i++) {
          v.set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
          min.min(v);
          max.max(v);
        }
      } else {
        for (const node of model.nodes.values()) {
          const p = visualToThree(node.x, node.y, node.z);
          min.min(p);
          max.max(p);
        }
      }
      if (isFinite(min.x) && isFinite(min.y) && isFinite(min.z) &&
          isFinite(max.x) && isFinite(max.y) && isFinite(max.z)) {
        model.bbox = new THREE.Box3(min, max);
      } else if (!model.bbox) {
        model.bbox = new THREE.Box3(new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,1,1));
      }
      if (typeof axesHelper !== 'undefined' && axesHelper && model.bbox) {
        const sizeVec = model.bbox.getSize(new THREE.Vector3());
        const diag = sizeVec.length();
        const scale = diag > 0 ? diag * 0.15 : 1;
        axesHelper.scale.setScalar(scale);
        axesHelper.position.set(0, 0, 0);
      }
    }

    function fitView(){
        const box=model.bbox||new THREE.Box3(new THREE.Box3(-1,-1,-1), new THREE.Vector3(1,1,1));
        const size=box.getSize(new THREE.Vector3()).length()||1;
        const center=box.getCenter(new THREE.Vector3());

        // Update controls target
        controls.target.copy(center);

        // Update perspective camera
        perspectiveCamera.near=size/100;
        perspectiveCamera.far=size*100;
        perspectiveCamera.position.copy(center.clone().add(new THREE.Vector3(size,size,size)));
        perspectiveCamera.updateProjectionMatrix();

        // Update orthographic camera
        const aspect = canvas.clientWidth / canvas.clientHeight;
        orthographicCamera.near = size / 100;
        orthographicCamera.far = size * 100;
        orthographicCamera.position.copy(perspectiveCamera.position); // Match positions
        const camDistance = orthographicCamera.position.distanceTo(center);
        const h = camDistance / 2; // Heuristic for frustum size
        orthographicCamera.left = -h * aspect;
        orthographicCamera.right = h * aspect;
        orthographicCamera.top = h;
        orthographicCamera.bottom = -h;
        orthographicCamera.zoom = 1.0; // Reset zoom
        orthographicCamera.updateProjectionMatrix();

        controls.update();
    }

    function updateSelectionVisual() {
      if (!highlightPoints) return;
      const arr = [];
      if (selectMode === 'node') {
        for (const nid of selection.nodes) {
          const idx = model.nodeIndex.get(nid);
          if (idx !== undefined) {
            const p = nodePosition(idx);
            arr.push(p.x, p.y, p.z);
          }
        }
      }
      highlightPoints.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(arr), 3));
      highlightPoints.geometry.setDrawRange(0, arr.length / 3);
      if (highlightPoints.geometry.attributes.position) highlightPoints.geometry.attributes.position.needsUpdate = true;
      highlightPoints.visible = (selectMode === 'node') && arr.length > 0;
    }

    function highlightSelectedElementVisual() {
      if (selectedElemLines) {
        scene.remove(selectedElemLines);
        if (selectedElemLines.geometry) selectedElemLines.geometry.dispose();
        if (selectedElemLines.material) selectedElemLines.material.dispose();
        selectedElemLines = null;
      }
      const sel = Array.from(selection.elems);
      if (sel.length === 0) return;
      const positions = [];
      const allElems = [...model.elems.tri, ...model.elems.quad, ...model.elems.bar, ...model.elems.beam, ...model.elems.bush, ...model.elems.rbe2, ...model.elems.rbe3];

      for (const eid of sel) {
        const foundElem = allElems.find(e => e.eid === eid);
        if (!foundElem) continue;
        
        if (foundElem.type === 'RBE2' || foundElem.type === 'RBE3') {
            const depNodes = foundElem.deps || foundElem.inds;
            for (const depNid of depNodes) {
                const p0 = nodePosition(model.nodeIndex.get(foundElem.gn));
                const p1 = nodePosition(model.nodeIndex.get(depNid));
                if(p0 && p1) positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
        } else {
            const nodes = foundElem.n;
            for (let i = 0; i < nodes.length; i++) {
                const idx0 = model.nodeIndex.get(nodes[i]);
                const idx1 = model.nodeIndex.get(nodes[(i + 1) % nodes.length]);
                if (idx0 === undefined || idx1 === undefined) continue;
                const p0 = nodePosition(idx0);
                const p1 = nodePosition(idx1);
                positions.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);
            }
        }
      }

      if (positions.length > 0) {
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        selectedElemLines = new THREE.LineSegments(geom, new THREE.LineBasicMaterial({ color: 0xffd166, linewidth: 3 }));
        scene.add(selectedElemLines);
      }
    }

    function updateSelectionUI() {
      const editElemCard = document.getElementById('editElementCard');
      const measureContainer = document.getElementById('measureResultsContainer');
      const selectionEditContainer = document.getElementById('selectionEditContainer');
      const btnCopySelectedNode = document.getElementById('btnCopySelectedNode');

      if (btnCopySelectedNode) {
          btnCopySelectedNode.disabled = !(selectMode === 'node' && selection.nodes.size === 1);
      }

      if (selCount) {
        const n = selection.nodes.size;
        const m = selection.elems.size;
        if (n === 0 && m === 0) selCount.textContent = 'None';
        else if (m === 0) selCount.textContent = n + ' node' + (n === 1 ? '' : 's');
        else if (n === 0) selCount.textContent = m + ' element' + (m === 1 ? '' : 's');
        else selCount.textContent = n + ' nodes, ' + m + ' elements';
      }

      const showNodeEdit = (selectMode === 'node' && selection.nodes.size > 0);
      selectionEditContainer.style.display = showNodeEdit ? '' : 'none';
      if (showNodeEdit) {
        const selNodes = Array.from(selection.nodes);
        if (selNodes.length === 1) {
          const nid = selNodes[0];
          const node = model.nodes.get(nid);
          const idx = model.nodeIndex.get(nid);

          if (node && idx !== undefined) {
            selNid.value = String(nid);
            selX.value = node.x; selY.value = node.y; selZ.value = node.z;
            
            const globalPos = threeToVisual(nodePosition(idx));
            selGX.value = globalPos.x.toPrecision(5);
            selGY.value = globalPos.y.toPrecision(5);
            selGZ.value = globalPos.z.toPrecision(5);

            selCP.value = node.cp || 0; selCD.value = node.cd || 0;
            selNid.disabled = true; 
            selX.disabled = false; selY.disabled = false; selZ.disabled = false;
          }
        } else { // Multi-select
            selNid.value = 'Multiple'; selX.value = ''; selY.value = ''; selZ.value = '';
            selGX.value = ''; selGY.value = ''; selGZ.value = '';
            selNid.disabled = true; selX.disabled = true; selY.disabled = true; selZ.disabled = true;
            
            const firstNode = model.nodes.get(selNodes[0]);
            const sameCP = selNodes.every(nid => (model.nodes.get(nid).cp || 0) === (firstNode.cp || 0));
            const sameCD = selNodes.every(nid => (model.nodes.get(nid).cd || 0) === (firstNode.cd || 0));
            selCP.value = sameCP ? (firstNode.cp || 0) : '';
            selCP.placeholder = sameCP ? '' : 'Multiple Values';
            selCD.value = sameCD ? (firstNode.cd || 0) : '';
            selCD.placeholder = sameCD ? '' : 'Multiple Values';
        }
      }

      const showElemEdit = (selectMode === 'element' && selection.elems.size === 1);
      editElemCard.style.display = showElemEdit ? '' : 'none';
      if (showElemEdit) {
        const eid = Array.from(selection.elems)[0];
        let elem;
        for (const type in model.elems) {
          const found = model.elems[type].find(e => e.eid === eid);
          if (found) { elem = found; break; }
        }
        if (elem) {
          document.getElementById('editEid').value = elem.eid;
          document.getElementById('editPid').value = elem.pid;
          const nodeFields = [ document.getElementById('editN1'), document.getElementById('editN2'), document.getElementById('editN3'), document.getElementById('editN4') ];
          nodeFields.forEach((nf, i) => {
            if (elem.n && i < elem.n.length) { nf.value = elem.n[i]; nf.parentElement.style.display = ''; } 
            else { nf.value = ''; nf.parentElement.style.display = 'none'; }
          });
          const advFields = document.getElementById('editCquad4AdvancedOptions');
          if (elem.type === 'CQUAD4') {
            advFields.style.display = '';
            document.getElementById('editThetaMcid').value = elem.thetaMcid ?? '';
            document.getElementById('editZoffs').value = elem.zoffs ?? '';
            document.getElementById('editTflag').value = elem.tflag ?? '';
            const t = elem.T || [];
            document.getElementById('editT1').value = t[0] ?? '';
            document.getElementById('editT2').value = t[1] ?? '';
            document.getElementById('editT3').value = t[2] ?? '';
            document.getElementById('editT4').value = t[3] ?? '';
          } else {
            advFields.style.display = 'none';
          }
        }
      }
      
      if (selectMode === 'node' && selection.nodes.size === 2) {
          const [nid1, nid2] = Array.from(selection.nodes);
          const idx1 = model.nodeIndex.get(nid1);
          const idx2 = model.nodeIndex.get(nid2);

          if (idx1 !== undefined && idx2 !== undefined) {
              const n1 = nodePosition(idx1);
              const n2 = nodePosition(idx2);
              const v1 = threeToVisual(n1);
              const v2 = threeToVisual(n2);
              const dx = v2.x - v1.x, dy = v2.y - v1.y, dz = v2.z - v1.z;
              const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
              document.getElementById('measureResults').innerHTML = `<div class="row" style="margin-bottom:4px"><label style="width:auto">Nodes:</label><span>${nid1} to ${nid2}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔX:</label><span>${dx.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔY:</label><span>${dy.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">ΔZ:</label><span>${dz.toPrecision(4)}</span></div><div class="row" style="margin-bottom:4px"><label style="width:auto">Distance:</label><span><b>${dist.toPrecision(5)}</b></span></div>`;
              measureContainer.style.display = 'block';
          }
      } else {
          measureContainer.style.display = 'none';
      }
    }

    function populateModelTree() {
      if (!modelTreeContainer) return;
      modelTreeContainer.innerHTML = '';
      const root = document.createElement('ul');
      const nodesLi = document.createElement('li');
      nodesLi.textContent = 'Nodes (' + model.indexToNid.length + ')';
      nodesLi.addEventListener('click', (ev) => { ev.stopPropagation(); selection.nodes = new Set(model.indexToNid); selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(nodesLi);
      
      const totalElems = Object.values(model.elems).reduce((sum, arr) => sum + arr.length, 0);
      const elemsLi = document.createElement('li');
      elemsLi.textContent = 'Elements (' + totalElems + ')';
      const elemSub = document.createElement('ul');
      function addElemType(name, arr) {
        if (arr.length === 0) return;
        const li = document.createElement('li');
        li.textContent = name + ' (' + arr.length + ')';
        li.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const s = new Set();
          for (const e of arr) {
            const nodes = e.n || [e.gn, ...(e.deps || e.inds)];
            for (const nid of nodes) s.add(nid);
          }
          selection.nodes = s;
          selection.elems.clear();
          updateSelectionVisual();
          updateSelectionUI();
        });
        elemSub.appendChild(li);
      }
      addElemType('CTRIA3', model.elems.tri); addElemType('CQUAD4', model.elems.quad); addElemType('CBAR', model.elems.bar); addElemType('CBEAM', model.elems.beam); addElemType('CBUSH', model.elems.bush); addElemType('RBE2', model.elems.rbe2); addElemType('RBE3', model.elems.rbe3);
      elemsLi.appendChild(elemSub);
      elemsLi.addEventListener('click', (ev) => { if (ev.target === elemsLi) elemsLi.classList.toggle('open'); ev.stopPropagation(); });
      root.appendChild(elemsLi);

      const totalLoads = (model.loads.force?.length || 0) + (model.loads.pload?.length || 0) + (model.loads.moment?.length || 0);
      const loadsLi = document.createElement('li');
      loadsLi.textContent = 'Loads (' + totalLoads + ')';
      loadsLi.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); if (model.loads.force) for (const f of model.loads.force) s.add(f.nid); if (model.loads.moment) for (const m of model.loads.moment) s.add(m.nid); if (model.loads.pload) for (const pl of model.loads.pload) for (const nid of pl.nodes) s.add(nid); selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(loadsLi);
      
      const spcCount = model.spc1.reduce((sum, grp) => sum + grp.nodes.length, 0);
      const spcLi = document.createElement('li');
      spcLi.textContent = 'SPC1 (' + spcCount + ')';
      spcLi.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); for (const grp of model.spc1) { for (const nid of grp.nodes) s.add(nid); } selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
      root.appendChild(spcLi);
      
      if (model.coords.size > 0) {
        const coordsLi = document.createElement('li');
        coordsLi.textContent = 'Coord Sys ('+model.coords.size+')';
        const coordsSub = document.createElement('ul');
        for (const [cid, cs] of model.coords) {
          const li = document.createElement('li');
          li.textContent = cs.type + ' ' + cid;
          li.addEventListener('click', (ev) => { ev.stopPropagation(); if(cs.nodes) selection.nodes = new Set(cs.nodes); selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
          coordsSub.appendChild(li);
        }
        coordsLi.appendChild(coordsSub);
        coordsLi.addEventListener('click', (ev) => { if (ev.target === coordsLi) coordsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(coordsLi);
      }

      if (model.properties.size > 0) {
        const propsLi = document.createElement('li');
        propsLi.textContent = 'Properties (' + model.properties.size + ')';
        const propsSub = document.createElement('ul');
        for (const [pid, prop] of model.properties) {
          const li = document.createElement('li');
          li.textContent = prop.type + ' ' + pid;
          li.addEventListener('click', (ev) => { ev.stopPropagation(); const s = new Set(); for (const t of Object.keys(model.elems)) { for (const e of model.elems[t]) { if (e.pid === pid) { const nodes = e.n || [e.gn, ...(e.deps || e.inds)]; for (const nid of nodes) s.add(nid); } } } selection.nodes = s; selection.elems.clear(); updateSelectionVisual(); updateSelectionUI(); });
          propsSub.appendChild(li);
        }
        propsLi.appendChild(propsSub);
        propsLi.addEventListener('click', (ev) => { if (ev.target === propsLi) propsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(propsLi);
      }
      
      if (model.materials.size > 0) {
        const matsLi = document.createElement('li');
        matsLi.textContent = 'Materials (' + model.materials.size + ')';
        const matsSub = document.createElement('ul');
        for (const [mid, mat] of model.materials) { const li = document.createElement('li'); li.textContent = 'MAT1 ' + mid; matsSub.appendChild(li); }
        matsLi.appendChild(matsSub);
        matsLi.addEventListener('click', (ev) => { if (ev.target === matsLi) matsLi.classList.toggle('open'); ev.stopPropagation(); });
        root.appendChild(matsLi);
      }
      modelTreeContainer.appendChild(root);
    }

    // --------------- Interaction ---------------
    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let selectedIdx = -1;

    function onClick(ev) {
      if (ev.altKey || boxSelecting) return;
      if (contextMenu && contextMenu.style.display === 'block') { contextMenu.style.display = 'none'; return; }
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (selectMode === 'node') {
        if (!points || !model.indexToNid.length) return;
        raycaster.params.Points.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.005 : 0.1);
        let indexHit = -1;
        const hits = raycaster.intersectObject(points);
        if (hits.length) { indexHit = hits[0].index; } 
        else {
          const rectCanvas = canvas.getBoundingClientRect();
          const cx = ev.clientX - rectCanvas.left, cy = ev.clientY - rectCanvas.top;
          let bestDist = Infinity;
          for (let i = 0; i < model.indexToNid.length; i++) {
            const p3 = nodePosition(i).clone().project(camera);
            const sx = (p3.x * 0.5 + 0.5) * rectCanvas.width;
            const sy = (-p3.y * 0.5 + 0.5) * rectCanvas.height;
            const d = Math.hypot(sx - cx, sy - cy);
            if (d < bestDist) { bestDist = d; indexHit = i; }
          }
          if (bestDist > 16) indexHit = -1;
        }
        if (indexHit >= 0) {
          const nid = model.indexToNid[indexHit];
          selectNode(indexHit);
          if (currentElemInput) {
            currentElemInput.value = String(nid);
            const order = [elemN1, elemN2, elemN3, elemN4, csysN1, csysN2, csysN3];
            const idxInput = order.indexOf(currentElemInput);
            if (idxInput >= 0) {
              let nextIndex = idxInput + 1;
              while (nextIndex < order.length && order[nextIndex]?.parentElement.style.display === 'none') nextIndex++;
              if (nextIndex < order.length && order[nextIndex]?.parentElement.style.display !== 'none') { currentElemInput = order[nextIndex]; order[nextIndex].focus(); } 
              else { currentElemInput = null; }
            } else { currentElemInput = null; }
          }
          if (multiSelectMode) { if (selection.nodes.has(nid)) selection.nodes.delete(nid); else selection.nodes.add(nid); } 
          else { selection.nodes = new Set([nid]); selection.elems.clear(); }
          updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI();
        }
      } else if (selectMode === 'element') {
        raycaster.params.Line.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.01 : 0.1);
        const intersectable = [meshShell, meshLines, bushGroup].filter(o => o && o.visible);
        const hits = raycaster.intersectObjects(intersectable, true);
        if (hits.length > 0) {
            let hitData;
            const hit = hits[0];
            if (hit.object.type === 'Sprite') { hitData = hit.object.userData; } 
            else if (hit.object === meshShell) { hitData = faceToElem[hit.faceIndex]; } 
            else if (hit.object === meshLines) { hitData = lineToElem[hit.faceIndex]; }
            if (hitData) {
              const { eid, nodes } = hitData;
              if (multiSelectMode) { if (selection.elems.has(eid)) { selection.elems.delete(eid); } else { selection.elems.add(eid); } } 
              else { selection.elems = new Set([eid]); selection.nodes = new Set(nodes); }
              updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); statusMsg('Selected element ' + eid);
            }
        }
      }
    }
    function onDoubleClick(ev) {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersectable = [meshShell, meshLines, points, bushGroup].filter(o => o && o.visible);
        const hits = raycaster.intersectObjects(intersectable, true);

        if (hits.length > 0) {
            controls.target.copy(hits[0].point);
            statusMsg('Rotation point set.');
        } else {
            // Reset to center of bounding box if we click empty space
            if (model.bbox) {
                const center = model.bbox.getCenter(new THREE.Vector3());
                controls.target.copy(center);
                statusMsg('Rotation point reset to model center.');
            }
        }
        controls.update();
    }
    function selectNode(i){ 
        if (i < 0) return; selectedIdx=i; 
        const nid=model.indexToNid[i], p=nodePosition(i); 
        if (!selectionSphere){ selectionSphere=new THREE.Mesh(new THREE.SphereGeometry(1,16,12), new THREE.MeshBasicMaterial({ color: 0xffd166, transparent:true, opacity:0.7 })); scene.add(selectionSphere); }
        const size = model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() : 1;
        selectionSphere.scale.setScalar(size * 0.0025 * Number(symbolSize.value || 1.0));
        selectionSphere.position.copy(p); 
        statusMsg('Selected node '+nid); 
    }
    canvas.addEventListener('click', onClick);
    canvas.addEventListener('dblclick', onDoubleClick);

    for (const inp of nodeInputs) { if (!inp) continue; inp.addEventListener('focus', () => { currentElemInput = inp; }); }
    
    document.querySelectorAll('input[data-vis]').forEach(cb => { cb.addEventListener('change', () => { visibility[cb.dataset.vis] = cb.checked; buildGeometries(true); }); });
    if(opacitySlider) opacitySlider.addEventListener('input', updateOpacity);
    if(shadingToggle) shadingToggle.addEventListener('change', () => buildGeometries(true));
    
    if(parallelToggle) {
        parallelToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                // Switch TO Orthographic
                camera = orthographicCamera;
                camera.position.copy(perspectiveCamera.position);
                camera.quaternion.copy(perspectiveCamera.quaternion);
                
                // Calculate view frustum size to match what the perspective camera was seeing
                const distance = perspectiveCamera.position.distanceTo(controls.target);
                const vFov = perspectiveCamera.fov * Math.PI / 180;
                let h = Math.tan(vFov / 2) * distance; // This is half-height
                
                if (h === 0) { // Fallback if camera is at the target
                    const boxSize = model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() : 1;
                    h = boxSize * 0.5;
                }
                
                const aspect = perspectiveCamera.aspect;
                camera.left = -h * aspect;
                camera.right = h * aspect;
                camera.top = h;
                camera.bottom = -h;
                
                // CRITICAL FIX: Recalculate near/far clipping planes to contain the entire model
                if (model.bbox) {
                    const box = model.bbox;
                    const boxCenter = box.getCenter(new THREE.Vector3());
                    const boxRadius = box.getSize(new THREE.Vector3()).length() / 2;
                    
                    // Project the bounding sphere's center onto the camera's view direction
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    const vecToCenter = new THREE.Vector3().subVectors(boxCenter, camera.position);
                    const distToCenter = vecToCenter.dot(cameraDirection);

                    // Set near/far planes to encompass the bounding sphere from the current viewpoint
                    camera.near = distToCenter - boxRadius;
                    camera.far = distToCenter + boxRadius;

                    // Ensure near plane is a small positive number to prevent rendering issues
                    if (camera.near < 0.1) {
                        camera.near = 0.1;
                    }
                }
                camera.zoom = 1; // Reset zoom

            } else {
                // Switch BACK to Perspective
                camera = perspectiveCamera;
                camera.position.copy(orthographicCamera.position);
                camera.quaternion.copy(orthographicCamera.quaternion);
            }
            controls.object = camera;
            camera.updateProjectionMatrix();
            controls.update();
        });
    }

    if(bgColorPicker) bgColorPicker.addEventListener('input', (e) => { scene.background = new THREE.Color(e.target.value); });

    const sampleDatFile = `
$ START OF BULK DATA
$
$ WebMeshEditor Sample: FULL High-Density Delta Wing
$ This is the complete model with all elements generated.
$ Features a 4-element chord-wise mesh and varied property IDs
$ by bay to demonstrate property-based coloring.
$
$=======================================================================
$ 1. Grid Points (Nodes)
$=======================================================================
$ 13 span-wise stations, each with 10 nodes to define the chord.
$
$       --- X ---     --- Y ---    --- Z ---
GRID,101,0,0.000,0.000,5.000
GRID,102,0,20.000,0.000,5.000
GRID,103,0,40.000,0.000,5.000
GRID,104,0,60.000,0.000,5.000
GRID,105,0,80.000,0.000,5.000
GRID,106,0,0.000,0.000,-5.000
GRID,107,0,20.000,0.000,-5.000
GRID,108,0,40.000,0.000,-5.000
GRID,109,0,60.000,0.000,-5.000
GRID,110,0,80.000,0.000,-5.000
GRID,201,0,2.917,12.500,4.667
GRID,202,0,21.46,12.500,4.667
GRID,203,0,40.00,12.500,4.667
GRID,204,0,58.54,12.500,4.667
GRID,205,0,77.08,12.500,4.667
GRID,206,0,2.917,12.500,-4.667
GRID,207,0,21.46,12.500,-4.667
GRID,208,0,40.00,12.500,-4.667
GRID,209,0,58.54,12.500,-4.667
GRID,210,0,77.08,12.500,-4.667
GRID,301,0,5.833,25.000,4.333
GRID,302,0,22.92,25.000,4.333
GRID,303,0,40.00,25.000,4.333
GRID,304,0,57.08,25.000,4.333
GRID,305,0,74.17,25.000,4.333
GRID,306,0,5.833,25.000,-4.333
GRID,307,0,22.92,25.000,-4.333
GRID,308,0,40.00,25.000,-4.333
GRID,309,0,57.08,25.000,-4.333
GRID,310,0,74.17,25.000,-4.333
GRID,401,0,8.750,37.500,4.000
GRID,402,0,24.38,37.500,4.000
GRID,403,0,40.00,37.500,4.000
GRID,404,0,55.62,37.500,4.000
GRID,405,0,71.25,37.500,4.000
GRID,406,0,8.750,37.500,-4.000
GRID,407,0,24.38,37.500,-4.000
GRID,408,0,40.00,37.500,-4.000
GRID,409,0,55.62,37.500,-4.000
GRID,410,0,71.25,37.500,-4.000
GRID,501,0,11.67,50.000,3.667
GRID,502,0,25.83,50.000,3.667
GRID,503,0,40.00,50.000,3.667
GRID,504,0,54.17,50.000,3.667
GRID,505,0,68.33,50.000,3.667
GRID,506,0,11.67,50.000,-3.667
GRID,507,0,25.83,50.000,-3.667
GRID,508,0,40.00,50.000,-3.667
GRID,509,0,54.17,50.000,-3.667
GRID,510,0,68.33,50.000,-3.667
GRID,601,0,14.58,62.500,3.333
GRID,602,0,27.29,62.500,3.333
GRID,603,0,40.00,62.500,3.333
GRID,604,0,52.71,62.500,3.333
GRID,605,0,65.42,62.500,3.333
GRID,606,0,14.58,62.500,-3.333
GRID,607,0,27.29,62.500,-3.333
GRID,608,0,40.00,62.500,-3.333
GRID,609,0,52.71,62.500,-3.333
GRID,610,0,65.42,62.500,-3.333
GRID,701,0,17.50,75.000,3.000
GRID,702,0,28.75,75.000,3.000
GRID,703,0,40.00,75.000,3.000
GRID,704,0,51.25,75.000,3.000
GRID,705,0,62.50,75.000,3.000
GRID,706,0,17.50,75.000,-3.000
GRID,707,0,28.75,75.000,-3.000
GRID,708,0,40.00,75.000,-3.000
GRID,709,0,51.25,75.000,-3.000
GRID,710,0,62.50,75.000,-3.000
GRID,801,0,20.42,87.500,2.667
GRID,802,0,30.21,87.500,2.667
GRID,803,0,40.00,87.500,2.667
GRID,804,0,49.79,87.500,2.667
GRID,805,0,59.58,87.500,2.667
GRID,806,0,20.42,87.500,-2.667
GRID,807,0,30.21,87.500,-2.667
GRID,808,0,40.00,87.500,-2.667
GRID,809,0,49.79,87.500,-2.667
GRID,810,0,59.58,87.500,-2.667
GRID,901,0,23.33,100.00,2.333
GRID,902,0,31.67,100.00,2.333
GRID,903,0,40.00,100.00,2.333
GRID,904,0,48.33,100.00,2.333
GRID,905,0,56.67,100.00,2.333
GRID,906,0,23.33,100.00,-2.333
GRID,907,0,31.67,100.00,-2.333
GRID,908,0,40.00,100.00,-2.333
GRID,909,0,48.33,100.00,-2.333
GRID,910,0,56.67,100.00,-2.333
GRID,1001,0,26.25,112.50,2.000
GRID,1002,0,33.12,112.50,2.000
GRID,1003,0,40.00,112.50,2.000
GRID,1004,0,46.88,112.50,2.000
GRID,1005,0,53.75,112.50,2.000
GRID,1006,0,26.25,112.50,-2.000
GRID,1007,0,33.12,112.50,-2.000
GRID,1008,0,40.00,112.50,-2.000
GRID,1009,0,46.88,112.50,-2.000
GRID,1010,0,53.75,112.50,-2.000
GRID,1101,0,29.17,125.00,1.667
GRID,1102,0,34.58,125.00,1.667
GRID,1103,0,40.00,125.00,1.667
GRID,1104,0,45.42,125.00,1.667
GRID,1105,0,50.83,125.00,1.667
GRID,1106,0,29.17,125.00,-1.667
GRID,1107,0,34.58,125.00,-1.667
GRID,1108,0,40.00,125.00,-1.667
GRID,1109,0,45.42,125.00,-1.667
GRID,1110,0,50.83,125.00,-1.667
GRID,1201,0,32.08,137.50,1.333
GRID,1202,0,36.04,137.50,1.333
GRID,1203,0,40.00,137.50,1.333
GRID,1204,0,43.96,137.50,1.333
GRID,1205,0,47.92,137.50,1.333
GRID,1206,0,32.08,137.50,-1.333
GRID,1207,0,36.04,137.50,-1.333
GRID,1208,0,40.00,137.50,-1.333
GRID,1209,0,43.96,137.50,-1.333
GRID,1210,0,47.92,137.50,-1.333
GRID,1301,0,35.00,150.00,1.000
GRID,1302,0,37.50,150.00,1.000
GRID,1303,0,40.00,150.00,1.000
GRID,1304,0,42.50,150.00,1.000
GRID,1305,0,45.00,150.00,1.000
GRID,1306,0,35.00,150.00,-1.000
GRID,1307,0,37.50,150.00,-1.000
GRID,1308,0,40.00,150.00,-1.000
GRID,1309,0,42.50,150.00,-1.000
GRID,1310,0,45.00,150.00,-1.000
$
$ Pylon and Control Nodes
GRID,99,0,40.0,0.0,0.0         $ RBE2 Independent Node (Root Constraint)
GRID,1399,0,40.0,150.0,0.0      $ RBE3 Dependent Node (Tip Load)
GRID,791,0,28.75,75.0,-6.0      $ Pylon/Engine point (Fwd)
GRID,792,0,51.25,75.0,-6.0      $ Pylon/Engine point (Aft)
GRID,799,0,40.0,75.0,-6.0       $ RBE3 Dependent Node (Pylon Load)
$
$=======================================================================
$ 2. Elements
$=======================================================================
$ Elements are defined for all 12 bays.
$ Property IDs change for bays 1-4, 5-8, and 9-12.
$
$ --- Function to generate a bay (logic used to create this file) ---
$ def create_bay(bay_num, p_skin, p_web, p_beam, p_rib):
$   n_start = bay_num * 100
$   n_end = (bay_num + 1) * 100
$   ... generate connectivity ...
$
$ --- Bays 1-4 : Root Section Properties (PIDs 11, 12, 13, 14) ---
$ BAY 1
CQUAD4,1011,11,101,201,202,102
CQUAD4,1012,11,102,202,203,103
CQUAD4,1013,11,103,203,204,104
CQUAD4,1014,11,104,204,205,105
CQUAD4,1015,11,106,107,207,206
CQUAD4,1016,11,107,108,208,207
CQUAD4,1017,11,108,109,209,208
CQUAD4,1018,11,109,110,210,209
CQUAD4,1019,12,101,106,206,201
CQUAD4,1020,12,105,205,210,110
CBEAM,2011,13,101,201
CBEAM,2012,13,102,202
CBEAM,2013,13,103,203
CBEAM,2014,13,104,204
CBEAM,2015,13,105,205
CBEAM,2016,13,106,206
CBEAM,2017,13,107,207
CBEAM,2018,13,108,208
CBEAM,2019,13,109,209
CBEAM,2020,13,110,210
CBAR,3011,14,101,102
CBAR,3012,14,102,103
CBAR,3013,14,103,104
CBAR,3014,14,104,105
CBAR,3015,14,106,107
CBAR,3016,14,107,108
CBAR,3017,14,108,109
CBAR,3018,14,109,110
CBAR,3019,14,101,106
CBAR,3020,14,102,107
CBAR,3021,14,103,108
CBAR,3022,14,104,109
CBAR,3023,14,105,110
$ BAY 2
CQUAD4,1021,11,201,301,302,202
CQUAD4,1022,11,202,302,303,203
CQUAD4,1023,11,203,303,304,204
CQUAD4,1024,11,204,304,305,205
CQUAD4,1025,11,206,207,307,306
CQUAD4,1026,11,207,208,308,307
CQUAD4,1027,11,208,209,309,308
CQUAD4,1028,11,209,210,310,309
CQUAD4,1029,12,201,206,306,301
CQUAD4,1030,12,205,305,310,210
CBEAM,2021,13,201,301
CBEAM,2022,13,202,302
CBEAM,2023,13,203,303
CBEAM,2024,13,204,304
CBEAM,2025,13,205,305
CBEAM,2026,13,206,306
CBEAM,2027,13,207,307
CBEAM,2028,13,208,308
CBEAM,2029,13,209,309
CBEAM,2030,13,210,310
CBAR,3031,14,201,202
CBAR,3032,14,202,203
CBAR,3033,14,203,204
CBAR,3034,14,204,205
CBAR,3035,14,206,207
CBAR,3036,14,207,208
CBAR,3037,14,208,209
CBAR,3038,14,209,210
CBAR,3039,14,201,206
CBAR,3040,14,202,207
CBAR,3041,14,203,208
CBAR,3042,14,204,209
CBAR,3043,14,205,210
$ BAY 3
CQUAD4,1041,11,301,401,402,302
CQUAD4,1042,11,302,402,403,303
CQUAD4,1043,11,303,403,404,304
CQUAD4,1044,11,304,404,405,305
CQUAD4,1045,11,306,307,407,406
CQUAD4,1046,11,307,308,408,407
CQUAD4,1047,11,308,309,409,408
CQUAD4,1048,11,309,310,410,409
CQUAD4,1049,12,301,306,406,401
CQUAD4,1050,12,305,405,410,310
CBEAM,2041,13,301,401
CBEAM,2042,13,302,402
CBEAM,2043,13,303,403
CBEAM,2044,13,304,404
CBEAM,2045,13,305,405
CBEAM,2046,13,306,406
CBEAM,2047,13,307,407
CBEAM,2048,13,308,408
CBEAM,2049,13,309,409
CBEAM,2050,13,310,410
CBAR,3051,14,301,302
CBAR,3052,14,302,303
CBAR,3053,14,303,304
CBAR,3054,14,304,305
CBAR,3055,14,306,307
CBAR,3056,14,307,308
CBAR,3057,14,308,309
CBAR,3058,14,309,310
CBAR,3059,14,301,306
CBAR,3060,14,302,307
CBAR,3061,14,303,308
CBAR,3062,14,304,309
CBAR,3063,14,305,310
$ BAY 4
CQUAD4,1061,11,401,501,502,402
CQUAD4,1062,11,402,502,503,403
CQUAD4,1063,11,403,503,504,404
CQUAD4,1064,11,404,504,505,405
CQUAD4,1065,11,406,407,507,506
CQUAD4,1066,11,407,408,508,507
CQUAD4,1067,11,408,409,509,508
CQUAD4,1068,11,409,410,510,509
CQUAD4,1069,12,401,406,506,501
CQUAD4,1070,12,405,505,510,410
CBEAM,2061,13,401,501
CBEAM,2062,13,402,502
CBEAM,2063,13,403,503
CBEAM,2064,13,404,504
CBEAM,2065,13,405,505
CBEAM,2066,13,406,506
CBEAM,2067,13,407,507
CBEAM,2068,13,408,508
CBEAM,2069,13,409,509
CBEAM,2070,13,410,510
CBAR,3071,14,401,402
CBAR,3072,14,402,403
CBAR,3073,14,403,404
CBAR,3074,14,404,405
CBAR,3075,14,406,407
CBAR,3076,14,407,408
CBAR,3077,14,408,409
CBAR,3078,14,409,410
CBAR,3079,14,401,406
CBAR,3080,14,402,407
CBAR,3081,14,403,408
CBAR,3082,14,404,409
CBAR,3083,14,405,410
$
$ --- Bays 5-8 : Mid Section Properties (PIDs 21, 22, 23, 24) ---
$ BAY 5
CQUAD4,1081,21,501,601,602,502
CQUAD4,1082,21,502,602,603,503
CQUAD4,1083,21,503,603,604,504
CQUAD4,1084,21,504,604,605,505
CQUAD4,1085,21,506,507,607,606
CQUAD4,1086,21,507,508,608,607
CQUAD4,1087,21,508,509,609,608
CQUAD4,1088,21,509,510,610,609
CQUAD4,1089,22,501,506,606,601
CQUAD4,1090,22,505,605,610,510
CBEAM,2081,23,501,601
CBEAM,2082,23,502,602
CBEAM,2083,23,503,603
CBEAM,2084,23,504,604
CBEAM,2085,23,505,605
CBEAM,2086,23,506,606
CBEAM,2087,23,507,607
CBEAM,2088,23,508,608
CBEAM,2089,23,509,609
CBEAM,2090,23,510,610
CBAR,3091,24,501,502
CBAR,3092,24,502,503
CBAR,3093,24,503,504
CBAR,3094,24,504,505
CBAR,3095,24,506,507
CBAR,3096,24,507,508
CBAR,3097,24,508,509
CBAR,3098,24,509,510
CBAR,3099,24,501,506
CBAR,3100,24,502,507
CBAR,3101,24,503,508
CBAR,3102,24,504,509
CBAR,3103,24,505,510
$ BAY 6
CQUAD4,1101,21,601,701,702,602
CQUAD4,1102,21,602,702,703,603
CQUAD4,1103,21,603,703,704,604
CQUAD4,1104,21,604,704,705,605
CQUAD4,1105,21,606,607,707,706
CQUAD4,1106,21,607,608,708,707
CQUAD4,1107,21,608,609,709,708
CQUAD4,1108,21,609,610,710,709
CQUAD4,1109,22,601,606,706,701
CQUAD4,1110,22,605,705,710,610
CBEAM,2101,23,601,701
CBEAM,2102,23,602,702
CBEAM,2103,23,603,703
CBEAM,2104,23,604,704
CBEAM,2105,23,605,705
CBEAM,2106,23,606,706
CBEAM,2107,23,607,707
CBEAM,2108,23,608,708
CBEAM,2109,23,609,709
CBEAM,2110,23,610,710
CBAR,3111,24,601,602
CBAR,3112,24,602,603
CBAR,3113,24,603,604
CBAR,3114,24,604,605
CBAR,3115,24,606,607
CBAR,3116,24,607,608
CBAR,3117,24,608,609
CBAR,3118,24,609,610
CBAR,3119,24,601,606
CBAR,3120,24,602,607
CBAR,3121,24,603,608
CBAR,3122,24,604,609
CBAR,3123,24,605,610
$ BAY 7
CQUAD4,1121,21,701,801,802,702
CQUAD4,1122,21,702,802,803,703
CQUAD4,1123,21,703,803,804,704
CQUAD4,1124,21,704,804,805,705
CQUAD4,1125,21,706,707,807,806
CQUAD4,1126,21,707,708,808,807
CQUAD4,1127,21,708,709,809,808
CQUAD4,1128,21,709,710,810,809
CQUAD4,1129,22,701,706,806,801
CQUAD4,1130,22,705,805,810,710
CBEAM,2121,23,701,801
CBEAM,2122,23,702,802
CBEAM,2123,23,703,803
CBEAM,2124,23,704,804
CBEAM,2125,23,705,805
CBEAM,2126,23,706,806
CBEAM,2127,23,707,807
CBEAM,2128,23,708,808
CBEAM,2129,23,709,809
CBEAM,2130,23,710,810
CBAR,3131,24,701,702
CBAR,3132,24,702,703
CBAR,3133,24,703,704
CBAR,3134,24,704,705
CBAR,3135,24,706,707
CBAR,3136,24,707,708
CBAR,3137,24,708,709
CBAR,3138,24,709,710
CBAR,3139,24,701,706
CBAR,3140,24,702,707
CBAR,3141,24,703,708
CBAR,3142,24,704,709
CBAR,3143,24,705,710
$ BAY 8
CQUAD4,1141,21,801,901,902,802
CQUAD4,1142,21,802,902,903,803
CQUAD4,1143,21,803,903,904,804
CQUAD4,1144,21,804,904,905,805
CQUAD4,1145,21,806,807,907,906
CQUAD4,1146,21,807,808,908,907
CQUAD4,1147,21,808,809,909,908
CQUAD4,1148,21,809,810,910,909
CQUAD4,1149,22,801,806,906,901
CQUAD4,1150,22,805,905,910,810
CBEAM,2141,23,801,901
CBEAM,2142,23,802,902
CBEAM,2143,23,803,903
CBEAM,2144,23,804,904
CBEAM,2145,23,805,905
CBEAM,2146,23,806,906
CBEAM,2147,23,807,907
CBEAM,2148,23,808,908
CBEAM,2149,23,809,909
CBEAM,2150,23,810,910
CBAR,3151,24,801,802
CBAR,3152,24,802,803
CBAR,3153,24,803,804
CBAR,3154,24,804,805
CBAR,3155,24,806,807
CBAR,3156,24,807,808
CBAR,3157,24,808,809
CBAR,3158,24,809,810
CBAR,3159,24,801,806
CBAR,3160,24,802,807
CBAR,3161,24,803,808
CBAR,3162,24,804,809
CBAR,3163,24,805,810
$
$ --- Bays 9-12 : Tip Section Properties (PIDs 31, 32, 33, 34) ---
$ BAY 9
CQUAD4,1161,31,901,1001,1002,902
CQUAD4,1162,31,902,1002,1003,903
CQUAD4,1163,31,903,1003,1004,904
CQUAD4,1164,31,904,1004,1005,905
CQUAD4,1165,31,906,907,1007,1006
CQUAD4,1166,31,907,908,1008,1007
CQUAD4,1167,31,908,909,1009,1008
CQUAD4,1168,31,909,910,1010,1009
CQUAD4,1169,32,901,906,1006,1001
CQUAD4,1170,32,905,1005,1010,910
CBEAM,2161,33,901,1001
CBEAM,2162,33,902,1002
CBEAM,2163,33,903,1003
CBEAM,2164,33,904,1004
CBEAM,2165,33,905,1005
CBEAM,2166,33,906,1006
CBEAM,2167,33,907,1007
CBEAM,2168,33,908,1008
CBEAM,2169,33,909,1009
CBEAM,2170,33,910,1010
CBAR,3171,34,901,902
CBAR,3172,34,902,903
CBAR,3173,34,903,904
CBAR,3174,34,904,905
CBAR,3175,34,906,907
CBAR,3176,34,907,908
CBAR,3177,34,908,909
CBAR,3178,34,909,910
CBAR,3179,34,901,906
CBAR,3180,34,902,907
CBAR,3181,34,903,908
CBAR,3182,34,904,909
CBAR,3183,34,905,910
$ BAY 10
CQUAD4,1181,31,1001,1101,1102,1002
CQUAD4,1182,31,1002,1102,1103,1003
CQUAD4,1183,31,1003,1103,1104,1004
CQUAD4,1184,31,1004,1104,1105,1005
CQUAD4,1185,31,1006,1007,1107,1106
CQUAD4,1186,31,1007,1008,1108,1107
CQUAD4,1187,31,1008,1009,1109,1108
CQUAD4,1188,31,1009,1010,1110,1109
CQUAD4,1189,32,1001,1006,1106,1101
CQUAD4,1190,32,1005,1105,1110,1010
CBEAM,2181,33,1001,1101
CBEAM,2182,33,1002,1102
CBEAM,2183,33,1003,1103
CBEAM,2184,33,1004,1104
CBEAM,2185,33,1005,1105
CBEAM,2186,33,1006,1106
CBEAM,2187,33,1007,1107
CBEAM,2188,33,1008,1108
CBEAM,2189,33,1009,1109
CBEAM,2190,33,1010,1110
CBAR,3191,34,1001,1002
CBAR,3192,34,1002,1003
CBAR,3193,34,1003,1004
CBAR,3194,34,1004,1005
CBAR,3195,34,1006,1007
CBAR,3196,34,1007,1008
CBAR,3197,34,1008,1009
CBAR,3198,34,1009,1010
CBAR,3199,34,1001,1006
CBAR,3200,34,1002,1007
CBAR,3201,34,1003,1008
CBAR,3202,34,1004,1009
CBAR,3203,34,1005,1010
$ BAY 11
CQUAD4,1201,31,1101,1201,1202,1102
CQUAD4,1202,31,1102,1202,1203,1103
CQUAD4,1203,31,1103,1203,1204,1104
CQUAD4,1204,31,1104,1204,1205,1105
CQUAD4,1205,31,1106,1107,1207,1206
CQUAD4,1206,31,1107,1108,1208,1207
CQUAD4,1207,31,1108,1109,1209,1208
CQUAD4,1208,31,1109,1110,1210,1209
CQUAD4,1209,32,1101,1106,1206,1201
CQUAD4,1210,32,1105,1205,1210,1110
CBEAM,2201,33,1101,1201
CBEAM,2202,33,1102,1202
CBEAM,2203,33,1103,1203
CBEAM,2204,33,1104,1204
CBEAM,2205,33,1105,1205
CBEAM,2206,33,1106,1206
CBEAM,2207,33,1107,1207
CBEAM,2208,33,1108,1208
CBEAM,2209,33,1109,1209
CBEAM,2210,33,1110,1210
CBAR,3211,34,1101,1102
CBAR,3212,34,1102,1103
CBAR,3213,34,1103,1104
CBAR,3214,34,1104,1105
CBAR,3215,34,1106,1107
CBAR,3216,34,1107,1108
CBAR,3217,34,1108,1109
CBAR,3218,34,1109,1110
CBAR,3219,34,1101,1106
CBAR,3220,34,1102,1107
CBAR,3221,34,1103,1108
CBAR,3222,34,1104,1109
CBAR,3223,34,1105,1110
$ BAY 12
CQUAD4,1221,31,1201,1301,1302,1202
CQUAD4,1222,31,1202,1302,1303,1203
CQUAD4,1223,31,1203,1303,1304,1204
CQUAD4,1224,31,1204,1304,1305,1205
CQUAD4,1225,31,1206,1207,1307,1306
CQUAD4,1226,31,1207,1208,1308,1307
CQUAD4,1227,31,1208,1209,1309,1308
CQUAD4,1228,31,1209,1210,1310,1309
CQUAD4,1229,32,1201,1206,1306,1301
CQUAD4,1230,32,1205,1305,1310,1210
CBEAM,2221,33,1201,1301
CBEAM,2222,33,1202,1302
CBEAM,2223,33,1203,1303
CBEAM,2224,33,1204,1304
CBEAM,2225,33,1205,1305
CBEAM,2226,33,1206,1306
CBEAM,2227,33,1207,1307
CBEAM,2228,33,1208,1308
CBEAM,2229,33,1209,1309
CBEAM,2230,33,1210,1310
CBAR,3231,34,1201,1202
CBAR,3232,34,1202,1203
CBAR,3233,34,1203,1204
CBAR,3234,34,1204,1205
CBAR,3235,34,1206,1207
CBAR,3236,34,1207,1208
CBAR,3237,34,1208,1209
CBAR,3238,34,1209,1210
CBAR,3239,34,1201,1206
CBAR,3240,34,1202,1207
CBAR,3241,34,1203,1208
CBAR,3242,34,1204,1209
CBAR,3243,34,1205,1210
$ Final Rib at Tip
CBAR,3251,34,1301,1302
CBAR,3252,34,1302,1303
CBAR,3253,34,1303,1304
CBAR,3254,34,1304,1305
CBAR,3255,34,1306,1307
CBAR,3256,34,1307,1308
CBAR,3257,34,1308,1309
CBAR,3258,34,1309,1310
CBAR,3259,34,1301,1306
CBAR,3260,34,1302,1307
CBAR,3261,34,1303,1308
CBAR,3262,34,1304,1309
CBAR,3263,34,1305,1310
$
$ --- Bushes (PID 5) for Pylon Attachment at Y=75 (Station 7) ---
CBUSH,7001,5,707,791
CBUSH,7002,5,709,792
$
$=======================================================================
$ 3. Rigid Elements (RBEs)
$=======================================================================
$ RBE2 at root to connect all 10 nodes to fixed point 99
RBE2,8001,99,123456,101,102,103,104,105,106,107,108,109,110
$ RBE3 at tip to apply loads to all 10 tip nodes
RBE3,9001,1399,123,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310
$ RBE3 at pylon to apply engine weight
RBE3,9002,799,3,791,792
$
$=======================================================================
$ 4. Loads and Constraints
$=======================================================================
$ Load set ID = 1
$ Fix the RBE2 center node in all 6 DOF
SPC1,1,123456,99
$
$ Apply loads to the RBE3 center nodes.
$ 25,000 unit lift force (+Z) at the tip
FORCE,1,1399,0,25000.0,0.0,0.0,1.0
$ 150,000 unit nose-up pitching moment (+Y) at the tip
MOMENT,1,1399,0,150000.0,0.0,1.0,0.0
$ 5,000 unit engine weight force (-Z) at the pylon
FORCE,1,799,0,-5000.0,0.0,0.0,-1.0
$
$=======================================================================
$ 5. Properties and Materials
$=======================================================================
$ Single material (Aluminum)
MAT1,1,1.0E7,0.33,
$
$ --- Properties for Root Section (Bays 1-4) ---
PSHELL,11,1,0.15,1       $ PID 11: Skin, 0.15 thickness
PSHELL,12,1,0.25,1       $ PID 12: Spar Web, 0.25 thickness
PBEAM,13,1,1.2,0.3,0.15, $ PID 13: Spar Caps & Stringers
PBAR,14,1,0.6,0.15,      $ PID 14: Ribs
$ --- Properties for Mid Section (Bays 5-8) ---
PSHELL,21,1,0.10,1
PSHELL,22,1,0.20,1
PBEAM,23,1,1.0,0.2,0.1,
PBAR,24,1,0.5,0.1,
$ --- Properties for Tip Section (Bays 9-12) ---
PSHELL,31,1,0.08,1
PSHELL,32,1,0.15,1
PBEAM,33,1,0.8,0.15,0.08,
PBAR,34,1,0.4,0.08,
$ --- Pylon Bush Property ---
PBUSH,5,K,1.E6,1.E6,1.E6,1.E5,1.E5,1.E5
$
ENDDATA
`;
    if(btnSample) {
        btnSample.addEventListener('click', () => {
            loadFromText(sampleDatFile, 'sample.dat');
        });
    }

    if(csysMethod) { csysMethod.addEventListener('change', () => { csysNodes.style.display = csysMethod.value === 'nodes' ? '' : 'none'; csysCoords.style.display = csysMethod.value === 'coords' ? '' : 'none'; }); }
    if(advancedNodeToggle) { advancedNodeToggle.addEventListener('click', () => { const isHidden = advancedNodeOptions.style.display === 'none'; advancedNodeOptions.style.display = isHidden ? '' : 'none'; advancedNodeToggle.textContent = isHidden ? 'Advanced ▲' : 'Advanced ▼'; }); }


    if (multiSelectEl) { multiSelectMode = multiSelectEl.checked; multiSelectEl.addEventListener('change', () => { multiSelectMode = multiSelectEl.checked; }); }
    if (symbolSize) symbolSize.addEventListener('input', () => { buildGeometries(true); selectNode(selectedIdx); });
    if (springSize) springSize.addEventListener('input', () => { buildGeometries(true); });

    if (selectModeEl) { selectMode = selectModeEl.value; selectModeEl.addEventListener('change', (e) => { selectMode = e.target.value; selection.nodes.clear(); selection.elems.clear(); updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); }); }
    if (colorMode) colorMode.addEventListener('change', () => { buildGeometries(true); });
    if (btnClearSelection) btnClearSelection.addEventListener('click', () => { selection.nodes.clear(); selection.elems.clear(); updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); });

    if (canvas && selectRect) {
      canvas.addEventListener('mousedown', (ev) => { if (!ev.altKey) return; const rect = viewportEl.getBoundingClientRect(); dragStart = { x: ev.clientX - rect.left, y: ev.clientY - rect.top }; boxSelecting = true; if (controls) controls.enabled = false; selectRect.style.display = 'block'; selectRect.style.left = dragStart.x + 'px'; selectRect.style.top = dragStart.y + 'px'; selectRect.style.width = '0px'; selectRect.style.height = '0px'; ev.preventDefault(); });
      window.addEventListener('mousemove', (ev) => { if (!dragStart) return; const rect = viewportEl.getBoundingClientRect(); const currentX = ev.clientX - rect.left, currentY = ev.clientY - rect.top; const x = Math.min(dragStart.x, currentX), y = Math.min(dragStart.y, currentY), w = Math.abs(currentX - dragStart.x), h = Math.abs(currentY - dragStart.y); selectRect.style.left = x + 'px'; selectRect.style.top = y + 'px'; selectRect.style.width = w + 'px'; selectRect.style.height = h + 'px'; });
      window.addEventListener('mouseup', (ev) => {
        if (!dragStart) return;
        const rect = viewportEl.getBoundingClientRect(), endX = ev.clientX - rect.left, endY = ev.clientY - rect.top;
        const x1 = Math.min(dragStart.x, endX), x2 = Math.max(dragStart.x, endX), y1 = Math.min(dragStart.y, endY), y2 = Math.max(dragStart.y, endY);
        const rectCanvas = canvas.getBoundingClientRect();
        if (selectMode === 'node') {
          if (points) {
            const selectedInBox = [];
            for (let i = 0; i < model.indexToNid.length; i++) {
              const p = nodePosition(i).clone().project(camera);
              const sx = (p.x + 1) * 0.5 * rectCanvas.width, sy = (1 - p.y) * 0.5 * rectCanvas.height;
              if (sx >= x1 && sx <= x2 && sy >= y1 && sy <= y2) { selectedInBox.push(model.indexToNid[i]); }
            }
            if (!multiSelectMode) selection.nodes.clear();
            selection.elems.clear();
            for (const nid of selectedInBox) selection.nodes.add(nid);
            updateSelectionVisual(); updateSelectionUI();
          }
        } else if (selectMode === 'element') {
          const selectedElems = new Set();
          const projectToScreen = (vec3) => { const p = vec3.clone().project(camera); return { sx: (p.x + 1) * 0.5 * rectCanvas.width, sy: (1 - p.y) * 0.5 * rectCanvas.height }; };
          const checkElem = (e) => { if (hidden.elems && hidden.elems.has(e.eid)) return; const nodes = e.n || [e.gn, ...(e.deps || e.inds)]; const centroid = centroidOf(nodes); const { sx, sy } = projectToScreen(centroid); if (sx >= x1 && sx <= x2 && sy >= y1 && sy <= y2) { selectedElems.add(e.eid); } };
          Object.values(model.elems).flat().forEach(checkElem);
          if (!multiSelectMode) { selection.elems.clear(); selection.nodes.clear(); }
          for (const eid of selectedElems) {
            if (multiSelectMode && selection.elems.has(eid)) { selection.elems.delete(eid); } else { selection.elems.add(eid); }
          }
          updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI();
        }
        if (controls) controls.enabled = true;
        dragStart = null; boxSelecting = false;
        selectRect.style.display = 'none';
      });
    }

    fileInput.addEventListener('change', async (e)=>{ const f=e.target.files[0]; if (!f) return; const text=await f.text(); loadFromText(text, f.name); });
    btnClear.addEventListener('click', ()=>{ historyManager.recordAction(() => { resetModel(); clearScene(); refreshCounts(); statusMsg('Cleared model.'); }); });
    btnReset.addEventListener('click', fitView);
    btnExport.addEventListener('click', exportBDF);

    if (btnCopySelectedNode) {
        btnCopySelectedNode.addEventListener('click', () => {
            if (selectMode === 'node' && selection.nodes.size === 1) {
                const nid = Array.from(selection.nodes)[0];
                const node = model.nodes.get(nid);
                if (node) {
                    document.getElementById('newX').value = node.x;
                    document.getElementById('newY').value = node.y;
                    document.getElementById('newZ').value = node.z;
                    document.getElementById('newCP').value = node.cp || 0;
                    statusMsg(`Copied coords from node ${nid}.`);
                }
            }
        });
    }

    btnApplyChanges.addEventListener('click', ()=>{ 
        if (selection.nodes.size === 0) return;
        
        const newCP_val = selCP.value !== '' ? parseInt(selCP.value) : null;

        if (newCP_val !== null) {
            const csys = model.coords.get(newCP_val);
            if (csys && csys.nodes) {
                for (const nid of selection.nodes) {
                    if (csys.nodes.includes(nid)) {
                        statusMsg(`Error: Node ${nid} defines CSYS ${newCP_val} and cannot be defined in it.`, true);
                        return; 
                    }
                }
            }
        }
        
        historyManager.recordAction(() => {
            const newCD_val = selCD.value !== '' ? parseInt(selCD.value) : null;
            const { globalPositions, globalCoordTransforms } = resolveAllTransforms();

            for(const nid of selection.nodes) {
                const node = model.nodes.get(nid);
                if(!node) continue;
                
                const originalCP = node.cp || 0;
                const newCP = newCP_val !== null ? newCP_val : originalCP;

                if (newCP !== originalCP) {
                    const globalPos = globalPositions.get(nid);
                    const newTransform = globalCoordTransforms.get(newCP);

                    if (!newTransform) {
                         statusMsg(`Error: CP ${newCP} has no transform (unresolved). Node ${nid} not changed.`, true);
                         continue; 
                    }

                    if (globalPos) {
                        const invNewTransform = newTransform.clone().invert();
                        const newLocalPos = globalPos.clone().applyMatrix4(invNewTransform);
                        
                        node.x = newLocalPos.x;
                        node.y = newLocalPos.y;
                        node.z = newLocalPos.z;
                        node.cp = newCP;
                    }
                } else if(selection.nodes.size === 1) {
                    node.x = Number(selX.value);
                    node.y = Number(selY.value);
                    node.z = Number(selZ.value);
                }

                if (newCD_val !== null && !isNaN(newCD_val)) node.cd = newCD_val;
            }
            buildGeometries(true);
            statusMsg(`Updated ${selection.nodes.size} node(s).`); 
        });
    });

    btnCancelChanges.addEventListener('click', updateSelectionUI);

    btnApplyElemEdit.addEventListener('click', () => {
        const eid = parseInt(document.getElementById('editEid').value); if (isNaN(eid)) return;
        historyManager.recordAction(() => {
            let elem; for (const type in model.elems) { const found = model.elems[type].find(e => e.eid === eid); if (found) { elem = found; break; } }
            if (!elem) { statusMsg(`Element ${eid} not found.`, true); return; }
            const newPid = parseInt(document.getElementById('editPid').value); if (!isNaN(newPid)) elem.pid = newPid;
            const nodeFields = [document.getElementById('editN1'), document.getElementById('editN2'), document.getElementById('editN3'), document.getElementById('editN4')];
            const newNodes = []; let allNodesValid = true;
            if(elem.n) {
              for (let i = 0; i < elem.n.length; i++) { const nVal = parseInt(nodeFields[i].value); if (isNaN(nVal) || !model.nodes.has(nVal)) { allNodesValid = false; break; } newNodes.push(nVal); }
              if (allNodesValid) { elem.n = newNodes; } 
              else { statusMsg(`Invalid node ID entered for element ${eid}. Aborting edit.`, true); return; }
            }
            if (elem.type === 'CQUAD4') {
                const getVal = (id, isInt = false) => {
                    const val = isInt ? parseInt(document.getElementById(id).value) : parseFloat(document.getElementById(id).value);
                    return isNaN(val) ? undefined : val;
                };
                elem.thetaMcid = getVal('editThetaMcid');
                elem.zoffs = getVal('editZoffs');
                elem.tflag = getVal('editTflag', true);
                const t = [getVal('editT1'), getVal('editT2'), getVal('editT3'), getVal('editT4')];
                elem.T = t.some(v => v !== undefined) ? t : undefined;
            }
            statusMsg(`Updated element ${eid}.`); buildGeometries(true); 
        });
        document.getElementById('editElementCard').style.display = 'none'; selection.elems.clear(); updateSelectionUI(); highlightSelectedElementVisual();
    });

    btnCancelElemEdit.addEventListener('click', () => { document.getElementById('editElementCard').style.display = 'none'; selection.elems.clear(); updateSelectionUI(); highlightSelectedElementVisual(); });

    function getTargetNodes() {
        const manualIds = loadNodeId.value.split(/[\s,]+/).map(s => parseInt(s.trim())).filter(v => !isNaN(v) && model.nodes.has(v));
        if (manualIds.length > 0) return manualIds;
        if (selection.nodes.size > 0) return Array.from(selection.nodes);
        return [];
    }

    btnAddForce.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), mag = Number(fMag.value||0), dir = [Number(fX.value||0),Number(fY.value||0),Number(fZ.value||0)]; let count = 0;
            for (const nid of targetNids) { model.loads.force.push({ type: 'FORCE', sid, nid, cid:0, mag, dir }); count++; }
            buildGeometries(true); refreshCounts(); statusMsg(`Added FORCE on ${count} node(s).`); loadNodeId.value = '';
        });
    });
    btnAddMoment.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), mag = Number(mMag.value||0), dir = [Number(mX.value||0),Number(mY.value||0),Number(mZ.value||0)]; let count = 0;
            for (const nid of targetNids) { model.loads.moment.push({ type: 'MOMENT', sid, nid, cid:0, mag, dir }); count++; }
            buildGeometries(true); refreshCounts(); statusMsg(`Added MOMENT on ${count} node(s).`); loadNodeId.value = '';
        });
    });
    btnAddSPC.addEventListener('click', ()=>{ 
        const targetNids = getTargetNodes(); if (targetNids.length === 0) { statusMsg('Enter valid node ID(s) or select node(s) first.', true); return; }
        historyManager.recordAction(() => {
            const sid = Number(sidEl.value||1), components = (spcComp.value||'123'); 
            let grp = model.spc1.find(s=>s.sid===sid && s.components===components); if (!grp){ grp={sid, components, nodes:[]}; model.spc1.push(grp);} let count = 0;
            for (const nid of targetNids) { if (!grp.nodes.includes(nid)) { grp.nodes.push(nid); count++; } }
            buildGeometries(true); refreshCounts(); statusMsg(`Added SPC1 ${components} on ${count} node(s).`); loadNodeId.value = '';
        });
    });

    btnAddCsys.addEventListener('click', () => {
        const cid = parseInt(csysId.value), rid = parseInt(csysRid.value);
        if (isNaN(cid) || isNaN(rid)) { statusMsg('CSYS ID and Ref CID must be valid integers.', true); return; }
        if (model.coords.has(cid)) { statusMsg(`Coordinate system ${cid} already exists.`, true); return; }
        historyManager.recordAction(() => {
            if (csysMethod.value === 'nodes') {
                const n1 = parseInt(csysN1.value), n2 = parseInt(csysN2.value), n3 = parseInt(csysN3.value);
                if ([n1, n2, n3].some(isNaN)) { statusMsg('All node fields must be valid IDs.', true); return; }
                if (!model.nodes.has(n1) || !model.nodes.has(n2) || !model.nodes.has(n3)) { statusMsg('One or more defining nodes do not exist.', true); return; }
                model.coords.set(cid, { type: 'CORD2R', rid, nodes: [n1, n2, n3] });
            } else {
                const origin = [Number(document.getElementById('csysA1').value), Number(document.getElementById('csysA2').value), Number(document.getElementById('csysA3').value)];
                const zAxisPt = [Number(document.getElementById('csysB1').value), Number(document.getElementById('csysB2').value), Number(document.getElementById('csysB3').value)];
                const xzPlanePt = [Number(document.getElementById('csysC1').value), Number(document.getElementById('csysC2').value), Number(document.getElementById('csysC3').value)];
                if ([...origin, ...zAxisPt, ...xzPlanePt].some(isNaN)) { statusMsg('All coordinate fields must be valid numbers.', true); return; }
                model.coords.set(cid, { type: 'CORD2R', rid, origin, zAxisPt, xzPlanePt });
            }
            buildGeometries(true);
            statusMsg(`Added CORD2R ${cid}.`);
        });
    });
    
    // Label Toggles
    for (const el of [showNodeIds, showElemIds, showSPCLabels, showLoadLabels, loadLabelMode, cullLabelsToggle]) {
      if(el) el.addEventListener('change', rebuildLabels);
    }

    contextMenu.addEventListener('contextmenu', (ev) => {
      ev.preventDefault();
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      let entity = null, eType = null;
      const loadHits = raycaster.intersectObjects([forceGroup, momentGroup, ploadGroup], true);
      if (loadHits.length) { let parent = loadHits[0].object; while(parent && !parent.userData.type) parent = parent.parent; if(parent) { entity = parent; eType = parent.userData.type; } }
      if (!entity) { const spcHits = raycaster.intersectObjects(spcGroup.children, true); if (spcHits.length) { entity = spcHits[0].object; eType = 'spc'; } }
      if (!entity) {
        raycaster.params.Line.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.01 : 0.1);
        const hits = raycaster.intersectObjects([meshShell, meshLines, bushGroup].filter(Boolean), true);
        if (hits.length > 0) {
            eType = 'elem'; const hit = hits[0];
            if (hit.object.type === 'Sprite') { entity = hit.object.userData; } else if (hit.object === meshShell) { entity = faceToElem[hit.faceIndex]; } else if (hit.object === meshLines) { entity = lineToElem[hit.faceIndex]; }
        }
      }
      if (!entity && points) {
        raycaster.params.Points.threshold = (model.bbox ? model.bbox.getSize(new THREE.Vector3()).length() * 0.005 : 0.1);
        const nhits = raycaster.intersectObject(points); if (nhits.length) { const i = nhits[0].index; entity = { i: i, nid: model.indexToNid[i] }; eType = 'node'; }
      }
      if (!entity) { contextMenu.style.display = 'none'; return; }
      contextMenu.innerHTML = '';
      const makeItem = (label, fn) => { const div = document.createElement('div'); div.textContent = label; div.addEventListener('click', () => { fn(); contextMenu.style.display = 'none'; }); return div; };
      if (eType === 'elem') {
          const targetEids = (selection.elems.size > 1 && selection.elems.has(entity.eid)) ? [...selection.elems] : [entity.eid];
          const plural = targetEids.length > 1 ? 's' : '';
          contextMenu.appendChild(makeItem(`Hide ${targetEids.length > 1 ? targetEids.length + ' ' : ''}Element${plural}`, () => { historyManager.recordAction(() => { targetEids.forEach(eid => hidden.elems.add(eid)); if (targetEids.length > 1) selection.elems.clear(); buildGeometries(true); updateSelectionUI(); highlightSelectedElementVisual(); }); }));
          contextMenu.appendChild(makeItem(`Delete ${targetEids.length > 1 ? targetEids.length + ' ' : ''}Element${plural}`, () => { historyManager.recordAction(() => { for (const eid of targetEids) { for (const type in model.elems) { const idx = model.elems[type].findIndex(e => e.eid === eid); if (idx > -1) { model.elems[type].splice(idx, 1); break; } } hidden.elems.delete(eid); } if (targetEids.length > 1) selection.elems.clear(); buildGeometries(true); refreshCounts(); rebuildLabels(); updateSelectionUI(); highlightSelectedElementVisual(); }); }));
          contextMenu.appendChild(makeItem('Edit', () => { selection.elems = new Set([entity.eid]); selection.nodes = new Set(entity.nodes); selectModeEl.value = 'element'; selectMode = 'element'; updateSelectionVisual(); highlightSelectedElementVisual(); updateSelectionUI(); }));
      } else {
         contextMenu.appendChild(makeItem('Hide', () => { historyManager.recordAction(() => { if (eType === 'load') { if (entity?.userData?.data) hidden.loads.add(entity.userData.data); buildGeometries(true); } else if (eType === 'spc') { if (entity?.userData?.key) hidden.spc.add(entity.userData.key); buildGeometries(true); } else if (eType === 'node') { hidden.nodes.add(entity.nid); statusMsg('Node hiding not supported.', true); } rebuildLabels(); }); }));
      }
      contextMenu.appendChild(makeItem('Show All', () => { hidden.elems.clear(); hidden.loads.clear(); hidden.spc.clear(); hidden.nodes.clear(); buildGeometries(true); rebuildLabels(); }));
      contextMenu.style.left = (ev.clientX + 2) + 'px'; contextMenu.style.top = (ev.clientY + 2) + 'px'; contextMenu.style.display = 'block';
    });
    document.addEventListener('click', (e) => { if (contextMenu && !contextMenu.contains(e.target)) { contextMenu.style.display = 'none'; } });

    if (btnAddNode) {
      btnAddNode.addEventListener('click', () => {
        historyManager.recordAction(() => {
            let val = newNid.value.trim(), nid = parseInt(val);
            if (isNaN(nid) || model.nodes.has(nid)) { nid = (model.nodes.size > 0 ? Math.max(...model.nodes.keys()) : 0) + 1; }
            const x = Number(newX.value||0), y=Number(newY.value||0), z=Number(newZ.value||0);
            const cp = Number(newCP.value || 0);
            const cd = Number(newCD.value || 0);
            const ps = newPS.value || '';
            const hadNodes = model.nodes.size > 0;
            model.nodes.set(nid, { x, y, z, cp, cd, ps });
            const nidsArr = Array.from(model.nodes.keys()).sort((a,b) => a - b);
            model.indexToNid = nidsArr;
            model.nodeIndex = new Map(nidsArr.map((nid,i) => [nid, i]));
            hidden.nodes.delete(nid);
            buildGeometries(hadNodes); if (!hadNodes) fitView();
            refreshCounts(); statusMsg('Added node ' + nid); newNid.value = '';
        });
      });
    }

    if (elemType) {
        const updateElemUI = () => {
            const type = elemType.value, card = document.getElementById('addElementCard'); if (!card) return;
            const showRow = (sel, cond) => { const el = card.querySelector(sel); if(el) el.closest('.row').style.display = cond ? '' : 'none'; };
            const n1Label = document.getElementById('elemN1Label');
            showRow('#elemN2', /cbar|cbeam|cbush|ctria3|cquad4/.test(type)); showRow('#elemN3', /ctria3|cquad4/.test(type)); showRow('#elemN4', type === 'cquad4'); showRow('#elemCmRow', /rbe2|rbe3/.test(type)); showRow('#elemDepNodesRow', type === 'rbe2'); showRow('#elemIndNodesRow', type === 'rbe3'); showRow('#elemPid', !/rbe2|rbe3/.test(type));
            if (type === 'rbe2') { n1Label.textContent = 'Indep Node'; } else if (type === 'rbe3') { n1Label.textContent = 'Dep Node'; } else { n1Label.textContent = 'Node 1'; }
            const cquad4ToggleRow = document.getElementById('cquad4AdvancedToggleRow');
            const cquad4Options = document.getElementById('cquad4AdvancedOptions');
            cquad4ToggleRow.style.display = (type === 'cquad4') ? '' : 'none';
            if(type !== 'cquad4' && cquad4Options.style.display !== 'none') {
              cquad4Options.style.display = 'none';
              document.getElementById('cquad4AdvancedToggle').textContent = 'Advanced ▼';
            }
        };
        elemType.addEventListener('change', updateElemUI);
        const cquad4Toggle = document.getElementById('cquad4AdvancedToggle');
        const cquad4Options = document.getElementById('cquad4AdvancedOptions');
        if (cquad4Toggle && cquad4Options) {
          cquad4Toggle.addEventListener('click', () => {
              const isHidden = cquad4Options.style.display === 'none';
              cquad4Options.style.display = isHidden ? '' : 'none';
              cquad4Toggle.textContent = isHidden ? 'Advanced ▲' : 'Advanced ▼';
          });
        }
        updateElemUI();
    }

    if (btnAddElement) {
        btnAddElement.addEventListener('click', () => {
            historyManager.recordAction(() => {
                let eid = parseInt(elemEid.value);
                if (isNaN(eid)) {
                    const allEids = Object.values(model.elems).flat().map(e => e.eid);
                    eid = allEids.length > 0 ? Math.max(...allEids) + 1 : 1;
                }
                const type = elemType.value, pid=Number(elemPid.value||1), n1=parseInt(elemN1.value), n2=parseInt(elemN2.value), n3=parseInt(elemN3.value), n4=parseInt(elemN4.value), cm = elemCm.value||'123456';
                const getRbeNodes = (inputEl) => { const csv = inputEl.value.split(/[\s,]+/).map(s => parseInt(s)).filter(v => !isNaN(v) && model.nodes.has(v)); return csv.length > 0 ? csv : Array.from(selection.nodes).filter(nid => nid !== n1); };
                const deps = type === 'rbe2' ? getRbeNodes(elemDepNodes) : [], inds = type === 'rbe3' ? getRbeNodes(elemIndNodes) : [];
                let newElem, msg = '';
                try {
                    switch (type) {
                        case 'cquad4': {
                          if ([n1, n2, n3, n4].some(isNaN)) throw new Error('CQUAD4 requires 4 valid node IDs.');
                          newElem = { eid, pid, n: [n1, n2, n3, n4], type: 'CQUAD4' };
                          const getVal = (id, isInt=false) => {
                              const val = isInt ? parseInt(document.getElementById(id).value) : parseFloat(document.getElementById(id).value);
                              return isNaN(val) ? undefined : val;
                          };
                          newElem.thetaMcid = getVal('elemThetaMcid');
                          newElem.zoffs = getVal('elemZoffs');
                          newElem.tflag = getVal('elemTflag', true);
                          const t = [getVal('elemT1'), getVal('elemT2'), getVal('elemT3'), getVal('elemT4')];
                          if (t.some(v => v !== undefined)) newElem.T = t;
                          model.elems.quad.push(newElem);
                          msg = `Added CQUAD4 ${eid}`;
                          break;
                        }
                        case 'ctria3': if ([n1,n2,n3].some(isNaN)) throw new Error('CTRIA3 requires 3 valid node IDs.'); newElem = { eid, pid, n: [n1, n2, n3], type: 'CTRIA3' }; model.elems.tri.push(newElem); msg = `Added CTRIA3 ${eid}`; break;
                        case 'cbar': case 'cbeam': case 'cbush': if ([n1,n2].some(isNaN)) throw new Error(`${type.toUpperCase()} requires 2 valid node IDs.`); newElem = { eid, pid, n: [n1, n2], type: type.toUpperCase() }; model.elems[type.replace('c','')].push(newElem); msg = `Added ${type.toUpperCase()} ${eid}`; break;
                        case 'rbe2': if (isNaN(n1) || deps.length === 0) throw new Error('RBE2 requires a GN and dependent nodes.'); newElem = { eid, gn: n1, cm, deps, type: 'RBE2' }; model.elems.rbe2.push(newElem); msg = `Added RBE2 ${eid}`; break;
                        case 'rbe3': if (isNaN(n1) || inds.length === 0) throw new Error('RBE3 requires a GN and independent nodes.'); newElem = { eid, gn: n1, cm, inds, type: 'RBE3' }; model.elems.rbe3.push(newElem); msg = `Added RBE3 ${eid}`; break;
                    }
                    statusMsg(msg); buildGeometries(true); recomputeBBox(); refreshCounts();
                } catch (e) { statusMsg(e.message, true); }
            });
        });
    }

    window.addEventListener('dragover', (e)=>{ e.preventDefault(); dropzone.style.display='flex'; });
    window.addEventListener('dragleave', (e)=>{ if (e.target.id === 'app') dropzone.style.display='none'; });
    window.addEventListener('drop', async (e)=>{ e.preventDefault(); dropzone.style.display='none'; const f=e.dataTransfer.files?.[0]; if (!f) return; const text=await f.text(); loadFromText(text, f.name); });
    function loadFromText(text, name='model.dat') { try { parseBDF(text); buildGeometries(); statusMsg('Loaded '+name+'. Nodes: '+model.indexToNid.length); historyManager.clear(); updateClipSliderRange(); } catch (e) { console.error(e); statusMsg('Failed to load file (see console).', true); } }
    function refreshCounts(){ const nNodes=model.indexToNid.length, nElems=Object.values(model.elems).reduce((s, a)=>s+a.length,0), nLoads=(model.loads.force?.length||0)+(model.loads.pload?.length||0)+(model.loads.moment?.length||0), nSPC=model.spc1.reduce((s,g)=>s+g.nodes.length,0); }
    function statusMsg(msg, isErr=false){ statusEl.textContent=msg; statusEl.classList.toggle('danger', !!isErr); }
    function onResize(){
        const r=document.getElementById('viewport').getBoundingClientRect();
        const aspect = r.width / r.height;

        renderer.setSize(r.width, r.height, false);
        labelRenderer.setSize(r.width, r.height);

        perspectiveCamera.aspect = aspect;
        perspectiveCamera.updateProjectionMatrix();

        const h = orthographicCamera.top;
        orthographicCamera.left = -h * aspect;
        orthographicCamera.right = h * aspect;
        orthographicCamera.updateProjectionMatrix();

        if (camera.isOrthographicCamera) {
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        } else {
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }
    }
    window.addEventListener('resize', onResize); onResize();

    function updateUndoRedoButtons() { btnUndo.disabled = historyManager.pointer <= 0; btnRedo.disabled = historyManager.pointer >= historyManager.stack.length - 1; }
    btnUndo.addEventListener('click', () => historyManager.undo());
    btnRedo.addEventListener('click', () => historyManager.redo());
    window.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); btnUndo.click(); } if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); btnRedo.click(); } });
    
    // Add collapsible functionality
    document.querySelectorAll('.card-header').forEach(header => {
        header.addEventListener('click', () => {
            header.parentElement.classList.toggle('collapsed');
        });
    });

    // --- Clipping Plane UI ---
    function updateClipSliderRange() {
        if (model.bbox && !model.bbox.isEmpty()) {
            const box = model.bbox;
            const normal = clippingPlane.normal;
            
            const corners = [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z), new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z), new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z), new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z), new THREE.Vector3(box.max.x, box.max.y, box.max.z),
            ];

            let min_d = Infinity, max_d = -Infinity;
            corners.forEach(corner => {
                const d = corner.dot(normal);
                if (d < min_d) min_d = d;
                if (d > max_d) max_d = d;
            });

            const buffer = (max_d - min_d) * 0.05; 
            min_d -= buffer;
            max_d += buffer;

            clipOffsetSlider.min = min_d;
            clipOffsetSlider.max = max_d;
            clipOffsetSlider.step = (max_d - min_d) / 200;
        }
        updateClipSliderFromPlane();
    }

    function updateClipSliderFromPlane() {
        clipOffsetSlider.value = -clippingPlane.constant;
    }
    
    clippingToggle.addEventListener('change', (e) => {
        renderer.localClippingEnabled = e.target.checked;
        if(clipPlaneHelper) clipPlaneHelper.visible = e.target.checked;
    });

    clipPlaneSelect.addEventListener('change', () => {
        const val = clipPlaneSelect.value;
        const currentOriginPoint = new THREE.Vector3(0,0,0);
        if (model.bbox) model.bbox.getCenter(currentOriginPoint);

        const normal = new THREE.Vector3();
        if (val === 'x') normal.set(1, 0, 0); // YZ Plane
        else if (val === 'y') normal.set(0, 1, 0); // XZ visual, but in Three.js it's Y
        else if (val === 'z') normal.set(0, 0, 1); // XY visual, but in Three.js it's Z

        clippingPlane.setFromNormalAndCoplanarPoint(normal, currentOriginPoint);
        updateClipSliderRange();
    });

    flipClipPlane.addEventListener('click', () => {
        clippingPlane.negate();
        updateClipSliderFromPlane();
    });
    
    setClipOriginToSelection.addEventListener('click', () => {
        if (selection.nodes.size > 0) {
            const centroid = centroidOf(selection.nodes);
            clippingPlane.setFromNormalAndCoplanarPoint(clippingPlane.normal, centroid);
            updateClipSliderRange();
        } else {
            statusMsg('Select one or more nodes to set clipping origin.', true);
        }
    });

    clipOffsetSlider.addEventListener('input', () => {
        clippingPlane.constant = -parseFloat(clipOffsetSlider.value);
    });

    canvas.addEventListener('wheel', (e) => {
        if (e.ctrlKey && renderer.localClippingEnabled) {
            e.preventDefault();
            e.stopPropagation();
            const range = parseFloat(clipOffsetSlider.max) - parseFloat(clipOffsetSlider.min);
            if (range === 0) return;
            const step = range / 200;
            const newValue = parseFloat(clipOffsetSlider.value) - Math.sign(e.deltaY) * step;
            
            clipOffsetSlider.value = Math.max(parseFloat(clipOffsetSlider.min), Math.min(parseFloat(clipOffsetSlider.max), newValue));
            clippingPlane.constant = -parseFloat(clipOffsetSlider.value);
        }
    }, { passive: false });

    // --- Label Culling Logic ---
    function updateLabelVisibility() {
        if (!cullLabelsToggle.checked) {
            allLabelGroups.forEach(group => group.children.forEach(lbl => lbl.visible = lbl.parent.visible));
            return;
        }

        const visibleRects = [];
        const canvasRect = canvas.getBoundingClientRect();
        const labels = allLabelGroups.flatMap(g => g.children);
        
        if (labels.length === 0) return;

        labels.forEach(l => l.userData.distance = camera.position.distanceToSquared(l.position));
        labels.sort((a, b) => a.userData.distance - b.userData.distance);

        for (const label of labels) {
            if (!label.parent.visible) {
              label.visible = false;
              continue;
            }

            const pos = new THREE.Vector3().setFromMatrixPosition(label.matrixWorld);
            const proj = pos.project(camera);

            if (proj.z > 1 || proj.z < -1) {
                label.visible = false;
                continue;
            }

            const screenX = (proj.x * 0.5 + 0.5) * canvasRect.width;
            const screenY = (-proj.y * 0.5 + 0.5) * canvasRect.height;
            
            const width = label.element.offsetWidth;
            const height = label.element.offsetHeight;

            const rect = {
                x: screenX - width / 2,
                y: screenY - height / 2,
                x2: screenX + width / 2,
                y2: screenY + height / 2,
            };

            let intersects = false;
            for (const other of visibleRects) {
                if (!(rect.x2 < other.x || rect.x > other.x2 || rect.y2 < other.y || rect.y > other.y2)) {
                    intersects = true;
                    break;
                }
            }

            if (!intersects) {
                label.visible = true;
                visibleRects.push(rect);
            } else {
                label.visible = false;
            }
        }
    }

(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  const staticScale = Number(symbolSize.value || 1.0);
  if (staticScale > 0) {
    const dist = camera.position.distanceTo(controls.target);
    const scaleFactor = dist * 0.007;
    const updateSymbolScale = (obj) => { if (obj.userData.isStaticSymbol) { const newScale = scaleFactor * obj.userData.baseScale * staticScale; if (newScale > 1e-5) { obj.scale.set(newScale, newScale, newScale); } } };
    for (const child of forceGroup.children) updateSymbolScale(child); for (const child of momentGroup.children) updateSymbolScale(child); for (const child of ploadGroup.children) updateSymbolScale(child); for (const child of spcGroup.children) updateSymbolScale(child);
  }
  
  if (camera.position.distanceToSquared(lastCameraPos) > CULLING_THRESHOLD_SQUARED || 
      !camera.quaternion.equals(lastCameraQuat)) {
      updateLabelVisibility();
      lastCameraPos.copy(camera.position);
      lastCameraQuat.copy(camera.quaternion);
  }

  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
  if (compassRenderer) { const offset = new THREE.Vector3().subVectors(camera.position, controls.target); offset.setLength(2.5); compassCamera.position.copy(offset); compassCamera.lookAt(0, 0, 0); compassRenderer.render(compassScene, compassCamera); }
})();
  
    historyManager.clear();
  </script>
</body>
</html>


